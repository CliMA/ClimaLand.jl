<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Intro to multi-component models · ClimaLSM.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">ClimaLSM.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">APIs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">ClimaLSM</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/ClimaLSM/">ClimaLSM</a></li><li><a class="tocitem" href="../../../APIs/Regridder/">Parameter Dataset Tools</a></li><li><a class="tocitem" href="../../../APIs/SharedUtilities/">Shared Utilities</a></li><li><a class="tocitem" href="../../../APIs/Soil/">Soil Energy and Hydrology</a></li><li><a class="tocitem" href="../../../APIs/SoilBiogeochemistry/">Soil Biogeochemistry</a></li><li><a class="tocitem" href="../../../APIs/Vegetation/">Vegetation Models</a></li><li><a class="tocitem" href="../../../APIs/SurfaceWater/">Surface Water Models</a></li><li><a class="tocitem" href="../../../APIs/Bucket/">Bucket Model</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../Contributing/">Contribution guide</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">For model developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model_tutorial/">Using AbstractModel functionality</a></li><li class="is-active"><a class="tocitem" href>Intro to multi-component models</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#The-individual-component-models-II-Surface-Water"><span>The individual component models II - Surface Water</span></a></li><li class="toplevel"><a class="tocitem" href="#An-LSM-with-pond-and-soil:"><span>An LSM with pond and soil:</span></a></li><li class="toplevel"><a class="tocitem" href="#Advantages-and-disadvantages"><span>Advantages and disadvantages</span></a></li></ul></li><li><a class="tocitem" href="../domain_tutorial/">Intro to ClimaLSM Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Running simulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-2-1" type="checkbox"/><label class="tocitem" for="menuitem-4-2-1"><span class="docs-label">Soil modeling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Soil/richards_equation/">Richards Equation</a></li><li><a class="tocitem" href="../../Soil/soil_energy_hydrology/">Energy and Hydrology</a></li><li><a class="tocitem" href="../../Soil/freezing_front/">Phase Changes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2-2"><span class="docs-label">Bucket LSM</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Bucket/bucket_tutorial/">Introduction to the Land Bucket Model</a></li><li><a class="tocitem" href="../../Bucket/coupled_bucket/">Setting up a Coupled Simulation</a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">For model developers</a></li><li class="is-active"><a href>Intro to multi-component models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Intro to multi-component models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaLSM.jl/../../../.." title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>The <code>AbstractModel</code> <a href="https://clima.github.io/ClimaLSM.jl/dev/generated/model_tutorial">tutorial</a> describes how a user can run simulations of a physical system governed by differential equations. In this framework, the user must define a model type for their problem, which contains all of the information required to set up the system of equations. By extending the methods for <code>make_rhs(model)</code>, <code>prognostic_variables(model)</code>, etc, the information stored in the <code>model</code> is used to make the system of equations. Given initial conditions, these equations can then be stepped forward in time using the time-stepper of your choice (we are set up to use OrdinaryDiffEq.jl currently).</p><p>The benefit of this framework is that it can be used for both individual components of an LSM (soil, snow, rivers, canopy biophysics, carbon...) <strong>as well as the LSM itself</strong>. Here we explain how a simple single column two component model can be set up using this software interface. Additionally, we demonstrate here the use of the auxiliary or cache variables, which were mentioned but not needed in the Henon-Heiles problem solved in the prior tutorial.</p><p>We&#39;ll first demonstrate how to set up two components in standalone mode, before spending time explaining the LSM setup. In our example, we have a component which accounts for soil hydrology via the Richardson-Richards (RR) equation.  Our second component is a surface water model without lateral flow (standing water, as in a pond). For more details on these models, and how they were set up, please feel free to look at the source code <a href="https://github.com/CliMA/ClimaLSM.jl/blob/main/src/Soil/Soil.jl">here</a> and <a href="https://github.com/CliMA/ClimaLSM.jl/blob/main/src/SurfaceWater/Pond.jl">here</a>. This tutorial focuses on using the <code>AbstractModel</code>s framework to set up the equations, rather than on running simulations.</p><p>First, let&#39;s load the required modules:</p><pre><code class="language-julia hljs">if !(&quot;.&quot; in LOAD_PATH)
    push!(LOAD_PATH, &quot;.&quot;)
end
using ClimaLSM
using ClimaLSM.Domains: LSMSingleColumnDomain, Column
using ClimaLSM.Soil
using ClimaLSM.Pond

FT = Float64;</code></pre><h1 id="The-individual-component-models-I-Soil-Hydrology"><a class="docs-heading-anchor" href="#The-individual-component-models-I-Soil-Hydrology">The individual component models I - Soil Hydrology</a><a id="The-individual-component-models-I-Soil-Hydrology-1"></a><a class="docs-heading-anchor-permalink" href="#The-individual-component-models-I-Soil-Hydrology" title="Permalink"></a></h1><p>The RR equation for the volumetric water content of soil is given by</p><p><span>$\frac{\partial ϑ}{\partial t} = -∇ ⋅ (-K∇(ψ+z)) + S(x,y,z, t)$</span></p><p>In order to solve this, one must specify:</p><ul><li>boundary conditions,</li><li>relevant parameters (closure models for <code>K</code> and <code>ψ</code>),</li><li>a domain and a spatial discretization scheme,</li><li>additional source terms <code>S</code>, if applicable,</li><li>a time-stepping algorithm,</li><li>initial conditions.</li></ul><p>We make the distinction between the spatially discretized equations (for which you need parameters, boundary conditions, source terms, and domain/ discretization scheme information in order to write down and evaluate), and the simulation you want to run (for which you need the equations, initial conditions, a time span, and a time-stepping scheme in order to specify completely).</p><p>Here, we&#39;ll focus on what you need to write the equations. In the design of all CliMA systems, everything you need to write the equations is stored in the model structure itself, so that we can call <code>make_ode_function(model)</code> and get back a function which computes the time derivative of the prognostic variables, which the ODE timestepper needs to advance the state forward in time.</p><p>For the RR equation, we can create this as follows. First, we specify parameters:</p><pre><code class="language-julia hljs">ν = FT(0.495);
K_sat = FT(0.0443 / 3600 / 100); # m/s
S_s = FT(1e-3); #inverse meters
vg_n = FT(2.0);
vg_α = FT(2.6); # inverse meters
vg_m = FT(1) - FT(1) / vg_n;
θ_r = FT(0);
soil_ps = Soil.RichardsParameters{FT}(ν, vg_α, vg_n, vg_m, K_sat, S_s, θ_r);</code></pre><p>Next, let&#39;s define the spatial domain and discretization:</p><pre><code class="language-julia hljs">zmax = FT(0);
zmin = FT(-1);
nelems = 20;
soil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);</code></pre><p>And boundary conditions and source terms (none currently):</p><pre><code class="language-julia hljs">top_flux_bc = FluxBC((p, t) -&gt; eltype(t)(0.0))
bot_flux_bc = FluxBC((p, t) -&gt; eltype(t)(0.0))
sources = ()
boundary_fluxes = (; water = (top = top_flux_bc, bottom = bot_flux_bc))</code></pre><pre><code class="nohighlight hljs">(water = (top = ClimaLSM.Soil.FluxBC(Main.var&quot;##315&quot;.var&quot;#1#2&quot;()), bottom = ClimaLSM.Soil.FluxBC(Main.var&quot;##315&quot;.var&quot;#3#4&quot;())),)</code></pre><p>With this information, we can make our model:</p><pre><code class="language-julia hljs">soil = Soil.RichardsModel{FT}(;
    parameters = soil_ps,
    domain = soil_domain,
    boundary_conditions = boundary_fluxes,
    sources = sources,
);</code></pre><p>We also can create the soil prognostic and auxiliary <code>ClimaCore.Field.FieldVector</code>s using the default method for <code>initialize</code>,</p><pre><code class="language-julia hljs">Y_soil, p_soil, coords_soil = initialize(soil);</code></pre><p>and we can set up the ode function using the default as well,</p><pre><code class="language-julia hljs">soil_ode! = make_ode_function(soil);</code></pre><p>which computes, for the column domain,</p><p><span>$-\frac{∂ }{∂z} (-K\frac{∂(ψ+z)}{∂ z})$</span></p><p>for each value of ϑ on the mesh of our <code>soil_domain</code>.</p><p>Note that the soil model does include both hydraulic <code>K</code> and pressure head <code>ψ</code> in the auxiliary vector, so the fields <code>p_soil.soil.K</code> and <code>p_soil.soil.ψ</code> are present. These are automatically updated first in each call to <code>soil_ode!</code>, as follows:</p><pre><code class="language-julia hljs">function soil_ode!(dY, Y, p, t)
         update_aux!(p,Y,t)
         rhs!(dY, Y, p, t)
end</code></pre><p>where <code>update_aux!</code> updates <code>K</code>, and <code>ψ</code>, in <code>p</code>, in place, and <code>rhs!</code> computes the divergence of the Darcy flux, using the updated <code>p</code>, and then updates <code>dY</code> in place with the computed values. For this reason, the <code>p</code> vector does not need to be set to some initial condition consistent with Y_soil.soil.ϑ(t=0) before starting a simulation, though initial conditions must be given for <code>Y</code>.</p><p>Note also that we have defined methods <code>make_rhs</code> and <code>make_update_aux</code>, which only take the <code>model</code> as argument, and which return the functions <code>update_aux!</code> and <code>rhs!</code>, <a href="https://github.com/CliMA/ClimaLSM.jl/blob/9e2b8df6d8d5b7f878a5b0f02e2bf80fa66aec33/src/Soil/Soil.jl#L292">here</a> and <a href="https://github.com/CliMA/ClimaLSM.jl/blob/9e2b8df6d8d5b7f878a5b0f02e2bf80fa66aec33/src/Soil/Soil.jl#L400">here</a>.</p><p>Lastly, the coordinates returned by <code>initialize</code> contain the z-coordinates of the centers of the finite difference layers used for spatial discretization of the PDE.</p><h1 id="The-individual-component-models-II-Surface-Water"><a class="docs-heading-anchor" href="#The-individual-component-models-II-Surface-Water">The individual component models II - Surface Water</a><a id="The-individual-component-models-II-Surface-Water-1"></a><a class="docs-heading-anchor-permalink" href="#The-individual-component-models-II-Surface-Water" title="Permalink"></a></h1><p>The pond model has a single variable, the pond height η, which satisfies the ODE:</p><p><span>$\frac{∂ η}{∂ t} = -(P - I) = R,$</span></p><p>where P is the precipitation, I the infiltration into the soil, and R is the runoff. Note that P, I &lt; 0 indicates flow in the -ẑ direction.</p><p>To write down the pond equations, we need to specify</p><ul><li>P</li><li>I</li></ul><p>which are akin to boundary conditions. In standalone mode,  one would need to pass in <strong>prescribed</strong> functions of time and store them inside our pond model, since again, the pond model structure must contain everything needed to make the ode function:</p><pre><code class="language-julia hljs">precipitation(t::T) where {T} = t &lt; T(20) ? -T(1e-5) : T(0.0) # m/s

infiltration(t::T) where {T} = -T(1e-6) #m/s
pond_model = Pond.PondModel{FT}(;
    runoff = PrescribedRunoff{FT}(precipitation, infiltration),
);</code></pre><p>Here, <code>PrescribedRunoff</code> is the structure holding the prescribed driving functions for <code>P</code> and <code>I</code>.</p><p>Again we can initialize the state vector and auxiliary vectors:</p><pre><code class="language-julia hljs">Y_pond, p_pond, coords_pond = initialize(pond_model);</code></pre><p>We can make the ode function in the same way, for stepping the state forward in time:</p><pre><code class="language-julia hljs">pond_ode! = make_ode_function(pond_model);</code></pre><p>The <code>pond_ode!</code> function works in the same way as for the soil model:</p><pre><code class="language-julia hljs">function pond_ode!(dY, Y, p, t)
         update_aux!(p,Y,t)
         rhs!(dY, Y, p, t)
end</code></pre><p>but the <code>update_aux!</code> does not alter <code>p</code> at all in this case. The pond model does not have auxiliary variables, so <code>p_pond</code> is empty.</p><p>The coordinates here are relatively meaningless - we are solving for the pond height at a point in space on the surface of the Earth, and by default this assigns a <code>Point</code> domain, with a coordinate of <code>z_sfc = 0</code>. In a simulation with horizontal resolution, the <code>coordinates</code> returned would be the <code>(x,y,z=z_sfc(x,y))</code> coordinates of the surface, which are more useful.</p><h1 id="An-LSM-with-pond-and-soil:"><a class="docs-heading-anchor" href="#An-LSM-with-pond-and-soil:">An LSM with pond and soil:</a><a id="An-LSM-with-pond-and-soil:-1"></a><a class="docs-heading-anchor-permalink" href="#An-LSM-with-pond-and-soil:" title="Permalink"></a></h1><p>The LSM model must contain everything needed to write down the joint system of equations</p><p><span>$\frac{\partial \eta}{\partial t} = -(P(t) - I(ϑ, η, P)) = R,$</span></p><p><span>$\frac{\partial ϑ}{\partial t} = -∇ ⋅ (-K∇(ψ+z)) + S$</span></p><p><span>$-K ∇(ψ+z)|_{z = zmax}  ⋅ ẑ = I(ϑ, η, P)$</span></p><p><span>$-K ∇(ψ+z)|_{z = zmin}  ⋅ ẑ = 0.0.$</span></p><p>These two components interact via the infiltration term <code>I</code>. Infiltration is a boundary condition for the soil, and affects the source term for the surface water equation. Infiltration depends on precipitation, the soil moisture state, and the pond height.</p><p>As in the standalone cases, defining our model requires specifying</p><ul><li>parameters,</li><li>domains, discretizations</li><li>precipitation,</li><li>boundary conditions,</li><li>sources in the soil equation, if any.</li></ul><p>First, let&#39;s make our LSM domain, which now contains information about the subsurface domain and the surface domain. For a single column, this means specifying the boundaries of the soil domain and the number of elements.</p><pre><code class="language-julia hljs">lsm_domain = LSMSingleColumnDomain(; zlim = (zmin, zmax), nelements = nelems);</code></pre><p>The surface domain is again just a <code>Point</code> with <code>z_sfc = zmax</code>.</p><pre><code class="language-julia hljs">lsm_domain.surface</code></pre><pre><code class="nohighlight hljs">ClimaLSM.Domains.Point{Float64, ClimaCore.Spaces.PointSpace{ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}}(0.0, ClimaCore.Spaces.PointSpace{ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}(ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}
  [0.0, 0.05, 0.025, 20.0, 0.05, 20.0, 400.0]))</code></pre><p>The subsurface domain is a column from zmin to zmax:</p><pre><code class="language-julia hljs">lsm_domain.subsurface</code></pre><pre><code class="nohighlight hljs">ClimaLSM.Domains.Column{Float64, ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Spaces.CellCenter, ClimaCore.Topologies.IntervalTopology{ClimaCore.Meshes.IntervalMesh{ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float64}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float64}, Int64}}, NamedTuple{(:bottom, :top), Tuple{Int64, Int64}}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, Matrix{Float64}}}}((-1.0, 0.0), (20,), (:bottom, :top), CenterFiniteDifferenceSpace:
  IntervalTopology on 20-element IntervalMesh of IntervalDomain(ZPoint(-1.0), ZPoint(0.0); boundary_names = (:bottom, :top)))</code></pre><p>Let&#39;s now collect the needed arguments for the soil and pond models:</p><pre><code class="language-julia hljs">soil_args = (parameters = soil_ps, domain = lsm_domain.subsurface, sources = ());
surface_water_args = (domain = lsm_domain.surface,);</code></pre><p>Atmospheric drivers don&#39;t &quot;belong&quot; to either component alone:</p><pre><code class="language-julia hljs">land_args = (precip = precipitation,);
land = LandHydrology{FT}(;
    land_args = land_args,
    soil_model_type = Soil.RichardsModel{FT},
    soil_args = soil_args,
    surface_water_model_type = Pond.PondModel{FT},
    surface_water_args = surface_water_args,
);</code></pre><p>Here, <code>LandHydrology</code> is a type of <code>AbstractModel</code> which has a surface water model (Pond or otherwise) and a soil model (RR, or perhaps otherwise). Note that we pass in the type of the soil and surface water model - these could be more complex, e.g. a river model with lateral flow could be used in place of the <code>Pond</code>. We could also add in a snow component.</p><p>Now, note that we did not specify the infiltration function, like we did in standalone pond mode, nor did we specify boundary conditions for the soil model. Yet, before we stressed that the model needs to have everything required to write down and evaluate the time derivative of the ODEs. So, how does this work?</p><p>Here, the LSM model <strong>constructor</strong> is given the information needed to make both the soil model and the pond model. Then, it is like running the pond and soil model in standalone mode, in series, <strong>except</strong> we have defined methods internally for computing the boundary condition and pond source term correctly, based on <code>I</code>, instead of using prescribed values passed in. The LSM constructor creates the correct <code>boundary_fluxes</code> object for the soil model, and the correct <code>infiltration</code> object for the pond model under the hood.</p><p>To advance the state of the joint system (ϑ, η) from time <code>t</code> to time <code>t+Δt</code>, we must compute the infiltration at <code>t</code>. This value is stored in <code>p.soil_infiltration</code>, and reflects a proper use of the auxiliary or cache state: storing a quantity which we would rather compute once and store, rather than compute twice, once in the soil ode function, and once in the pond ode function. This guarantees the same value is used for both equations. In pseudo code, we have:</p><pre><code class="language-julia hljs">function make_update_aux(land)
         soil_update_aux! = make_update_aux(land.soil)
         surface_update_aux! = make_update_aux(land.surface_water)
         interactions_update_aux! = make_update_aux(land, land.soil, land.surface_water)
         function update_aux!(p,Y,t)
                  surface_update_aux!(p,Y,t) # does nothing to `p`
                  soil_update_aux!(p,Y,t) # updates p.soil.K and p.soil.ψ
                  interactions_update_aux!(p,Y,t) # updates p.soil_infiltration
         end
         return update_aux!
end</code></pre><p>and similarily for the <code>rhs!</code> functions:</p><pre><code class="language-julia hljs">function make_rhs(land)
         soil_rhs! = make_update_aux(land.soil)
         surface_rhs! = make_update_aux(land.surface_water)
         function rhs!(dY,Y,p,t)
                  surface_rhs(dY,Y,p, t), # computes dY.surface.η
                  soil_rhs!(dY,Y,p,t) # computes dY.soil.ϑ
         end
         return rhs!
end</code></pre><p>The <code>ode_function!</code> for the land model is then again just</p><pre><code class="language-julia hljs">function ode_function!(dY, Y, p, t)
         update_aux!(p,Y,t)
         rhs!(dY, Y, p, t)
end</code></pre><p>In the above, we showed explicitly what occurs by hardcoding the <code>rhs!</code>, <code>update_aux!</code> with names for <code>soil</code> and <code>surface_water</code>. In reality, this is done by looping over the components of the land model, meaning that we can use the same code internally for land models with different components.</p><p>A similar composition occurs for initializing the state itself: Calling <code>initialize(land)</code> does four things:</p><ul><li>initialize(land.soil)</li><li>initialize(land.surface_water)</li><li>initializes interaction terms, like p.soil_infiltration</li><li>append these into Y, p, and coords:</li></ul><pre><code class="language-julia hljs">Y, p, coords = initialize(land);</code></pre><p>We have volumetric liquid water fraction:</p><pre><code class="language-julia hljs">propertynames(Y.soil)</code></pre><pre><code class="nohighlight hljs">(:ϑ_l,)</code></pre><p>and surface height of the pond:</p><pre><code class="language-julia hljs">propertynames(Y.surface_water)</code></pre><pre><code class="nohighlight hljs">(:η,)</code></pre><p>as well as auxiliary variables for the soil:</p><pre><code class="language-julia hljs">propertynames(p.soil)</code></pre><pre><code class="nohighlight hljs">(:K, :ψ)</code></pre><p>and nothing for surface water:</p><pre><code class="language-julia hljs">propertynames(p.surface_water)</code></pre><pre><code class="nohighlight hljs">()</code></pre><p>and the shared interaction term</p><pre><code class="language-julia hljs">propertynames(p)</code></pre><pre><code class="nohighlight hljs">(:soil_infiltration, :soil, :surface_water)</code></pre><p>and finally, coordinates - useful for visualization of solutions:</p><pre><code class="language-julia hljs">coords.subsurface</code></pre><pre><code class="nohighlight hljs">ClimaCore.Geometry.ZPoint{Float64}-valued Field:
  z: [-0.975, -0.925, -0.875, -0.825, -0.775, -0.725, -0.675, -0.625, -0.575, -0.525, -0.475, -0.425, -0.375, -0.325, -0.275, -0.225, -0.175, -0.125, -0.075, -0.025]</code></pre><p>and the coordinates of the surface variables:</p><pre><code class="language-julia hljs">coords.surface</code></pre><pre><code class="nohighlight hljs">ClimaCore.Geometry.ZPoint{Float64}-valued Field:
  z: [0.0]</code></pre><p>And we can make the ode function as before:</p><pre><code class="language-julia hljs">land_ode! = make_ode_function(land);</code></pre><p>Next up would be to set initial conditions, choose a timestepping scheme, and run your simulation.</p><h1 id="Advantages-and-disadvantages"><a class="docs-heading-anchor" href="#Advantages-and-disadvantages">Advantages and disadvantages</a><a id="Advantages-and-disadvantages-1"></a><a class="docs-heading-anchor-permalink" href="#Advantages-and-disadvantages" title="Permalink"></a></h1><p>Some advantages to our interface design are as follows:</p><ul><li>a developer only needs to learn a few concepts (<code>rhs!</code>, prognostic vs. aux variables, <code>update_aux!</code>, <code>initialize</code>, domains) to make a model which can be run in standalone or work with other components.</li><li>likewise, a user only needs to learn one interface to run all models, regardless of if they are standalone components or LSMs with multiple componnents.</li><li>the <code>ode_function!</code>is completely seperate from the timestepping scheme used, so any scheme can be used (with the exception of mixed implicit/explicit schemes, which we can&#39;t handle yet).</li><li>although we wrote it here in a <span>$hardwired$</span> fashion for surface water and soil, the <code>update_aux!</code>, <code>rhs!</code>, etc. many methods for LSM models generalize to any number and mix of components. One just needs to write a new model type (e.g. <code>BiophysicsModel &lt;: AbstractModel</code> for a vegetation and carbon component model) and the appropriate <code>interaction</code> methods for that model.</li><li>the order in which the components are treated in the rhs or in update aux does not matter. What matters is that auxiliary/cache variables are updated first, and within this update, interactions are updated last. We assume that the rhs! function for a component only needs the entire <code>p</code> and <code>Y.component</code> in making this statement. Similarily, updating the aux variables of a single component does not require interaction variables. Yhis is also the same as saying they can be run in <em>standalone</em> mode.</li><li>the code is also modular in terms of swapping out a simple component model for a more complex version.</li></ul><p>Possible disadvantages to our interface design:</p><ul><li>Even in standalone model, variables are accessed in a nested way: Y.soil, p.soil, etc, which is excessive.</li><li>To accomodate the fact that some components involve PDEs, a developer for purely ODE based component does need to at least handle <code>ClimaCore.Field.FieldVector</code>s.</li><li>standalone models need to play by the rules of <code>AbstractModel</code>s, and LSMs need to play by the rules of <code>ClimaLSM.jl</code>.</li></ul><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model_tutorial/">« Using AbstractModel functionality</a><a class="docs-footer-nextpage" href="../domain_tutorial/">Intro to ClimaLSM Domains »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 20 January 2023 00:36">Friday 20 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
