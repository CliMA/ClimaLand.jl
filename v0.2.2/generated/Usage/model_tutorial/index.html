<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using AbstractModel functionality · ClimaLSM.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">ClimaLSM.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">APIs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">ClimaLSM</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../APIs/ClimaLSM/">ClimaLSM</a></li><li><a class="tocitem" href="../../../APIs/Regridder/">Parameter Dataset Tools</a></li><li><a class="tocitem" href="../../../APIs/SharedUtilities/">Shared Utilities</a></li><li><a class="tocitem" href="../../../APIs/Soil/">Soil Energy and Hydrology</a></li><li><a class="tocitem" href="../../../APIs/SoilBiogeochemistry/">Soil Biogeochemistry</a></li><li><a class="tocitem" href="../../../APIs/Vegetation/">Vegetation Models</a></li><li><a class="tocitem" href="../../../APIs/SurfaceWater/">Surface Water Models</a></li><li><a class="tocitem" href="../../../APIs/Bucket/">Bucket Model</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../Contributing/">Contribution guide</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">For model developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Using AbstractModel functionality</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Optional-auxiliary-variables"><span>Optional auxiliary variables</span></a></li><li class="toplevel"><a class="tocitem" href="#The-Model"><span>The Model</span></a></li><li class="toplevel"><a class="tocitem" href="#Right-hand-side-function"><span>Right hand side function</span></a></li><li class="toplevel"><a class="tocitem" href="#The-state-vectors-\\vec{Y}-and-\\vec{p}"><span>The state vectors <span>$\vec{Y}$</span> and <span>$\vec{p}$</span></span></a></li><li class="toplevel"><a class="tocitem" href="#Running-the-simulation"><span>Running the simulation</span></a></li><li class="toplevel"><a class="tocitem" href="#And-now-for-some-bonus-material"><span>And now for some bonus material</span></a></li></ul></li><li><a class="tocitem" href="../LSM_single_column_tutorial/">Intro to multi-component models</a></li><li><a class="tocitem" href="../domain_tutorial/">Intro to ClimaLSM Domains</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Running simulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-2-1" type="checkbox"/><label class="tocitem" for="menuitem-4-2-1"><span class="docs-label">Soil modeling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Soil/richards_equation/">Richards Equation</a></li><li><a class="tocitem" href="../../Soil/soil_energy_hydrology/">Energy and Hydrology</a></li><li><a class="tocitem" href="../../Soil/freezing_front/">Phase Changes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2-2"><span class="docs-label">Bucket LSM</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Bucket/bucket_tutorial/">Introduction to the Land Bucket Model</a></li><li><a class="tocitem" href="../../Bucket/coupled_bucket/">Setting up a Coupled Simulation</a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">For model developers</a></li><li class="is-active"><a href>Using AbstractModel functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using AbstractModel functionality</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaLSM.jl/../../../.." title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>The <code>AbstractModel</code> framework allows users to define land component models (e.g. for snow, soil, vegetation, carbon...) which can be run in standalone mode, or as part of a land surface model with many components. In order to achieve this flexibility, we require a standard interface, which is what <code>AbstractModel</code>s provides. The interface is designed to work with an external package for the time-stepping of ODEs - we are using <code>DifferentialEquations.jl</code> at present - , with <code>ClimaCore.jl</code>, for the spatial discretization of PDEs, and with <code>ClimaLSM.jl</code>, for designing and running multi-component land surface models. For a developer of a new land model component, using <code>AbstractModel</code>s as shown below is the first step towards building a model which can be run in standalone or with <code>ClimaLSM.jl</code>.</p><p>This tutorial introduces some of the functionality of the <code>AbstractModel</code> interface functions and types. We demonstrate how to use a <code>Model &lt;: AbstractModel</code> structure to define a set of equations, and explain a few core methods which must be defined for your <code>Model</code> type in order to run a simulation.  We use a non-land modelling system of ODEs for this purpose, to demonstrate generality. For land model components, you would follow the same principles - see the carbon tutorial for a similar example.</p><p>Future tutorials (TBD where) will show to define simple land component models and run them together using <code>ClimaLSM.jl</code>.</p><h1 id="General-setup"><a class="docs-heading-anchor" href="#General-setup">General setup</a><a id="General-setup-1"></a><a class="docs-heading-anchor-permalink" href="#General-setup" title="Permalink"></a></h1><p>We assume you are solving a system of the form of a set of PDEs or ODEs. Additional algebraic equations for can be accomodated as well, but only in addition to variables advanced using differential equations.</p><p>Spatially discretized PDEs reduce to a system of ODEs, so we can assume an ODE system in what follows without a loss of generality. When using <code>AbstractModel</code>s, you should use <code>ClimaCore</code> to discretize your PDE, as applicable.</p><p>Your model defines a system of equations of the following form:</p><p><span>$\frac{d \vec{Y}}{d t} = \vec{f}(\vec{Y}, \vec{x}, t; \mbox{params} \ldots)$</span></p><p>The variables that are stepped forward via a differential equation are referred to as prognostic variables, and are stored in <span>$\vec{Y}$</span>. Generically, we will speak of the functions <span>$\vec{f}$</span> as the right hand side functions; these can be functions of the prognostic state, of space <span>$\vec{x}$</span>, and of time <span>$t$</span>, as well as of other parameters. Note that quantities such as boundary conditions, source terms, etc, will appear within these right hand side functions.</p><h1 id="Optional-auxiliary-variables"><a class="docs-heading-anchor" href="#Optional-auxiliary-variables">Optional auxiliary variables</a><a id="Optional-auxiliary-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-auxiliary-variables" title="Permalink"></a></h1><p>It may be that there are quantities, which depend on the state vector <span>$\vec{Y}$</span>, location, time, and other parameters, which are expensive to compute (e.g. requiring solving an implicit equation) and also needed multiple times in the right hand side functions.</p><p>Denoting these variables as <span>$\vec{p}$</span>, your equations may be rewritten as:</p><p><span>$\frac{d \vec{Y}}{d t} = \vec{f}(\vec{Y}, \vec{p}, \vec{x}, t; \mbox{params} \ldots)$</span></p><p><span>$\vec{p}(\vec{x}, t) = \vec{g}(\vec{Y}(t), \vec{x}, t; \mbox{params} \ldots)$</span></p><p>The variables <span>$\vec{p}$</span> at the current timestep are functions of the state, space, time, and parameters. These variables are referred to as auxiliary variables (TBD: or cache variables). <strong>Their only purpose is for storing the value of a quantity in a pre-allocated spot in memory, to avoid computing something expensive many times per time-step, or to avoid allocating memory to store each timestep. They are not a required feature, strictly speaking, and should be only used for this particular use case.</strong> A model purely consisting of algebraic equations, running in standalone mode, is not supported (<span>$\vec{Y}$</span> cannot be zero dimensional).</p><p>In order to define this set of equations, in a manner which is consistent with the <code>AbstractModel</code> interface (used by <code>ClimaLSM.jl</code>) and time-stepping algorithms (<code>OrdinaryDiffEq.jl</code> for the present), the following must be provided.</p><h1 id="The-Model"><a class="docs-heading-anchor" href="#The-Model">The Model</a><a id="The-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-Model" title="Permalink"></a></h1><p>All <code>ClimaLSM</code> component models are concrete instances of <code>AbstractModel</code>s. The reason for grouping them in such a way is because they all have shared required functionality, as we will see, and can make use of common default behavior.</p><p>The model structure holds all of the information needed to create the full right hand side function, including parameters (which can be functions of space and time), boundary conditions, and physical equations.</p><p>The purpose of our <code>AbstractModel</code> interface is that it allows you to run land component models in standalone mode and in an LSM mode without a change in interface. However, we can still use this system to show how to set up a model, equations, etc.</p><p>As a simple demonstration of use, we&#39;ll build a model now which describes the motion of a particle in the Henon-Heiles potential. This decribes a particle moving on a plane under a cubic potential energy function, and is a problem of historical and scientific interest as an example of a system exhibiting Hamiltonian chaos. To be clear, if you <strong>only</strong> want to integrate a system like this, you should not be using our AbstractModels interface, and working with OrdinaryDiffEq.jl directly!</p><p>Let&#39;s first import some needed packages.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq: ODEProblem, solve, RK4
using SciMLBase
using Plots
using ClimaCore
if !(&quot;.&quot; in LOAD_PATH)
    push!(LOAD_PATH, &quot;.&quot;)
end
using ClimaLSM
using ClimaLSM.Domains</code></pre><p>Import the functions we are extending for our model:</p><pre><code class="language-julia hljs">import ClimaLSM: name, make_rhs, prognostic_vars, prognostic_types
import ClimaLSM.Domains: coordinates</code></pre><p>There is only one free parameter in the model, <code>λ</code>, so our model structure is very simple. Remember, the model should contain everything you need to create the right hand side <strong>function</strong>.</p><pre><code class="language-julia hljs">struct HenonHeiles{FT} &lt;: AbstractModel{FT}
    λ::FT
end;</code></pre><p>For reasons we will discuss momentarily, let&#39;s also define the name of the model:</p><pre><code class="language-julia hljs">ClimaLSM.name(model::HenonHeiles) = :hh;</code></pre><h1 id="Right-hand-side-function"><a class="docs-heading-anchor" href="#Right-hand-side-function">Right hand side function</a><a id="Right-hand-side-function-1"></a><a class="docs-heading-anchor-permalink" href="#Right-hand-side-function" title="Permalink"></a></h1><p>Here is where we need to specify the equations of motion. The prognostic variables for the Henon-Heiles system consist of two position variables (<code>x</code>, <code>y</code>), and two momentum variables (<code>m_x, m_y</code>, where we are using <code>m</code> rather than <code>p</code> as is typical to avoid confusion with the auxiliary vector <code>p</code>). The differential equations are:</p><p><span>$\dot{x} = m_x$</span></p><p><span>$\dot{y} = m_y$</span></p><p><span>$\dot{m}_x = -x -2 λ xy$</span></p><p><span>$\dot{m}_y = -y - λ (x² - y²)$</span></p><p>These equations describe Newton&#39;s 2nd law for the particle, where the force acting is minus the gradient of the potential function (the aforementioned cubic); they are derived by taking the appropriate derivatives of the Hamiltonian (in this case, total energy) function.</p><p>We now create the function which makes the <code>rhs!</code> function:</p><pre><code class="language-julia hljs">function ClimaLSM.make_rhs(model::HenonHeiles{FT}) where {FT}
    function rhs!(dY, Y, p, t)
        dY.hh.x[1] = Y.hh.m[1]
        dY.hh.x[2] = Y.hh.m[2]
        dY.hh.m[1] = -Y.hh.x[1] - FT(2) * model.λ * Y.hh.x[1] * Y.hh.x[2]
        dY.hh.m[2] = -Y.hh.x[2] - model.λ * (Y.hh.x[1]^FT(2) - Y.hh.x[2]^FT(2))
    end
    return rhs!
end;</code></pre><p>A couple of notes: the vector <span>$\vec{dY}$</span> contains the evaluation of the right hand side function for each variable in <span>$\vec{Y}$</span>. It is updated in place (so no extra allocations are needed). Note that both vectors are not simple arrays. They are <code>ClimaCore</code> <code>FieldVectors</code>, which allow us to impose some organizational structure on the state while still behaving like arrays in some ways. We use the symbol returned by <code>name(model)</code> to create this hierarchy. There will ever only be one level to the hierarchy.</p><p>The arguments of <code>rhs!</code> are determined by the <code>OrdinaryDiffEq</code> interface, but should be fairly generic for any time-stepping algorithm. The <code>rhs!</code> function is only created once. If there are time-varying forcing terms appearing, for example, the forcing functions must be stored in <code>model</code> and passed in that way.</p><h1 id="The-state-vectors-\\vec{Y}-and-\\vec{p}"><a class="docs-heading-anchor" href="#The-state-vectors-\\vec{Y}-and-\\vec{p}">The state vectors <span>$\vec{Y}$</span> and <span>$\vec{p}$</span></a><a id="The-state-vectors-\\vec{Y}-and-\\vec{p}-1"></a><a class="docs-heading-anchor-permalink" href="#The-state-vectors-\\vec{Y}-and-\\vec{p}" title="Permalink"></a></h1><p>We have given the state vector <span>$\vec{Y}$</span> a particular structure, and don&#39;t expect the user to build this themselves. In order to have the structure <code>Y</code> (and <code>p</code>) correctly created, the model developer needs to define the names of the prognostic and auxiliary variables:</p><pre><code class="language-julia hljs">ClimaLSM.prognostic_vars(::HenonHeiles) = (:x, :m);</code></pre><p>There are no auxiliary variables. By not defining a method for them, we are using the default (which adds no variables to <code>p</code>), i.e. <code>ClimaLSM.auxiliary_vars(::HenonHeiles) = ()</code>.</p><p>Lastly, we need to tell the interface something about the variables. What are they? <code>Array</code>s? <code>ClimaCore</code> <code>Field</code>s? We have made the assumption that all variables are tied to a domain, or a set of coordinates.</p><p>In this case, our coordinates are 2-d. Hence our coordinates are given by a vector with 2 elements. For each coordinate, both <code>m</code> and <code>x</code> are scalars with type <code>FT</code>:</p><pre><code class="language-julia hljs">ClimaLSM.Domains.coordinates(model::HenonHeiles{FT}) where {FT} =
    FT.([0.0, 0.0]);
ClimaLSM.prognostic_types(::HenonHeiles{FT}) where {FT} = (FT, FT);</code></pre><p>OK, let&#39;s try running a simulation now. Create a model instance, with λ = 1:</p><pre><code class="language-julia hljs">hh = HenonHeiles{Float64}(1.0);</code></pre><p>Create the initial state structure, using the default method:</p><pre><code class="language-julia hljs">Y, p, _ = initialize(hh);</code></pre><p>Note that <code>Y</code> has the structure we planned on in our <code>rhs!</code> function, for <code>x</code>,</p><pre><code class="language-julia hljs">Y.hh.x</code></pre><pre><code class="nohighlight hljs">2-element Vector{Float64}:
 0.0
 0.0</code></pre><p>and for <code>m</code></p><pre><code class="language-julia hljs">Y.hh.m</code></pre><pre><code class="nohighlight hljs">2-element Vector{Float64}:
 0.0
 0.0</code></pre><p>Note also that <code>p</code> is empty:</p><pre><code class="language-julia hljs">p.hh</code></pre><pre><code class="nohighlight hljs">Float64[]</code></pre><p>Here we now update <code>Y</code> in place with initial conditions of our choosing.</p><pre><code class="language-julia hljs">Y.hh.x[1] = 0.0;
Y.hh.x[2] = 0.0;
Y.hh.m[1] = 0.5;
Y.hh.m[2] = 0.0;</code></pre><h1 id="Running-the-simulation"><a class="docs-heading-anchor" href="#Running-the-simulation">Running the simulation</a><a id="Running-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-simulation" title="Permalink"></a></h1><p>Create the <code>ode_function</code>. In our case, since we don&#39;t have any auxiliary variables to update each timestep, this is equivalent to the <code>rhs!</code> function, but in other models, it might involve an <code>update_aux!</code> step as well.</p><pre><code class="language-julia hljs">ode_function! = make_ode_function(hh);</code></pre><p>From here on out, we are just using <code>OrdinaryDiffEq.jl</code> functions to integrate the system forward in time.</p><p>Initial and end times, timestep:</p><pre><code class="language-julia hljs">t0 = 0.0;
tf = 600.0;
dt = 1.0;</code></pre><p>ODE.jl problem statement:</p><pre><code class="language-julia hljs">prob = ODEProblem(ode_function!, Y, (t0, tf), p);</code></pre><p>Solve command - we are using a fourth order Runge-Kutta timestepping scheme. ODE.jl uses adaptive timestepping, but we can still pass in a suggested timestep <code>dt</code>.</p><pre><code class="language-julia hljs">sol = solve(prob, RK4(); dt = dt, reltol = 1e-6, abstol = 1e-6);</code></pre><p>Get the solution back, and make a plot.</p><pre><code class="language-julia hljs">x = [sol.u[k].hh.x[1] for k in 1:1:length(sol.t)]
y = [sol.u[k].hh.x[2] for k in 1:1:length(sol.t)]

plot(x, y, xlabel = &quot;x&quot;, ylabel = &quot;y&quot;, label = &quot;&quot;);
savefig(&quot;orbits.png&quot;);</code></pre><p><img src="../orbits.png" alt/></p><p>And, yes, we could be using a symplectic integrator, but that would require us to use a slightly different interface - and that isn&#39;t needed for our Clima LSM application.</p><h1 id="And-now-for-some-bonus-material"><a class="docs-heading-anchor" href="#And-now-for-some-bonus-material">And now for some bonus material</a><a id="And-now-for-some-bonus-material-1"></a><a class="docs-heading-anchor-permalink" href="#And-now-for-some-bonus-material" title="Permalink"></a></h1><p>The motion of the system takes place in four dimensions, but it&#39;s hard for us to visualize. One nice way of doing so is via a Poincare section, or surface of section. The idea is that for quasiperiodic motion, which Hamiltonian dynamics result in, the orbit will repeatedly meet certain criteria, and we can look at the orbit variables <em>when that criterion is met</em>.</p><p>For example, we can define our surface of section to be <span>$x = 0, \dot{x} &gt; 0$</span>, since <code>x</code> is varying periodically and repeatedly passes through zero in the positive direction. We also will only look at orbits with a particular energy value, <span>$E_0$</span>.</p><p>Every time the section criterion is met, we plot <span>$(y, m_y)$</span>. Points on this surface provide a complete description of the orbit, because we can, with knowledge of <span>$x = 0, m_x &gt;0,$</span> and <span>$E_0$</span>, back out the state of the system, which uniquely defines the orbit we are looking at.</p><p>The functions below creates these initial conditions, given a value for E, λ, and y (setting <span>$m_y = 0$</span> arbitrarily):</p><pre><code class="language-julia hljs">function set_ic_via_y!(Y, E, λ, y; my = 0.0, x = 0.0)
    twiceV = λ * (x^2 + y^2 + 2 * x^2 * y - 2 / 3 * y^3)
    mx = sqrt(2.0 * E - my^2 - twiceV)
    Y.hh.x[1] = x
    Y.hh.x[2] = y
    Y.hh.m[1] = mx
    Y.hh.m[2] = my
end;</code></pre><p>This function creates similar initial conditions, but via <span>$m_y$</span> :</p><pre><code class="language-julia hljs">function set_ic_via_my!(Y, E, λ, my; y = 0.0, x = 0.0)
    twiceV = λ * (x^2 + y^2 + 2 * x^2 * y - 2 / 3 * y^3)
    mx = sqrt(2.0 * E - my^2 - twiceV)
    Y.hh.x[1] = x
    Y.hh.x[2] = y
    Y.hh.m[1] = mx
    Y.hh.m[2] = my
end;</code></pre><p>This function takes initial conditions, runs an integration, and saves the values of the state on the surface of section, and then plots those points (thanks to the SciML team for creating a <a href="https://tutorials.sciml.ai/html/models/01-classical_physics.html">tutorial</a> showing how to extract the state of the system when the section criterion is met.</p><pre><code class="language-julia hljs">function map(Y, pl)
    t0 = 0.0
    tf = 4800.0
    dt = 1.0
    condition(u, t, integrator) = u.hh.x[1]
    affect!(integrator) = nothing
    cb = ContinuousCallback(
        condition,
        affect!,
        nothing,
        save_positions = (true, false),
    )
    prob = ODEProblem(ode_function!, Y, (t0, tf), p)
    sol = solve(
        prob,
        RK4();
        dt = dt,
        reltol = 1e-6,
        abstol = 1e-6,
        callback = cb,
        save_everystep = false,
        save_start = false,
        save_end = false,
    )
    y_section = [sol.u[k].hh.x[2] for k in 1:1:length(sol.t)]
    my_section = [sol.u[k].hh.m[2] for k in 1:1:length(sol.t)]

    scatter!(pl, y_section, my_section, label = &quot;&quot;, markersize = 3, msw = 0)
end;</code></pre><p>Ok! Let&#39;s try it out:</p><pre><code class="language-julia hljs">E = 0.125;
yvals = -0.35:0.05:0.35;
pl = scatter();
for yval in yvals
    set_ic_via_y!(Y, E, 1.0, yval)
    map(Y, pl)
end;
myvals = [-0.42, -0.27, 0.05, 0.27, 0.42];
for myval in myvals
    set_ic_via_my!(Y, E, 1.0, myval)
    map(Y, pl)
end;

plot(pl, xlabel = &quot;y&quot;, ylabel = &quot;m_y&quot;);
savefig(&quot;surface.png&quot;);</code></pre><p><img src="../surface.png" alt/></p><p>On a plot like this, a single orbit (indicated via point color) can be identified roughly as regular, or periodic, if it the points lie on a curve. Orbits which are chaotic fill out an area (orbits with a lot of numerical error also do...). The coexistence of these orbits arbitrarily close to each other, in the same system, is one fascinating aspect of deterministic chaos. Another fun aspect is seeing periodic orbits of different resonances. The set of cocentric curves are near a first-order resonance, meaning that every period for <code>x</code> (to reach zero), we see about one period in <code>y,my</code> space. The teal circles around them indicate a near resonant orbit of order 4.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../Contributing/">« Contribution guide</a><a class="docs-footer-nextpage" href="../LSM_single_column_tutorial/">Intro to multi-component models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 20 January 2023 00:36">Friday 20 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
