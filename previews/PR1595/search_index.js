var documenterSearchIndex = {"docs":
[{"location":"standalone/pages/vegetation/plant_hydraulics/prognostic/#Plant-Hydraulics","page":"Prognostic model","title":"Plant Hydraulics","text":"Water loss during day-time transpiration drives plants to draw water from the soil by roots and transport it through the stem to leaves. The plant hydraulics code solves for the volumetric water content along the water flow path, in the stem and leaf (theta_stem and theta_leaf). It allows for an arbitrary number of compartments, but for now we will start with a single stem and leaf compartment. \n\nThe volume flux of water q (m/s) between compartments is given by Darcy's law as\n\nbeginalign\n    q = - K(psi) fracdhdz\nendalign\n\nwhere h = psi+z is the head (in meters), and K is the conductivity (units of m/s). We approximate the flux between two compartments, indexed with 2 at height z_2 and indexed with 1 at height z_1z_2, using finite difference as\n\nbeginequation\nq approx -fracK_1(psi_1) K_2(psi_2)K_1(psi_1)+K_2(psi_2) times biggfracpsi_2 - psi_1z_2 - z_1 +1bigg\nendequation\n\nThe change of water volume (m^3)  V, in the compartments is then\n\nbeginalign\n    fracd V_w stemdt = q_rootssigma_roots - q_stemsigma_stem nonumber \n    fracd V_w leafdt = q_stemsigma_stem - tau sigma_leaf\nendalign\n\nwhere tau is a transpiration volume flux per unit emitting area, and sigma is the total emitting/conducting area.\n\nThis currently holds for a single pathway. To convert to fluxes from an entire surface, we can multiply by the number of individuals N. We can make use of the fact that NsigmaA, where A is the area of the ground those N individuals are occupying, is the area index for that plant type. Following CLM, we incorporate a root, stem, and leaf area index (RAI, SAI, LAI) in order to model fluxes across an entire grid cell. \n\nThen we have:\n\nbeginalign\n    fracd v_stemdt = q_rootsRAI - q_stemSAI nonumber \n    fracd v_leafdt = q_stemSAI - tau LAI\nendalign\n\nwhere v now represents the volume of water in that compartment (of a bulk plant) per unit ground area.\n\nWe also need to convert from the variable v to psi, in order to compute root extraction with the soil.  To do so, we can convert v to the volumetric water content, and from theta to psi using the retention curve. To convert, let the volume of water per area of compartment be V_w, and H the typical ``length\" of the compartment. Then e.g.,\n\nbeginequation\n    theta_stem=fracV_wstemA_ground times fracA_groundA_stem times frac1H_stem = fracv_stemH_stem times SAI \nendequation\n\nSubstituting in the volumetric water content, we have\n\nbeginalign\n    fracd theta_stemdt = fracq_rootsRAI - q_stemSAIH_stem SAI nonumber \n    fracd theta_leafdt = fracq_stemSAI - tau LAIH_leaf LAI\nendalign\n\nWe can also account for the distribution of roots as a function of depth. A quantity that is modeled in plant hydraulic models is the root fraction P(z), satisfying int P(z) dz = 1. Instead of having a single root at one discrete location, we can distribute the root system over different depths using P(z). The total flux from roots between z and z+dz is given by\n\nbeginequation\n    dq_roots(z) = -P(z) q(z) dz\nendequation\n\nThen the net root flux for the plant system would sum over this\n\nbeginequation\n    q_roots  = -int_z_min^z_sfc P(z) q(z) dz \nendequation\n\nwhere z_min is the minimum soil layer of the simulation. \n\nThe sink term of the soil is in terms of a volumetric fraction change, i.e. we need a volume of water per volume of soil per second. We can obtain this with\n\nbeginequation\n    S(z) = -(RAI) fracdq_roots(z)dz = (RAI) P(z) q(z)\nendequation\n\nThe sign change occurs in the expression for S(z) because a positive value of q_roots indicates flow from the soil to the plant. This is a sink term for the soil.\n\nIn order to close the set of equations, the user will have to specify K(psi) and a function psi(theta). In our current implementation, we use the same parameter values for all compartments, a linear retention curve psi(theta), and a Weibull permeability curve K(psi):\n\nbeginequation\n    K(psi)  = begincases K_rm satexp(psipsi_63)^c  psi 0 \nK_rm sat  psi  0\nendcases\nendequation\n\nand\n\nbeginequation\n    psi(theta)  = frac1a(thetanu - 1)\nendequation\n\nThe model needs the following parameters:\n\nDrivers Symbol Unit Approximate Value\nLinear retention curve slope a 1/m 0.002\nSaturated conductivity K_rm sat m/s 1e-7\nPotential at 1/e loss in conductivity psi_63 m -400\nWeibull exponential parameter c - 4\nPorosity nu - 1e-4","category":"section"},{"location":"APIs/canopy/RadiativeTransfer/#Radiative-Transfer","page":"Radiative Transfer","title":"Radiative Transfer","text":"","category":"section"},{"location":"APIs/canopy/RadiativeTransfer/#Models-and-Parameters","page":"Radiative Transfer","title":"Models and Parameters","text":"","category":"section"},{"location":"APIs/canopy/RadiativeTransfer/#Radiative-Transfer-Parameterizations","page":"Radiative Transfer","title":"Radiative Transfer Parameterizations","text":"","category":"section"},{"location":"APIs/canopy/RadiativeTransfer/#Methods","page":"Radiative Transfer","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.TwoStreamModel","page":"Radiative Transfer","title":"ClimaLand.Canopy.TwoStreamModel","text":"TwoStreamModel{FT}(\n    domain,\n    toml_dict::CP.ParamDict;\n    radiation_parameters = clm_canopy_radiation_parameters(domain.space.surface),\n    ϵ_canopy = toml_dict[\"canopy_emissivity\"],\n    n_layers::Int = 20,\n)\n\nCreates a Two Stream model for canopy radiative transfer on the provided domain.\n\nSpatially-varying parameters are read in from data files in clm_canopy_radiation_parameters.` In particular, this function returns a NamedTuple containing:\n\nΩ: clumping index\nG_Function: a G function for leaf angle distribution\nα_PAR_leaf, τ_PAR_leaf: albedo and transmissivity in the PAR band\nα_NIR_leaf, τ_NIR_leaf: albedo and transmissivity in the NIR band\n\nCanopy emissivity and wavelength per PAR photon are currently treated as constants; these can be passed in as Floats by kwarg. Otherwise the default values from ClimaParams.jl are used.\n\nThe number of layers in the canopy is set by n_layers, which defaults to 20.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.TwoStreamModel-Union{Tuple{FT}, Tuple{Any, ClimaParams.ParamDict}} where FT<:AbstractFloat","page":"Radiative Transfer","title":"ClimaLand.Canopy.TwoStreamModel","text":"TwoStreamModel{FT}(\n    domain,\n    toml_dict::CP.ParamDict;\n    radiation_parameters = clm_canopy_radiation_parameters(domain.space.surface),\n    ϵ_canopy = toml_dict[\"canopy_emissivity\"],\n    n_layers::Int = 20,\n)\n\nCreates a Two Stream model for canopy radiative transfer on the provided domain.\n\nSpatially-varying parameters are read in from data files in clm_canopy_radiation_parameters.` In particular, this function returns a NamedTuple containing:\n\nΩ: clumping index\nG_Function: a G function for leaf angle distribution\nα_PAR_leaf, τ_PAR_leaf: albedo and transmissivity in the PAR band\nα_NIR_leaf, τ_NIR_leaf: albedo and transmissivity in the NIR band\n\nCanopy emissivity and wavelength per PAR photon are currently treated as constants; these can be passed in as Floats by kwarg. Otherwise the default values from ClimaParams.jl are used.\n\nThe number of layers in the canopy is set by n_layers, which defaults to 20.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.BeerLambertModel","page":"Radiative Transfer","title":"ClimaLand.Canopy.BeerLambertModel","text":"BeerLambertModel{FT}(\n    domain,\n    toml_dict::CP.ParamDict;\n    radiation_parameters = clm_canopy_radiation_parameters(domain.space.surface),\n    ϵ_canopy::FT = toml_dict[\"canopy_emissivity\"],\n) where {FT <: AbstractFloat}\n\nCreates a Beer-Lambert model for canopy radiative transfer on the provided domain.\n\nSpatially-varying parameters are read in from data files in clm_canopy_radiation_parameters.` In particular, this function returns a field for\n\nclumping index Ω\nleaf angle distribution G_Function\nalbedo and transmissitivy in PAR and NIR bands (α_PAR_leaf, τ_PAR_leaf, α_NIR_leaf, τ_NIR_leaf)\n\nCanopy emissivity and wavelength per PAR photon are currently treated as constants; these can be passed in as Floats by kwarg. Otherwise the default values from ClimaParams.jl are used.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.BeerLambertModel-Union{Tuple{FT}, Tuple{Any, ClimaParams.ParamDict}} where FT<:AbstractFloat","page":"Radiative Transfer","title":"ClimaLand.Canopy.BeerLambertModel","text":"BeerLambertModel{FT}(\n    domain,\n    toml_dict::CP.ParamDict;\n    radiation_parameters = clm_canopy_radiation_parameters(domain.space.surface),\n    ϵ_canopy::FT = toml_dict[\"canopy_emissivity\"],\n) where {FT <: AbstractFloat}\n\nCreates a Beer-Lambert model for canopy radiative transfer on the provided domain.\n\nSpatially-varying parameters are read in from data files in clm_canopy_radiation_parameters.` In particular, this function returns a field for\n\nclumping index Ω\nleaf angle distribution G_Function\nalbedo and transmissitivy in PAR and NIR bands (α_PAR_leaf, τ_PAR_leaf, α_NIR_leaf, τ_NIR_leaf)\n\nCanopy emissivity and wavelength per PAR photon are currently treated as constants; these can be passed in as Floats by kwarg. Otherwise the default values from ClimaParams.jl are used.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.BeerLambertParameters","page":"Radiative Transfer","title":"ClimaLand.Canopy.BeerLambertParameters","text":"BeerLambertParameters{\n    FT <: AbstractFloat,\n    G <: Union{AbstractGFunction, ClimaCore.Fields.Field},\n    F <: Union{FT, ClimaCore.Fields.Field},\n}\n\nThe required parameters for the Beer-Lambert radiative transfer model.\n\nα_PAR_leaf: PAR leaf reflectance (unitless)\nα_NIR_leaf: NIR leaf reflectance\nϵ_canopy: Emissivity of the canopy\nΩ: Clumping index following Braghiere (2021) (unitless)\nλ_γ_PAR: Typical wavelength per PAR photon (m)\nG_Function: Leaf angle distribution function\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.BeerLambertParameters-Tuple{ClimaParams.ParamDict}","page":"Radiative Transfer","title":"ClimaLand.Canopy.BeerLambertParameters","text":"function BeerLambertParameters(\n    toml_dict::CP.ParamDict;\n    G_Function,\n    α_PAR_leaf,\n    α_NIR_leaf,\n    Ω,\n    ϵ_canopy = toml_dict[\"canopy_emissivity\"],\n)\n\nTOML dict based constructor supplying default values for the BeerLambertParameters struct. Additional parameter values can be directly set via kwargs.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.TwoStreamParameters","page":"Radiative Transfer","title":"ClimaLand.Canopy.TwoStreamParameters","text":"TwoStreamParameters{FT <: AbstractFloat}\n\nThe required parameters for the two-stream radiative transfer model.\n\nα_PAR_leaf: PAR leaf reflectance (unitless)\nτ_PAR_leaf: PAR leaf element transmittance\nα_NIR_leaf: NIR leaf reflectance\nτ_NIR_leaf: NIR leaf element transmittance\nϵ_canopy: Emissivity of the canopy\nΩ: Clumping index following Braghiere 2021 (unitless)\nλ_γ_PAR: Typical wavelength per PAR photon (m)\nn_layers: Number of layers to partition the canopy into when integrating the     absorption over the canopy vertically. Unrelated to the number of layers in     the vertical discretization of the canopy for the plant hydraulics model.     (Constant, and should eventually move to ClimaParams)\nG_Function: Leaf angle distribution function\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.TwoStreamParameters-Tuple{ClimaParams.ParamDict}","page":"Radiative Transfer","title":"ClimaLand.Canopy.TwoStreamParameters","text":"function TwoStreamParameters(\n    toml_dict::CP.ParamDict;\n    G_Function,\n    α_PAR_leaf,\n    τ_PAR_leaf,\n    α_NIR_leaf,\n    τ_NIR_leaf,\n    Ω,\n    n_layers = UInt64(20),\n    ϵ_canopy = toml_dict[\"canopy_emissivity\"],\n)\n\nTOML dict based constructor supplying default values for the TwoStreamParameters struct.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.ConstantGFunction","page":"Radiative Transfer","title":"ClimaLand.Canopy.ConstantGFunction","text":"ConstantGFunction\n\nA type for a constant G function, which is used to represent the leaf angle distribution function in the radiative transfer models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.CLMGFunction","page":"Radiative Transfer","title":"ClimaLand.Canopy.CLMGFunction","text":"CLMGFunction\n\nA type for a G function that is parameterized by the cosine of the solar zenith angle, following the CLM approach to parameterizing the leaf angle distribution function.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.canopy_radiant_energy_fluxes!","page":"Radiative Transfer","title":"ClimaLand.Canopy.canopy_radiant_energy_fluxes!","text":"Canopy.canopy_radiant_energy_fluxes!(p::NamedTuple,\n                                     s::PrognosticGroundConditions,\n                                     canopy,\n                                     radiation::PrescribedRadiativeFluxes,\n                                     earth_param_set::PSE,\n                                     Y::ClimaCore.Fields.FieldVector,\n                                     t,\n                                    ) where {PSE}\n\nIn standalone mode, this function computes and stores the net long and short wave radition, in W/m^2, absorbed by the canopy.\n\nIn integrated mode, we have already computed those quantities in lsm_radiant_energy_fluxes!, so this method does nothing additional.\n\nLW and SW net radiation are stored in p.canopy.radiative_transfer.LW_n and p.canopy.radiative_transfer.SW_n.\n\n\n\n\n\ncanopy_radiant_energy_fluxes!(p::NamedTuple,\n                              ground::PrescribedGroundConditions\n                              canopy,\n                              radiation::PrescribedRadiativeFluxes,\n                              earth_param_set::PSE,\n                              Y::ClimaCore.Fields.FieldVector,\n                              t,\n                             ) where {PSE}\n\nComputes and stores the net long and short wave radiation, in W/m^2, over all bands, absorbed by the canopy when the canopy is run in standalone mode, with only a :canopy model as a prognostic component, with PrescribedGroundConditions.\n\nLW and SW net radiation are stored in p.canopy.radiative_transfer.LW_n and p.canopy.radiative_transfer.SW_n.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.ground_albedo_PAR","page":"Radiative Transfer","title":"ClimaLand.Canopy.ground_albedo_PAR","text":"Canopy.ground_albedo_PAR(\n    prognostic_land_components::Val{(:canopy, :soil, :soilco2)},\n    ground,\n    Y,\n    p,\n    t,\n)\n\nA method of Canopy.Canopy.groundalbedoPAR for a prognostic soil.\n\n\n\n\n\nCanopy.ground_albedo_PAR(\n   prognostic_land_components::Union{\n        Val{(:canopy, :snow, :soil, :soilco2)},\n        Val{(:canopy, :snow, :soil)},\n    },\n    ground,\n    Y,\n    p,\n    t,\n)\n\nA method of Canopy.groundalbedoPAR for a prognostic soil/snow. This function is called in the Canopy update_aux! function.\n\n\n\n\n\nground_albedo_PAR(prognostic_land_components::Val{(:canopy,)}, ground::PrescribedGroundConditions, _...)\n\nReturns the ground albedo in the PAR for a PrescribedGroundConditions driver. In this case, the prognostic_land_components only contain :canopy, because the canopy is being run in standalone mode.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.ground_albedo_NIR","page":"Radiative Transfer","title":"ClimaLand.Canopy.ground_albedo_NIR","text":"Canopy.ground_albedo_NIR(\n    prognostic_land_components::Val{(:canopy, :soil, :soilco2)},\n    ground,\n    Y,\n    p,\n    t,\n)\n\nA method of Canopy.groundalbedoNIR for a prognostic soil.\n\n\n\n\n\nCanopy.ground_albedo_NIR(\n    prognostic_land_components::Union{\n        Val{(:canopy, :snow, :soil, :soilco2)},\n        Val{(:canopy, :snow, :soil)},\n        },\n    ground,\n    Y,\n    p,\n    t,\n)\n\nA method of Canopy.groundalbedoNIR for a prognostic soil/snow. This function is called in the Canopy update_aux! function.\n\n\n\n\n\nground_albedo_NIR(prognostic_land_components::Val{(:canopy,)}, ground::PrescribedGroundConditions, _...)\n\nReturns the ground albedo in the NIR for a PrescribedGroundConditions driver. In this case, the prognostic_land_components only contain :canopy, because the canopy is being run in standalone mode.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.compute_fractional_absorbances!","page":"Radiative Transfer","title":"ClimaLand.Canopy.compute_fractional_absorbances!","text":"compute_fractional_absorbances!(\n    p,\n    RT::BeerLambertModel{FT},\n    LAI,\n    α_soil_PAR,\n    α_soil_NIR,\n)\n\nComputes the PAR and NIR fractional absorbances, reflectances, and tranmittances for a canopy in the case of the Beer-Lambert model. The absorbances are a function of the radiative transfer model, as well as the leaf area index, the clumping index, the cosine of the zenith angle, the leaf angle distribution, the extinction coefficient, and the soil albedo in the PAR and NIR bands. Returns a NamedTuple of NamedTuple, of the form: (; par = (; refl = , trans = , abs = ),  nir = (; refl = , trans = , abs = ))\n\n\n\n\n\ncompute_fractional_absorbances!(p,\n    RT::TwoStreamModel{FT},\n    LAI,\n    α_soil_PAR,\n    α_soil_NIR,\n)\n\nComputes the PAR and NIR fractional absorbances, reflectances, and tranmittances for a canopy in the case of the Two-stream model. The absorbances are a function of the radiative transfer model, as well as the leaf area index, the clumping index, the cosine of the zenith angle, the leaf angle distribution, the extinction coefficient, and the soil albedo in the PAR and NIR bands.\n\nThis model also depends on the diffuse fraction. Returns a NamedTuple of NamedTuple, of the form: (; par = (; refl = , trans = , abs = ),  nir = (; refl = , trans = , abs = ))\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.canopy_sw_rt_beer_lambert","page":"Radiative Transfer","title":"ClimaLand.Canopy.canopy_sw_rt_beer_lambert","text":"canopy_sw_rt_beer_lambert(\n    G_Function,\n    cosθs::FT,\n    Ω::FT,\n    α_leaf::FT,\n    LAI::FT,\n    α_soil::FT,\n)\n\nComputes the absorbed, reflected, and transmitted flux fractions by radiation band.\n\nThis applies the Beer-Lambert law, which is a function of leaf reflectance (α_leaf), the leaf angle distribution and zenith angle (defined via G_Function, and cosθs), leaf area index (LAI), and the albedo of the soil (α_soil).\n\nReturns a tuple of reflected, absorbed, and transmitted radiation fractions.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.canopy_sw_rt_two_stream","page":"Radiative Transfer","title":"ClimaLand.Canopy.canopy_sw_rt_two_stream","text":"canopy_sw_rt_two_stream(\n    G_Function,\n    Ω::FT,\n    n_layers::UInt64,\n    SW_d::FT,\n    α_leaf::FT,\n    τ_leaf::FT,\n    LAI::FT,\n    cosθs::FT,\n    α_soil::FT,\n    frac_diff::FT,\n)\n\nComputes the absorbed, reflected, and transmitted flux fractions by radiation band.\n\nThis applies the two-stream radiative transfer solution which takes into account the impacts of scattering within the canopy. The function takes in all parameters from the parameter struct of a TwoStreamModel, along with the incident radiation, LAI, extinction coefficient K, soil albedo from the canopy soil_driver, the cosine of the solar zenith angle, and τ.\n\nReturns a tuple of reflected, absorbed, and transmitted radiation fractions.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.extinction_coeff","page":"Radiative Transfer","title":"ClimaLand.Canopy.extinction_coeff","text":"extinction_coeff(G_Function,\n                 cosθs::FT) where {FT}\n\nComputes the vegetation extinction coefficient (K), as a function of the cosine of the sun zenith angle (cosθs), and the leaf angle distribution function(G_Function).\n\nIn the two-stream scheme, values of K ~ 1/epsilon can lead to numerical issues. Here we clip it to 1e6.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.compute_G","page":"Radiative Transfer","title":"ClimaLand.Canopy.compute_G","text":"compute_G(\n    G::ConstantGFunction,\n    _,\n)\n\nReturns the constant leaf angle distribution value for the given G function. Takes in an arbitrary value for the cosine of the solar zenith angle, which is not used.\n\n\n\n\n\ncompute_G(\n    G::CLMGFunction,\n    cosθs,\n)\n\nReturns the leaf angle distribution value for CLM G function as a function of the cosine of the solar zenith angle and the leaf orientation index. See section 3.1 of https://www2.cesm.ucar.edu/models/cesm2/land/CLM50TechNote.pdf.\n\nNote that the zenith angle is defined ∈ [0,2π), so to prevent a negative value of G when the sun is below the horizon, we clip cosθs >= 0.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/available_diagnostics/#Available-diagnostic-variables","page":"Available diagnostics","title":"Available diagnostic variables","text":"Autogenerate table of available diagnostics:\n\ninclude(\"make_diagnostic_table.jl\")","category":"section"},{"location":"available_models/#Available-Models-and-Parameterizations","page":"Available Models and Parameterizations","title":"Available Models and Parameterizations","text":"","category":"section"},{"location":"available_models/#Standalone-and-integrated-models","page":"Available Models and Parameterizations","title":"Standalone and integrated models","text":"As described in the ClimaLand fundamental concepts page, ClimaLand contains a variety of standalone and integrated models. A complete list of available models is provided here.","category":"section"},{"location":"available_models/#ClimaLand-standalone-models","page":"Available Models and Parameterizations","title":"ClimaLand standalone models","text":"This table shows the abstract type (where applicable) and concrete type for each model. Abstract types are a concept originating in object-oriented programming that allow us to create a hierarchy of model types. For example, we can define an abstract type AbstractSoilModel, and then create specific models RichardsModel and EnergyHydrology as subtypes. This helps organize models and makes it easier to write functions that work with any model in the group via multiple dispatch on the abstract type. For more information about abstract types, please see the Julia manual.\n\nAbstract model type Model name\nAbstractSoilModel RichardsModel\n EnergyHydrology\nN/A CanopyModel\nAbstractSnowModel SnowModel\nAbstractSoilBiogeochemistryModel SoilCO2Model\nAbstractBucketModel BucketModel\nAbstractSurfaceWaterModel PondModel","category":"section"},{"location":"available_models/#ClimaLand-integrated-models","page":"Available Models and Parameterizations","title":"ClimaLand integrated models","text":"Integrated model name Component standalone models\nLandModel EnergyHydrology\n CanopyModel\n SoilCO2Model\n SnowModel\nSoilCanopyModel EnergyHydrology\n CanopyModel\n SoilCO2Model\nSoilSnowModel EnergyHydrology\n SnowModel\nLandSoilBiogeochemistry EnergyHydrologyModel\n SoilCO2Model\nLandHydrology RichardsModel\n PondModel","category":"section"},{"location":"available_models/#Model-parameterizations","page":"Available Models and Parameterizations","title":"Model parameterizations","text":"Each model contains one or more parameterizations, often with several options to choose from. The following tables show all available parameterizations to clarify the different model setups.\n\nWe also note the default option for each parameterization. This is what the model will use automatically when built with just the basic inputs (domain, forcing data, and TOML parameter file), without customizing the parameterizations yourself. The defaults are only explicitly shown here for standalone models but are also inherited by any integrated model containing a given standalone model, unless otherwise noted.","category":"section"},{"location":"available_models/#Soil-Models","page":"Available Models and Parameterizations","title":"Soil Models","text":"","category":"section"},{"location":"available_models/#EnergyHydrology","page":"Available Models and Parameterizations","title":"EnergyHydrology","text":"Parameterization type Available options\nAbstractSoilAlbedoParameterization CLMTwoBandSoilAlbedo (default)\n ConstantTwoBandSoilAlbedo\nAbstractRunoffModel TOPMODELRunoff (default)\n SurfaceRunoff\n NoRunoff\nAbstractSoilHydrologyClosure vanGenuchten (default)\n BrooksCorey","category":"section"},{"location":"available_models/#RichardsModel","page":"Available Models and Parameterizations","title":"RichardsModel","text":"Parameterization type Available options\nAbstractRunoffModel TOPMODELRunoff (default)\n SurfaceRunoff\n NoRunoff\nAbstractSoilHydrologyClosure vanGenuchten (default)\n BrooksCorey","category":"section"},{"location":"available_models/#CanopyModel","page":"Available Models and Parameterizations","title":"CanopyModel","text":"Parameterization type Available options\nAbstractAutotrophicRespirationModel AutotrophicRespirationModel (default)\nAbstractRadiationModel TwoStreamModel (default)\n BeerLambertModel\nAbstractPhotosynthesisModel FarquharModel (default)\n PModel\nAbstractStomatalConductanceModel MedlynConductanceModel (default)\n PModelConductance\nAbstractPlantHydraulicsModel PlantHydraulicsModel (default)\nAbstractSoilMoistureStressModel TuzetMoistureStressModel (default)\n PiecewiseMoistureStressModel\nAbstractSIFModel Lee2015SIFModel (default)\nAbstractCanopyEnergyModel PrescribedCanopyTempModel (default, in standalone canopy)\n BigLeafEnergyModel (default, in integrated models)","category":"section"},{"location":"available_models/#SnowModel","page":"Available Models and Parameterizations","title":"SnowModel","text":"Parameterization type Available options\nAbstractDensityModel MinimumDensityModel (default)\n NeuralDepthModel\nAbstractAlbedoModel ConstantAlbedoModel (default)\n ZenithAngleAlbedoModel\nAbstractSnowCoverFractionModel WuWuSnowCoverFractionModel (default)","category":"section"},{"location":"generated/standalone/Soil/evaporation/#Soil-evaporation","page":"Coarse Sand Evaporation","title":"Soil evaporation","text":"This sets up the simulation that mimicks the coarse sand lab experiment presented in Figures 7 and 8a of Lehmann et al. [14]\n\nusing CairoMakie\nimport SciMLBase\nimport ClimaTimeSteppers as CTS\nusing Thermodynamics\n\nusing ClimaCore\nimport ClimaParams as CP\nusing SurfaceFluxes\nusing StaticArrays\nusing Statistics\nusing Dates\nusing DelimitedFiles: readdlm\nusing ClimaUtilities.Utils: linear_interpolation\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nimport ClimaLand.Simulations: LandSimulation, solve!\nusing ClimaLand.Soil\nimport ClimaLand\nimport ClimaLand.Parameters as LP\nimport SurfaceFluxes.Parameters as SFP\n\nFT = Float64;\ntoml_dict = LP.create_toml_dict(FT);\nearth_param_set = LP.LandParameters(toml_dict);\nthermo_params = LP.thermodynamic_parameters(earth_param_set);\n\nWe model evaporation using Monin-Obukhov surface theory. In our soil model, it is not possible to set the initial condition corresponding to  MOST fluxes, but not include radiative fluxes. This is because for land surface models does not make sense to include atmospheric forcing but not radiative forcing.\n\nBecause of this, we need to supply downward welling short and long wave radiation. We chose SW = 0 and LW = σT^4, in order to approximately balance out the blackbody emission of the soil which is accounted for by our model. Our assumption is that in the lab experiment there was no radiative heating or cooling of the soil.\n\nTimestepping:\n\nstart_date = DateTime(2005)\nstop_date = start_date + Day(13)\ndt = Float64(900.0)\n\nSW_d = (t) -> 0\nLW_d = (t) -> 301.15^4 * 5.67e-8\nradiation = PrescribedRadiativeFluxes(\n    FT,\n    TimeVaryingInput(SW_d),\n    TimeVaryingInput(LW_d),\n    start_date,\n);\n\nSet up atmospheric conditions that result in the potential evaporation rate obsereved in the experiment. Some of these conditions are reported in the paper.\n\nT_air = FT(301.15)\nrh = FT(0.38)\nesat = Thermodynamics.saturation_vapor_pressure(\n    thermo_params,\n    T_air,\n    Thermodynamics.Liquid(),\n)\ne = rh * esat\nq = FT(0.622 * e / (101325 - 0.378 * e))\nprecip = (t) -> 0.0\nT_atmos = (t) -> T_air\nu_atmos = (t) -> 0.44\nq_atmos = (t) -> q\nh_atmos = FT(0.1)\nP_atmos = (t) -> 101325\ngustiness = FT(1e-2)\natmos = PrescribedAtmosphere(\n    TimeVaryingInput(precip),\n    TimeVaryingInput(precip),\n    TimeVaryingInput(T_atmos),\n    TimeVaryingInput(u_atmos),\n    TimeVaryingInput(q_atmos),\n    TimeVaryingInput(P_atmos),\n    start_date,\n    h_atmos,\n    toml_dict;\n    gustiness = gustiness,\n);\n\nDefine the boundary conditions\n\ntop_bc = ClimaLand.Soil.AtmosDrivenFluxBC(atmos, radiation);\nzero_water_flux = WaterFluxBC((p, t) -> 0)\nzero_heat_flux = HeatFluxBC((p, t) -> 0)\nboundary_fluxes = (;\n    top = top_bc,\n    bottom = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n);\n\n[ Info: Warning: No runoff model was provided; zero runoff generated.\n\n\nDefine the parameters n and alpha estimated by matching air entry and Δh_cap values in Lehmann paper\n\nK_sat = FT(225.1 / 3600 / 24 / 1000)\nvg_n = FT(8.91)\nvg_α = FT(3)\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n)\nν = FT(0.43)\nθ_r = FT(0.043)\nS_s = FT(1e-3)\nν_ss_om = FT(0.0)\nν_ss_quartz = FT(1.0)\nν_ss_gravel = FT(0.0)\nemissivity = FT(1.0)\nz_0m = FT(1e-2)\nz_0b = FT(1e-2)\nd_ds = FT(0.01)\nparams = ClimaLand.Soil.EnergyHydrologyParameters(\n    toml_dict;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm = hcm,\n    K_sat,\n    S_s,\n    θ_r,\n    emissivity,\n    z_0m,\n    z_0b,\n    d_ds,\n);\n\nIC functions\n\nfunction hydrostatic_equilibrium(z, z_interface, params)\n    (; ν, S_s, hydrology_cm) = params\n    (; α, n, m) = hydrology_cm\n    if z < z_interface\n        return -S_s * (z - z_interface) + ν\n    else\n        return ν * (1 + (α * (z - z_interface))^n)^(-m)\n    end\nend\nfunction set_ic!(Y, p, t0, model)\n    params = model.parameters\n    z = model.domain.fields.z\n    FT = eltype(Y.soil.ϑ_l)\n    Y.soil.ϑ_l .= hydrostatic_equilibrium.(z, FT(-0.001), params)\n    Y.soil.θ_i .= 0\n    T = FT(296.15)\n    ρc_s = @. Soil.volumetric_heat_capacity(\n        Y.soil.ϑ_l,\n        FT(0),\n        params.ρc_ds,\n        params.earth_param_set,\n    )\n    Y.soil.ρe_int =\n        Soil.volumetric_internal_energy.(FT(0), ρc_s, T, params.earth_param_set)\nend\n\nset_ic! (generic function with 1 method)\n\nDomain - single column\n\nzmax = FT(0)\nzmin = FT(-0.35)\nnelems = 28\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\nz = ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z;\n\nSoil model, and create the prognostic vector Y and cache p:\n\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = (),\n);\n\nTimestepping:\n\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 6,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\nsaveat = Second(3600.0)\nsaving_cb = ClimaLand.NonInterpSavingCallback(start_date, stop_date, saveat)\nsv_hr = saving_cb.affect!.saved_values\n\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    user_callbacks = (saving_cb,),\n    updateat = Second(3600.0),\n    diagnostics = (),\n);\n\nSolve\n\nsol_hr = solve!(simulation);\n\nRepeat at lower resolution\n\nzmax = FT(0)\nzmin = FT(-0.35)\nnelems = 7\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\nz = ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z;\n\nSoil model, and create the prognostic vector Y and cache p:\n\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = (),\n);\n\nTimestepping:\n\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 6,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\n\nsaveat = Second(3600.0)\nsaving_cb = ClimaLand.NonInterpSavingCallback(start_date, stop_date, saveat);\nsv_lr = saving_cb.affect!.saved_values;\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    updateat = Second(3600.0),\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    user_callbacks = (saving_cb,),\n    diagnostics = (),\n);\n\nSolve\n\nsol_lr = solve!(simulation);\n\nExtract the evaporation at each saved step, and convert to mm/day\n\nevap_hr =\n    [\n        parent(sv_hr.saveval[k].soil.turbulent_fluxes.vapor_flux_liq)[1] for\n        k in 1:length(sol_hr.t)\n    ] .* (1000 * 3600 * 24)\nevap_lr =\n    [\n        parent(sv_lr.saveval[k].soil.turbulent_fluxes.vapor_flux_liq)[1] for\n        k in 1:length(sol_lr.t)\n    ] .* (1000 * 3600 * 24)\nevaporation_data = ClimaLand.Artifacts.lehmann2008_evaporation_data();\nref_soln_E = readdlm(evaporation_data, ',')\nref_soln_E_350mm = ref_soln_E[2:end, 1:2]\ndata_dates = ref_soln_E_350mm[:, 1]\ndata_e = ref_soln_E_350mm[:, 2];\n\nGoodness of fit metrics: Mean Absolute Error (MAE) and Kling-Gupta Efficiency (KGE)\n\nmae(x, obs) = mean(abs.(x .- obs));\nfunction kge(x, obs)\n    σx = std(x)\n    σo = std(obs)\n    μx = mean(x)\n    μo = mean(obs)\n    α = σx / σo\n    β = μx / μo\n    r = mean((x .- μx) .* (obs .- μo)) / (σx * σo)\n    return 1 - sqrt((β - 1)^2 + (r - 1)^2 + (α - 1)^2)\nend;\n\nWe need to interpolate the simulation output to the timestamps of the data\n\ninterpolated_lr = [\n    linear_interpolation(FT.(sol_lr.t) ./ 3600 ./ 24, evap_lr, data_date)\n    for data_date in data_dates\n]\ninterpolated_hr = [\n    linear_interpolation(FT.(sol_hr.t) ./ 3600 ./ 24, evap_hr, data_date)\n    for data_date in data_dates\n];\n\n@show mae(interpolated_lr, data_e)\n\n0.9796549232221001\n\n@show mae(interpolated_hr, data_e)\n\n0.9499165362627402\n\n@show kge(interpolated_lr, data_e)\n\n0.3433856781874276\n\n@show kge(interpolated_hr, data_e)\n\n0.36856904909959853\n\nFigures\n\nfig = Figure(size = (800, 400), fontsize = 22)\nax = Axis(\n    fig[1, 1],\n    xlabel = \"Day\",\n    ylabel = \"Evaporation rate (mm/d)\",\n    xgridvisible = false,\n    ygridvisible = false,\n)\nCairoMakie.xlims!(minimum(data_dates), maximum(float.(sol_lr.t) ./ 3600 ./ 24))\nCairoMakie.lines!(\n    ax,\n    FT.(data_dates),\n    FT.(data_e),\n    label = \"Data\",\n    color = :orange,\n    linewidth = 3,\n)\nCairoMakie.lines!(\n    ax,\n    FT.(sol_lr.t) ./ 3600 ./ 24,\n    evap_lr,\n    label = \"Model, 7 elements\",\n    color = :blue,\n    linewidth = 3,\n)\nCairoMakie.lines!(\n    ax,\n    FT.(sol_hr.t) ./ 3600 ./ 24,\n    evap_hr,\n    label = \"Model, 28 elements\",\n    color = :blue,\n    linestyle = :dash,\n    linewidth = 3,\n)\nCairoMakie.axislegend(ax, framevisible = false)\n\nax = Axis(\n    fig[1, 2],\n    xlabel = \"Mass (g)\",\n    yticksvisible = false,\n    yticklabelsvisible = false,\n    xgridvisible = false,\n    ygridvisible = false,\n)\nA_col = π * (0.027)^2\nmass_0_hr = sum(sol_hr.u[1].soil.ϑ_l) * 1e6 * A_col\nmass_loss_hr = [\n    mass_0_hr - sum(sol_hr.u[k].soil.ϑ_l) * 1e6 * A_col for\n    k in 1:length(sol_hr.t)\n]\n\nmass_0_lr = sum(sol_lr.u[1].soil.ϑ_l) * 1e6 * A_col\nmass_loss_lr = [\n    mass_0_lr - sum(sol_lr.u[k].soil.ϑ_l) * 1e6 * A_col for\n    k in 1:length(sol_lr.t)\n]\nCairoMakie.lines!(\n    ax,\n    cumsum(FT.(data_e)) ./ (1000 * 24) .* A_col .* 1e6,\n    FT.(data_e),\n    color = :orange,\n    linewidth = 3,\n)\nCairoMakie.lines!(ax, mass_loss_lr, evap_lr, color = :blue, linewidth = 3)\nCairoMakie.lines!(\n    ax,\n    mass_loss_hr,\n    evap_hr,\n    color = :blue,\n    linewidth = 3,\n    linestyle = :dash,\n)\n\nsave(\"evaporation_lehmann2008_fig8.png\", fig);\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"parameters/#parameters_page","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters/#Default-parameters","page":"Parameters","title":"Default parameters","text":"ClimaLand provides a file toml/default_parameters.toml containing default parameters. For each parameter, this file includes its name, type, default value, units, and model or parameterization it is used for.\n\nClimaLand interacts with TOML parameter files via ClimaParams and ClimaLand.Parameters. To use the default parameter file, we create a parameter dictionary as follows:\n\nimport ClimaLand.Parameters as LP\n\n# Store default parameters\ntoml_dict = LP.create_toml_dict(FT)\n\nThe dictionary toml_dict can then be passed to parameterization and model constructors, and the parameters values defined there will be used.","category":"section"},{"location":"parameters/#How-can-I-check-that-a-parameter-is-actually-being-used?","page":"Parameters","title":"How can I check that a parameter is actually being used?","text":"ClimaParams provides the function ClimaParams.log_parameter_information which logs the parameters used in a simulation. Before calling ClimaLand.Simulations.solve!, log the parameters and inspect the generated TOML file to verify that the particular parameter you're interested in is being used.\n\nnote: Keyword arguments\nNote that any parameter overwritten by a keyword argument will not be logged.\n\n# -- Set up simulation --\nfilepath_to_save_params = \"parameters.log\"\nClimaParams.log_parameter_information(toml_dict, filepath_to_save_params)\nClimaLand.Simulations.solve!(simulation)\n\nnote: Logging parameters with versions above ClimaParams 0.12\nWith how ClimaParams is used with ClimaLand, the ClimaParams.log_parameter_information function requires ClimaParams version above 0.12 to behave correctly.","category":"section"},{"location":"parameters/#Changing-parameter-values","page":"Parameters","title":"Changing parameter values","text":"ClimaLand provides two ways to change parameter values: via keyword arguments of the functions that create the model or parameter struct, or via TOML files.\n\nwarning: Keyword arguments over TOML files\nAny keyword arguments take precedence over the parameters in the TOML files.\n\nParameters stored in TOML files are handled by ClimaParams which also stores parameters in a single TOML file. This allows for a single set of default parameters that can be used universally across multiple experiments and setups.\n\nnote: How should I change parameters?\nIt depends on your use case! For example, if you are running calibration with EnsembleKalmanProcesses.jl, TOML dicts would be a natural choice, as they would be for any simulation using the default model. On the other hand, we use keyword arguments in many of our tutorials to avoid needing a different TOML file for each simulation. However, we recommend that you do not modify the TOML files and keyword arguments at the same time. This can easily lead to confusion about whether the parameter in the TOML file or the keyword argument value is being used in the simulation.","category":"section"},{"location":"parameters/#How-do-I-use-the-TOML-files?","page":"Parameters","title":"How do I use the TOML files?","text":"Most of the constructors for the land model take in a toml_dict, which is a ClimaParams.ParamDict. ClimaLand provides the function create_toml_dict for creating a ClimaParams.ParamDict from a TOML file. See the example below of constructing one.\n\nimport ClimaLand.Parameters as LP\n\n# Store default parameters\ntoml_dict = LP.create_toml_dict(FT)\n\n# Use default parameters overwritten by the parameters in override_files\nLP.create_toml_dict(FT; override_files = [\"override.toml\"])\n","category":"section"},{"location":"parameters/#FAQ","page":"Parameters","title":"FAQ","text":"","category":"section"},{"location":"parameters/#I-added-a-new-parameterization-with-new-parameters.-How-do-I-add-a-parameter-to-a-TOML-file?","page":"Parameters","title":"I added a new parameterization with new parameters. How do I add a parameter to a TOML file?","text":"To add a parameter to the TOML file, a parameter needs a name, value, and type. For example, it could look like this:\n\n[example_land_parameter]\nvalue = 42.0\ntype = \"float\"\ndescription = \"Represents an example land parameter in a new parameterization. Units are m/s.\"\ntag = \"NewParameterizationModel\"\n\nThe possible types are bool, float, integer, or string. All parameter names must be unique. The tag attribute is optional, but we recommend adding a tag to make it easier for other users to know where a particular parameter is used.","category":"section"},{"location":"parameters/#What-parameters-are-available?","page":"Parameters","title":"What parameters are available?","text":"All parameters are stored in:\n\nThe toml directory of ClimaLand\nThe TOML file in ClimaParams","category":"section"},{"location":"parameters/#I-changed-a-parameter-in-the-TOML-file(s)-and-it-did-not-change-the-simulation.-How-can-I-check-that-a-parameter-is-actually-being-used?","page":"Parameters","title":"I changed a parameter in the TOML file(s) and it did not change the simulation. How can I check that a parameter is actually being used?","text":"ClimaParams provides the function ClimaParams.log_parameter_information which logs the parameters used in a simulation. See the first section of this page for more information.\n\nnote: Keyword arguments\nNote that any parameter overwritten by a keyword argument will not be logged.","category":"section"},{"location":"parameters/#API","page":"Parameters","title":"API","text":"","category":"section"},{"location":"parameters/#ClimaLand.Parameters.LandParameters","page":"Parameters","title":"ClimaLand.Parameters.LandParameters","text":"LandParameters(toml_dict::CP.ParamDict)\n\nA constructor from toml_dict for the ClimaLand earth_param_set (LandParameters) struct which contains the default values defined in ClimaParams with type FT (Float32, Float64)\n\nSee ClimaLand.Parameters.create_toml_dict.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#ClimaLand.Parameters.create_toml_dict","page":"Parameters","title":"ClimaLand.Parameters.create_toml_dict","text":"create_toml_dict(FT; override_files = [])\n\nConstruct a ParamDict{FT} struct from the default parameters with any parameter overrides specified in override_files\n\n\n\n\n\n","category":"function"},{"location":"generated/standalone/Usage/model_tutorial/#Creating-a-model","page":"Intro to standalone models","title":"Creating a model","text":"The AbstractModel framework allows users to define land component models (e.g. for snow, soil, vegetation, carbon...) which can be run in standalone mode, or as part of a land surface model with many components. In order to achieve this flexibility, we require a standard interface, which is what AbstractModels provide. The interface is designed to work with an external package for the time-stepping of ODEs, ClimaTimesteppers.jl, with ClimaCore.jl, for the spatial discretization of PDEs, and with ClimaLand.jl, for designing and running multi-component land surface models. For a developer of a new land model component, using AbstractModels as shown below is the first step towards building a model which can be run in standalone or with other components in an integrated land surface model.\n\nThis tutorial introduces some of the functionality of the AbstractModel interface functions and types. We demonstrate how to use a Model <: AbstractModel structure to define a set of equations, and explain a few core methods which must be defined for your Model type in order to run a simulation.","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/#General-setup","page":"Intro to standalone models","title":"General setup","text":"We assume you are solving a system of the form of a set of PDEs or ODEs. Additional algebraic equations can be accomodated as well, but only in addition to variables advanced using differential equations.\n\nSpatially discretized PDEs reduce to a system of ODEs, so we can assume an ODE system in what follows without a loss of generality. When using AbstractModels, you should use ClimaCore to discretize your PDE, as applicable.\n\nYour model defines a system of equations of the following form:\n\nfracd vecYd t = vecf(vecY vecx t mboxparams ldots)\n\nThe variables that are stepped forward via a differential equation are referred to as prognostic variables, and are stored in vecY. Generically, we will speak of the functions vecf as tendencies; these can be functions of the prognostic state, of space vecx, and of time t, as well as of other parameters. Note that quantities such as boundary conditions, source terms, etc, will appear within these tendency functions","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/#The-cache-(\"auxiliary-variables\")","page":"Intro to standalone models","title":"The cache (\"auxiliary variables\")","text":"There are typically quantities, which depend on the state vector vecY, location, time, and other parameters, which are expensive to compute, needed multiple times in the tendency computation, or require \"a lot\" of  memory to store (e.g., most variables in global runs). Allocating memory \"on-the-fly\" is typically time-consuming.  In these cases, it is far better to compute a quantity once and store in a variable where memory has been pre-allocated. The location where memory is allocated is called the model cache.\n\nDenoting the cache as vecp, your equations may be rewritten as:\n\nfracd vecYd t = vecf(vecY vecp vecx t mboxparams ldots)\n\nvecp(vecx t) = vecg(vecY vecx t mboxparams ldots)\n\nThe variables vecp at the current timestep are functions of the prognostic state, space, time, and parameters. These variables are referred to as auxiliary variables (or cache variables). Their main purpose is for storing the value of a quantity in a pre-allocated spot in memory, to avoid computing something expensive many times per time-step, or to avoid allocating memory each timestep. From a mathematical point of view, they represent intermediate quantities computed in each tendency. A model purely consisting of algebraic equations, with no prognostic variables, is not supported (vecY cannot be zero dimensional).\n\nIn order to define this set of equations, in a manner which is consistent with the AbstractModel interface (used by ClimaLand.jl) and time-stepping algorithms (OrdinaryDiffEq.jl for the present), the following must be provided.","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/#The-Model","page":"Intro to standalone models","title":"The Model","text":"All ClimaLand component models are concrete instances of AbstractModels. The reason for grouping them in such a way is because they all have shared required functionality, as we will see, and can make use of common default behavior.\n\nThe model structure holds all of the information needed to create the full right hand side function, including parameters (which can be functions of space and time), boundary conditions, and physical equations.\n\nThe purpose of our AbstractModel interface is that it allows you to run land component models in standalone mode and in an LSM mode without a change in interface.\n\nAs a simple demonstration of use, we'll build a model now which solves Richards Equation assuming a prescribed flux at the surface, and zero flux at the bottom of the column.\n\nNote that some model equations are stiff and require a very small timestep if stepped explicitly in time. Some model equations are amenable to \"imex\" timestepping, where some tendency functions are stepped implicitly, and some are stepped explicitly. Tagging a tendency function as \"explicit\" or \"implicit\" hardcodes something about the timestepping, and as such, conflates the idea of the model (which defines the equations) and the independent idea of a simulation (which solves the equations). However, we decided we did not need to support the flexibility of solving any set of equations in any way, as we are focused on land surface modeling in particular. In this example, we will tag the tendency as an explicitly time-stepped tendency. A follow-on tutorial will explain how to define an implicit tendency and tendency Jacobian.\n\nLet's first import some needed packages.\n\nimport ClimaTimeSteppers as CTS\nusing SciMLBase\nusing Plots\nusing ClimaCore\nusing ClimaLand\nimport ClimaLand.Simulations: LandSimulation, solve!\n\nImport the functions we are extending for our model:\n\nimport ClimaLand:\n    name,\n    make_exp_tendency,\n    make_compute_exp_tendency,\n    make_update_aux,\n    make_update_boundary_fluxes,\n    prognostic_vars,\n    prognostic_types,\n    prognostic_domain_names,\n    auxiliary_vars,\n    auxiliary_types,\n    auxiliary_domain_names\n\nThe model should contain everything you need to create the tendency function. In this case, that is some parameters, the surface flux boundary value, the floating point precision, and the domain of the model (single column, global run, etc..).\n\nstruct RichardsTutorialModel{FT, D} <: AbstractExpModel{FT}\n    \"van Genuchten model parameters\"\n    vGmodel::ClimaLand.Soil.vanGenuchten{FT}\n    \"Porosity [unitless]\"\n    ν::FT\n    \"Residual water fraction [unitless]\"\n    θ_r::FT\n    \"Saturated hydraulic conductiity [m/s]\"\n    Ksat::FT\n    \"Surface flux, used as boundary condition [m/s]\"\n    F_sfc::FT\n    \"Domain of the model\"\n    domain::D\nend;\n\nFor reasons that will be clear momentarily, let's also define the name of the model:\n\nClimaLand.name(model::RichardsTutorialModel) = :soil;","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/#Explicit-tendency","page":"Intro to standalone models","title":"Explicit tendency","text":"Here is where we need to specify the equations of motion. The prognostic variables for Richards equation consist of the volumetric water content at each location in the domain, θ. The differential equations are:\n\nfracpartial ϑ_lpartial t = - -K(θ) (ψ(θ)+z)\n\nwhere K(θ) is the hydraulic conductivity, and ψ(θ) is the matric potential. We now create the function which makes the compute_exp_tendency! function:\n\nfunction ClimaLand.make_compute_exp_tendency(model::RichardsTutorialModel)\n    function compute_exp_tendency!(dY, Y, p, t)\n        gradc2f = ClimaCore.Operators.GradientC2F()\n        interpc2f = ClimaCore.Operators.InterpolateC2F()\n        FT = FTfromY(Y)\n        divf2c = ClimaCore.Operators.DivergenceF2C(\n            top = ClimaCore.Operators.SetValue(\n                ClimaCore.Geometry.WVector.(model.F_sfc),\n            ),\n            bottom = ClimaCore.Operators.SetValue(\n                ClimaCore.Geometry.WVector.(FT(0)),\n            ),\n        )\n\n        @. dY.soil.θ =\n            -(divf2c(-interpc2f(p.soil.K) * gradc2f(p.soil.ψ + p.soil.z)))\n    end\n    return compute_exp_tendency!\nend;\n\nA couple of notes: the vector vecdY contains the evaluation of the tendency function for each variable in vecY. It is updated in place (so no extra allocations are needed). Note that Y is not a simple array. It is a ClimaCore FieldVector, which allow us to impose some organizational structure on the state while still behaving like arrays in some ways. We use the symbol returned by name(model) to create the naming hierarchy in Y, dY, p. This is useful for multi-component models.\n\nThe arguments of compute_exp_tendency! are generic for any time-stepping algorithm. The compute_exp_tendency! function is only created once. If there are time-varying forcing terms appearing, for example, the forcing functions must be stored in model and passed in that way.","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/#The-prognostic-state-vector-\\vec{Y}-and-cache-\\vec{p}","page":"Intro to standalone models","title":"The prognostic state vector vecY and cache vecp","text":"We have given the state vector vecY a particular structure, and don't expect the user to build this themselves. In order to have the structure Y (and p) correctly created, the model developer needs to define the names of the prognostic and auxiliary variables, as well as their types (often a floating point scalar), and where in the domain they are defined. For example, the volumetric water content is a scalar (type FT), with name θ, and it is defined throughout the subsurface of the domain.\n\nClimaLand.prognostic_vars(::RichardsTutorialModel) = (:θ,);\nClimaLand.prognostic_types(::RichardsTutorialModel{FT}) where {FT} = (FT,);\nClimaLand.prognostic_domain_names(::RichardsTutorialModel) = (:subsurface,);\n\nThe auxiliary variables for this model are the hydraulic conductivity, matric potential, boundary fluxes, and heights of each level in the domain. All of these are scalars, and some are defined throughout the soil volume, or subsurface, while some are defined only on a surface (at the top or bottom of the domain).\n\nClimaLand.auxiliary_vars(::RichardsTutorialModel) =\n    (:K, :ψ, :top_flux, :bottom_flux, :z)\nClimaLand.auxiliary_types(::RichardsTutorialModel{FT}) where {FT} =\n    (FT, FT, FT, FT, FT);\nClimaLand.auxiliary_domain_names(::RichardsTutorialModel) =\n    (:subsurface, :subsurface, :surface, :surface, :subsurface);","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/#Updating-the-cache","page":"Intro to standalone models","title":"Updating the cache","text":"We next need to define how we update the auxiliary variables. These are split between two functions, update_aux!, and update_boundary_fluxes!. For standalone component models, these could be combined into a single function, and indeed they could also be part of the tendency function itself.\n\nfunction ClimaLand.make_update_aux(model::RichardsTutorialModel)\n    function update_aux!(p, Y, t)\n        p.soil.z .=\n            ClimaCore.Fields.coordinate_field(model.domain.space.subsurface).z # technically this does not need to update each step\n        @. p.soil.K = ClimaLand.Soil.hydraulic_conductivity(\n            model.vGmodel,\n            model.Ksat,\n            ClimaLand.Soil.effective_saturation(model.ν, Y.soil.θ, model.θ_r),\n        )\n        @. p.soil.ψ = ClimaLand.Soil.matric_potential(\n            model.vGmodel,\n            ClimaLand.Soil.effective_saturation(model.ν, Y.soil.θ, model.θ_r),\n        )\n    end\n    return update_aux!\nend;\n\nfunction ClimaLand.make_update_boundary_fluxes(model::RichardsTutorialModel)\n    function update_boundary_fluxes!(p, Y, t)\n        FT = ClimaLand.FTfromY(Y)\n        p.soil.top_flux .= model.F_sfc\n        p.soil.bottom_flux .= FT(0)\n    end\n    return update_boundary_fluxes!\nend;\n\nThe default tendency function in ClimaLand for any AbstractModel carries out the following:\n\nfunction make_exp_tendency(model::AbstractModel)\n    update_aux! = make_update_aux(model)\n    update_boundary_fluxes! = make_update_boundary_fluxes(model)\n    compute_exp_tendency! = make_compute_exp_tendency(model)\n    function exp_tendency!(dY,Y,p,t)\n        update_aux!(p,Y,t)\n        update_boundary_fluxes!(p,Y,t)\n        compute_exp_tendency!(dY,Y,p,t)\n    end\n    return exp_tendency!\nend;\n\nTherefore, each time we need the tendency, we first update auxiliary variables, then update boundary fluxes, and then compute the tendency itself.\n\nWhy do we do this? It would be straightforward, and arguably a lot simpler, to update the cache p within compute_exp_tendency!itself. The reason why we introduce these other functions is because we want to be able to combine standalone \"component\" models, like this one, with others, to create land surface models. For example, if we would like to run a land surface model with the soil and the canopy, the canopy auxiliary variables (e.g. interception of water and snow, transmitted radiation) affect the boundary fluxes of the soil. In this case, we must update auxiliary variables for all components, before computing boundary conditions and tendency functions. Please see the (LSM tutorial) for further explanation.\n\nMore complex cases might require the evaluation of external data. For this, use the TimeVaryingInput interface. You can wrap functions, 1D/2D data in TimeVaryingInput to obtain an object that know how to evaluate that data on the model time (e.g., by performing linear interpolation). Then, in your model, you can just call evaluate!(destination, itp, time) to evaluate the itp on the given time and write the result to dest (typically a Field). With this common interface, you do not have to worry about the detail of the underlying data.","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/#Running-a-simulation","page":"Intro to standalone models","title":"Running a simulation","text":"Create a model instance.\n\nFT = Float32\nvGmodel = ClimaLand.Soil.vanGenuchten{FT}(; α = 2.3f0, n = 2.0f0)\nKsat = FT(4.0e-7)\nν = 0.5f0\nθ_r = 0.0f0\nF_sfc = FT(-3.0e-8)\ndomain = ClimaLand.Domains.Column(; zlim = (-1.0f0, 0.0f0), nelements = 10)\nsoil = RichardsTutorialModel{Float32, typeof(domain)}(\n    vGmodel,\n    ν,\n    θ_r,\n    Ksat,\n    F_sfc,\n    domain,\n);\n\nHere we create a function to update Y in place with initial conditions of our choosing.\n\nfunction set_ic!(Y, p, t0, model)\n    Y.soil.θ = 0.25f0\nend\n\nset_ic! (generic function with 1 method)","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/#Creating-and-running-the-simulation","page":"Intro to standalone models","title":"Creating and running the simulation","text":"Set the initial and end times, timestep:\n\nt0 = 0.0;\ntf = 7 * 24 * 3600.0;\ndt = 1800.0;\n\nSelect the timestepping algorithm we want to use from CTS.jl.\n\ntimestepper = CTS.RK4()\node_algo = CTS.ExplicitAlgorithm(timestepper)\n\nsimulation = LandSimulation(\n    t0,\n    tf,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    solver_kwargs = (; save_everystep = true),\n    timestepper = ode_algo,\n    user_callbacks = (),\n    diagnostics = (),\n);\n\nY = simulation._integrator.u\np = simulation._integrator.p\n\n(soil = (K = Float32-valued Field:\n  Float32[5.0768f-9, 5.0768f-9, 5.0768f-9, 5.0768f-9, 5.0768f-9, 5.0768f-9, 5.0768f-9, 5.0768f-9, 5.0768f-9, 5.0768f-9], ψ = Float32-valued Field:\n  Float32[-0.753066, -0.753066, -0.753066, -0.753066, -0.753066, -0.753066, -0.753066, -0.753066, -0.753066, -0.753066], top_flux = Float32-valued Field:\n  Float32[-3.0f-8], bottom_flux = Float32-valued Field:\n  Float32[0.0], z = Float32-valued Field:\n  Float32[-0.95, -0.85, -0.75, -0.65, -0.55, -0.45, -0.35, -0.25, -0.15, -0.05]),)\n\nNote that Y has the structure we planned on in our compute_exp_tendency! function, for x,\n\nY.soil\n\n1-blocked 10-element ClimaCore.Fields.FieldVector{Float32, @NamedTuple{θ::ClimaCore.Fields.Field{ClimaCore.DataLayouts.VF{Float32, 10, Matrix{Float32}}, ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Meshes.Uniform, ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float32}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float32}, Int64}, Nothing}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}}, 10, Matrix{Float32}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}}, 11, Matrix{Float32}}}, ClimaCore.Grids.CellCenter}}}}:\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n\nThe same is true for p:\n\np.soil\n\n@show p.soil.K\n\n@show p.soil.ψ\n\n@show p.soil.top_flux\n\nFloat32-valued Field:\n  Float32[-3.0f-8]\n\nSolve command:\n\nsol = solve!(simulation);\n\nThe solution is stored in sol.u[k].soil.θ, where k ranges over the number of timesteps.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/Domains/#ClimaLand-Domains","page":"Domains","title":"ClimaLand Domains","text":"","category":"section"},{"location":"APIs/Domains/#ClimaLand.Domains.AbstractDomain","page":"Domains","title":"ClimaLand.Domains.AbstractDomain","text":"AbstractDomain{FT <:AbstractFloat}\n\nAn abstract type for domains.\n\nThe domain structs typically hold information regarding the bounds of the domain, the boundary condition type (periodic or not), and the spatial discretization.\n\nAdditionally, the domain struct holds the relevant spaces for that domain. For example, a 3D domain holds the center space (in terms of finite difference - the space corresponding to the centers of each element), and the top face space where surface fluxes are computed.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Domains/#ClimaLand.Domains.SphericalShell","page":"Domains","title":"ClimaLand.Domains.SphericalShell","text":"struct SphericalShell{FT} <: AbstractDomain{FT}\n    radius::FT\n    depth::FT\n    dz_tuple::Union{Tuple{FT, FT}, Nothing}\n    nelements::Tuple{Int, Int}\n    npolynomial::Int\nend\n\nA struct holding the necessary information to construct a domain, a mesh, a 2d spectral element space (non-radial directions) x a 1d finite difference space (radial direction),  and the resulting coordinate field.\n\nspace is a NamedTuple holding the surface space (in this case, the top face space) and the center space for the subsurface. These are stored using the keys :surface and :subsurface.\n\nFields\n\nradius: The radius of the shell\ndepth: The radial extent of the shell\ndz_tuple: Tuple for mesh stretching specifying target (dzbottom, dztop) (m). If nothing, no stretching is applied.\nnelements: The number of elements to be used in the non-radial and radial directions\nnpolynomial: The polynomial order to be used in the non-radial directions\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface space and subsurface center space\nfields: Fields and field data associated with the coordinates of the domain that are useful to store\n\n\n\n\n\n","category":"type"},{"location":"APIs/Domains/#ClimaLand.Domains.SphericalSurface","page":"Domains","title":"ClimaLand.Domains.SphericalSurface","text":"struct SphericalSurface{FT} <: AbstractDomain{FT}\n    radius::FT\n    nelements::Tuple{Int, Int}\n    npolynomial::Int\nend\n\nA struct holding the necessary information to construct a domain, a mesh, a 2d spectral element space (non-radial directions) and the resulting coordinate field.\n\nspace is a NamedTuple holding the surface space (in this case, the entire SphericalSurface space).\n\nFields\n\nradius: The radius of the surface\nnelements: The number of elements to be used in the non-radial directions\nnpolynomial: The polynomial order to be used in the non-radial directions\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface (SphericalSurface) space\n\n\n\n\n\n","category":"type"},{"location":"APIs/Domains/#ClimaLand.Domains.HybridBox","page":"Domains","title":"ClimaLand.Domains.HybridBox","text":"struct HybridBox{FT} <: AbstractDomain{FT}\n    xlim::Tuple{FT, FT}\n    ylim::Tuple{FT, FT}\n    zlim::Tuple{FT, FT}\n    longlat::Union{Nothing, Tuple{FT, FT}},\n    dz_tuple::Union{Tuple{FT, FT}, Nothing}\n    nelements::Tuple{Int, Int, Int}\n    npolynomial::Int\n    periodic::Tuple{Bool, Bool}\nend\n\nA struct holding the necessary information to construct a domain, a mesh, a 2d spectral element space (horizontal) x a 1d finite difference space (vertical), and the resulting coordinate field. This domain is not periodic along the z-axis. Note that no-flow boundary conditions are supported in the horizontal.\n\nWhen longlat is not nothing, assume that the box describes a region on the globe centered around the long and lat.\n\nspace is a NamedTuple holding the surface space (in this case, the top face space) and the center space for the subsurface. These are stored using the keys :surface and :subsurface.\n\nFields\n\nxlim: Domain interval limits along x axis, in meters or degrees (if latlong != nothing)\nylim: Domain interval limits along y axis, in meters or degrees (if latlong != nothing)\nzlim: Domain interval limits along z axis, in meters\nlonglat: When not nothing, a Tuple that contains the center long and lat.\ndz_tuple: Tuple for mesh stretching specifying target (dzbottom, dztop) (m). If nothing, no stretching is applied.\nnelements: Number of elements to discretize interval, (nx, ny,nz)\nnpolynomial:  Polynomial order for the horizontal directions\nperiodic: Flag indicating periodic boundaries in horizontal\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface space and subsurface center space\nfields: Fields and field data associated with the coordinates of the domain that are useful to store\n\n\n\n\n\n","category":"type"},{"location":"APIs/Domains/#ClimaLand.Domains.Column","page":"Domains","title":"ClimaLand.Domains.Column","text":"Column{FT} <: AbstractDomain{FT}\n\nA struct holding the necessary information to construct a domain, a mesh, a center and face space, etc. for use when a finite difference in 1D is suitable, as for a soil column model.\n\nspace is a NamedTuple holding the surface space (in this case, the top face space) and the center space for the subsurface. These are stored using the keys :surface and :subsurface.\n\nFields\n\nzlim: Domain interval limits, (zmin, zmax), in meters\nnelements: Number of elements used to discretize the interval\ndz_tuple: Tuple for mesh stretching specifying target (dzbottom, dztop) (m). If nothing, no stretching is applied.\nboundary_names: Boundary face identifiers\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface space and subsurface center space\nfields: Fields and field data associated with the coordinates of the domain that are useful to store\n\n\n\n\n\n","category":"type"},{"location":"APIs/Domains/#ClimaLand.Domains.Plane","page":"Domains","title":"ClimaLand.Domains.Plane","text":"Plane{FT} <: AbstractDomain{FT}\n\nA struct holding the necessary information to construct a domain, a mesh, a 2d spectral element space, and the resulting coordinate field.\n\nWhen longlat is not nothing, the plane is assumed to be centered around these coordinates. In this case, the curvature of the Earth is not accounted for.\n\nlonglat are in degrees, with longitude going from -180 to 180.\n\n:warning: Only independent columns are supported! (No lateral flow).\n\nspace is a NamedTuple holding the surface space (in this case, the entire Plane space).\n\nFields\n\nxlim: Domain interval limits along x axis, in meters or degrees (if latlong != nothing)\nylim: Domain interval limits along y axis, in meters or degrees (if latlong != nothing)\nlonglat: When not nothing, a Tuple that contains the center long and lat (in degrees, with long     from -180 to 180).\nnelements: Number of elements to discretize interval, (nx, ny)\nperiodic: Flags for periodic boundaries. Only periodic or no lateral flow is supported.\nnpolynomial: Polynomial order for both x and y\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface(Plane) space\n\n\n\n\n\n","category":"type"},{"location":"APIs/Domains/#ClimaLand.Domains.Point","page":"Domains","title":"ClimaLand.Domains.Point","text":"Point{FT} <: AbstractDomain{FT}\n\nA domain for single column surface variables. For models such as ponds, snow, plant hydraulics, etc. Enables consistency in variable initialization across all domains.\n\nspace is a NamedTuple holding the surface space (in this case, the Point space).\n\nFields\n\nz_sfc: Surface elevation relative to a reference (m)\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the Point (surface) space\n\n\n\n\n\n","category":"type"},{"location":"APIs/Domains/#ClimaLand.Domains.global_domain","page":"Domains","title":"ClimaLand.Domains.global_domain","text":"global_domain(\n    FT;\n    apply_mask = true,\n    mask_threshold = 0.5,\n    nelements = (101, 15),\n    dz_tuple = (3.0, 0.05),\n    depth = 15.0,\n    npolynomial = 0,\n    context = ClimaComms.context(),\n    filepath = landseamask_file_path(;context),\n    regridder_type = :InterpolationsRegridder,\n    extrapolation_bc = (\n        Interpolations.Periodic(),\n        Interpolations.Flat(),\n        Interpolations.Flat(),\n    ),\n    interpolation_method = Interpolations.Constant()\n)\n\nHelper function to create a SphericalShell domain with nelements elements, a depth of 50m, vertical layering ranging from 0.05m in depth at the surface to 10m at the bottom of the domain, with npolynomial = 0 and GL quadrature.\n\nnpolynomial determines the order of polynomial base to use for the spatial discretization, which is correlated to the spatial resolution of the domain.\n\nWhen npolynomial is zero, the element is equivalent to a single point. In this case, the resolution of the model is sqrt((360 x 180)/(101 x 101 x 6)). The factor of 6 arises because there are 101x101 elements per side of the cubed sphere, meaning 6 x 101 x 101 for the entire globe.\n\nWhen npolynomial is greater than 1, a Gauss-Legendre-Lobotto quadrature is used, with npolynomial + 1 points along the element. In this case, there are always points two points on the boundaries for each direction with the other points in the interior. These points are not equally spaced.\n\nIn practice, there is no reason to use npolynomial greater than 1 in the current version of ClimaLand. To increase resolution, we recommend increasing the number of elements rather than increasing the polynomial order.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Domains/#ClimaLand.Domains.global_box_domain","page":"Domains","title":"ClimaLand.Domains.global_box_domain","text":"global_box_domain(\n    FT;\n    apply_mask = true,\n    mask_threshold = 0.5,\n    nelements = (180, 360, 15),\n    dz_tuple = (10.0, 0.05),\n    depth = 50.0,\n    npolynomial = 0,\n    context = ClimaComms.context(),\n    filepath = landseamask_file_path(;context),\n    regridder_type = :InterpolationsRegridder,\n    extrapolation_bc = (\n    Interpolations.Periodic(),\n    Interpolations.Flat(),\n    Interpolations.Flat(),\n    ),\n    interpolation_method = Interpolations.Constant()\n)\n\nHelper function to create a HybridBox domain corresponding to the entire globe, i.e. a regular latitude/longitude grid  with nelements[1:2] horizontal elements (lat, long). The box has a depth of 50m, vertical layering ranging from 0.05m in depth at the surface to 10m at the bottom of the domain, with npolynomial = 0, GL quadrature,  and nelements[3] vertical elements.\n\nnpolynomial determines the order of polynomial base to use for the spatial discretization, which is correlated to the spatial resolution of the domain.\n\nWhen npolynomial is zero, the element is equivalent to a single point. In this case, the resolution of the model with the default nelements is one degree.\n\nWhen npolynomial is greater than 1, a Gauss-Legendre-Lobotto quadrature is used, with npolynomial + 1 points along the element. In this case, there are always points two points on the boundaries for each direction with the other points in the interior. These points are not equally spaced.\n\nIn practice, there is no reason to use npolynomial greater than 1 in the current version of ClimaLand. To increase resolution, we recommend increasing the number of elements rather than increasing the polynomial order.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Domains/#ClimaLand.Domains.coordinates","page":"Domains","title":"ClimaLand.Domains.coordinates","text":"coordinates(domain::AbstractDomain)\n\nReturns the coordinate fields for the domain as a NamedTuple.\n\nThe returned coordinates are stored with keys :surface, :subsurface, e.g. as relevant for the domain.\n\n\n\n\n\nDomains.coordinates(model::AbstractLandModel)\n\nReturns a NamedTuple of the unique set of coordinates for the LSM model, where the unique set is taken over the coordinates of all of the subcomponents.\n\nFor example, an LSM with a single layer snow model, multi-layer soil model, and canopy model would have a coordinate set corresponding to the coordinates of the surface (snow), the subsurface coordinates (soil) and the coordinates of the surface (canopy). This would return the coordinates of the surface and subsurface. These are distinct because the subsurface coordinates correspond to the centers of the layers, while the surface corresponds to the top face of the domain.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Domains/#ClimaLand.Domains.obtain_surface_space","page":"Domains","title":"ClimaLand.Domains.obtain_surface_space","text":"obtain_surface_space(cs::ClimaCore.Spaces.AbstractSpace)\n\nReturns the surface space, if applicable, for the center space cs.\n\n\n\n\n\nobtain_surface_space(cs::ClimaCore.Spaces.CenterExtrudedFiniteDifferenceSpace)\n\nReturns the horizontal space for the CenterExtrudedFiniteDifferenceSpace cs.\n\n\n\n\n\nobtain_surface_space(cs::ClimaCore.Spaces.FiniteDifferenceSpace)\n\nReturns the top level of the face space corresponding to the input space cs.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Domains/#ClimaLand.Domains.obtain_surface_domain","page":"Domains","title":"ClimaLand.Domains.obtain_surface_domain","text":"obtain_surface_domain(d::AbstractDomain) where {FT}\n\nDefault method throwing an error; any domain with a corresponding domain should define a new method of this function.\n\n\n\n\n\nobtain_surface_domain(c::Column{FT}) where {FT}\n\nReturns the Point domain corresponding to the top face (surface) of the Column domain c.\n\n\n\n\n\nobtain_surface_domain(b::HybridBox{FT}) where {FT}\n\nReturns the Plane domain corresponding to the top face (surface) of the HybridBox domain b.\n\n\n\n\n\nobtain_surface_domain(s::SphericalShell{FT}) where {FT}\n\nReturns the SphericalSurface domain corresponding to the top face (surface) of the SphericalShell domain s.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Domains/#ClimaLand.Domains.top_face_to_surface","page":"Domains","title":"ClimaLand.Domains.top_face_to_surface","text":"top_face_to_surface(face_field::ClimaCore.Fields.Field, surface_space)\n\nCreates and returns a ClimaCore.Fields.Field defined on the space corresponding to the surface of the space on which face_field is defined, with values equal to the those at the level of the top face.\n\nGiven a face_field defined on a 3D extruded face finite difference space, this would return a 2D field corresponding to the surface, with values equal to the topmost level.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Domains/#ClimaLand.Domains.linear_interpolation_to_surface!","page":"Domains","title":"ClimaLand.Domains.linear_interpolation_to_surface!","text":"linear_interpolation_to_surface!(sfc_field, center_field, z, Δz_top)\n\nLinearly interpolate the center field center_field to the surface defined by the top face coordinate of z with a center to face distance Δz_top in the first layer; updates the sfc_field on the surface (face) space in place.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Domains/#ClimaLand.Domains.get_Δz","page":"Domains","title":"ClimaLand.Domains.get_Δz","text":"get_Δz(z::ClimaCore.Fields.Field)\n\nA function to return a tuple containing the distance between the top boundary and its closest center, and the bottom boundary and its closest center, both as Fields. It also returns the widths of each layer as a field.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Domains/#ClimaLand.Domains.average_horizontal_resolution_degrees","page":"Domains","title":"ClimaLand.Domains.average_horizontal_resolution_degrees","text":"horizontal_resolution_degrees(domain::AbstractDomain)\n\nReturn a tuple with the approximate resolution on the domain in degrees along the two directions.\n\nFor boxes and planes, the order is (latitude, longitude).\n\nExamples\n\njulia> using ClimaLand\n\njulia> domain = ClimaLand.Domains.SphericalShell(;\n        radius = 6300e3,\n        depth = 15.,\n        nelements = (10, 3),\n        dz_tuple = ((1.0, 0.05)));\n\njulia> ClimaLand.Domains.average_horizontal_resolution_degrees(domain)\n(9.0, 9.0)\n\njulia> domain = ClimaLand.Domains.Plane(;\n        xlim = (50000.0, 80000.),\n        ylim = (30000.0, 40000.),\n        longlat = (-118.14452, 34.14778),\n        nelements = (20, 3));\n\njulia> round.(ClimaLand.Domains.average_horizontal_resolution_degrees(domain), digits = 3)\n(0.031, 0.389)\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand","page":"Integrated Models","title":"ClimaLand","text":"","category":"section"},{"location":"APIs/ClimaLand/#Integrated-Land-Model-Types-and-methods","page":"Integrated Models","title":"Integrated Land Model Types and methods","text":"","category":"section"},{"location":"APIs/ClimaLand/#Land-Hydrology","page":"Integrated Models","title":"Land Hydrology","text":"","category":"section"},{"location":"APIs/ClimaLand/#SoilCanopyModel","page":"Integrated Models","title":"SoilCanopyModel","text":"","category":"section"},{"location":"APIs/ClimaLand/#LandSoilBiogeochemistry","page":"Integrated Models","title":"LandSoilBiogeochemistry","text":"","category":"section"},{"location":"APIs/ClimaLand/#ClimaLand.LandModel","page":"Integrated Models","title":"ClimaLand.LandModel","text":"struct LandModel{\n    FT,\n    MM <: Union{Soil.Biogeochemistry.SoilCO2Model{FT}, Nothing},\n    SM <: Soil.EnergyHydrology{FT},\n    VM <: Canopy.CanopyModel{FT},\n    SnM <: Snow.SnowModel{FT},\n} <: AbstractLandModel{FT}\n    \"The soil microbe model to be used, or `nothing` if no soil microbe model is used\"\n    soilco2::MM\n    \"The soil model to be used\"\n    soil::SM\n    \"The canopy model to be used\"\n    canopy::VM\n    \"The snow model to be used\"\n    snow::SnM\nend\n\nA concrete type of land model used for simulating systems with soil, canopy, snow, soilco2.\n\nClimaLand v1: SoilCO2 is still under testing, but errors in soilco2 do not propagate into the other components.\n\nsoilco2: The soil microbe model to be used\nsoil: The soil model to be used\ncanopy: The canopy model to be used\nsnow: The snow model to be used\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.LandModel-Union{Tuple{FT}, Tuple{Any, Any, ClimaParams.ParamDict, Union{ClimaLand.Domains.Column, ClimaLand.Domains.HybridBox, ClimaLand.Domains.SphericalShell}, Any}} where FT","page":"Integrated Models","title":"ClimaLand.LandModel","text":"LandModel{FT}(\n    forcing,\n    LAI,\n    toml_dict::CP.ParamDict,\n    domain::Union{\n        ClimaLand.Domains.Column,\n        ClimaLand.Domains.SphericalShell,\n        ClimaLand.Domains.HybridBox,\n    },\n    Δt;\n    prognostic_land_components = (:canopy, :snow, :soil),\n    soil = Soil.EnergyHydrology{FT}(\n        domain,\n        forcing,\n        toml_dict;\n        prognostic_land_components,\n        additional_sources = (ClimaLand.RootExtraction{FT}(),),\n    ),\n    soilco2 = :soilco2 in prognostic_land_components ?\n            Soil.Biogeochemistry.SoilCO2Model{FT}(\n        domain,\n        Soil.Biogeochemistry.SoilDrivers(\n            PrognosticMet(soil.parameters),\n            forcing.atmos,\n        ),\n        toml_dict,\n    ) : nothing,\n    canopy = Canopy.CanopyModel{FT}(\n        Domains.obtain_surface_domain(domain),\n        (;\n            atmos = forcing.atmos,\n            radiation = forcing.radiation,\n            ground = ClimaLand.PrognosticGroundConditions{FT}(),\n        ),\n        LAI,\n        toml_dict;\n        prognostic_land_components,\n    ),\n    snow = Snow.SnowModel(\n        FT,\n        ClimaLand.Domains.obtain_surface_domain(domain),\n        forcing,\n        toml_dict,\n        Δt;\n        prognostic_land_components,\n    ),\n) where {FT}\n\nA convenience constructor for setting up the default LandModel, where all the parameterizations and parameter values are set to default values or passed in via the toml_dict. The boundary conditions of all models correspond to forcing with the atmosphere, as specified by forcing, a NamedTuple of the form (;atmos, radiation), with atmos an AbstractAtmosphericDriver and radiation and AbstractRadiativeDriver. The leaf area index LAI must be provided (prescribed) as a TimeVaryingInput, and the domain must be a ClimaLand domain with a vertical extent. Finally, since the snow model requires the timestep, that is a required argument as well. By default, no soilco2 model is included; to include one, include :soilco2 in the prognostic_land_components keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"APIs/ClimaLand/#ClimaLand.SoilCanopyModel","page":"Integrated Models","title":"ClimaLand.SoilCanopyModel","text":"struct SoilCanopyModel{\n    FT,\n    MM <: Soil.Biogeochemistry.SoilCO2Model{FT},\n    SM <: Soil.EnergyHydrology{FT},\n    VM <: Canopy.CanopyModel{FT},\n} <: AbstractLandModel{FT}\n    \"The soil microbe model to be used\"\n    soilco2::MM\n    \"The soil model to be used\"\n    soil::SM\n    \"The canopy model to be used\"\n    canopy::VM\nend\n\nA concrete type of land model used for simulating systems with a canopy, a soil, and a soilco2 component.\n\nClimaLand v1: SoilCO2 is still under testing, but errors in soilco2 do not propagate into the other components.\n\nsoilco2: The soil microbe model to be used\nsoil: The soil model to be used\ncanopy: The canopy model to be used\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.SoilCanopyModel-Union{Tuple{FT}, Tuple{Any, Any, ClimaParams.ParamDict, Union{ClimaLand.Domains.Column, ClimaLand.Domains.SphericalShell}}} where FT","page":"Integrated Models","title":"ClimaLand.SoilCanopyModel","text":"SoilCanopyModel{FT}(\n    forcing,\n    LAI,\n    toml_dict::CP.ParamDict,\n    domain::Union{ClimaLand.Domains.Column, ClimaLand.Domains.SphericalShell};\n    soil = Soil.EnergyHydrology{FT}(\n        domain,\n        forcing,\n        toml_dict;\n        prognostic_land_components = (:canopy, :soil, :soilco2),\n        additional_sources = (ClimaLand.RootExtraction{FT}(),),\n    ),\n    soilco2 = Soil.Biogeochemistry.SoilCO2Model{FT}(\n        domain,\n        Soil.Biogeochemistry.SoilDrivers(\n           PrognosticMet(soil.parameters),\n            forcing.atmos,\n        ),\n        toml_dict,\n    ),\n    canopy = Canopy.CanopyModel{FT}(\n        Domains.obtain_surface_domain(domain),\n        (;\n            atmos = forcing.atmos,\n            radiation = forcing.radiation,\n            ground = ClimaLand.PrognosticGroundConditions{FT}(),\n        ),\n        LAI,\n        toml_dict;\n        prognostic_land_components = (:canopy, :soil, :soilco2),\n    ),\n) where {FT}\n\nA convenience constructor for setting up the default SoilCanpyModel, where all the parameterizations and parameter values are set to default values or passed in via the toml_dict. The boundary conditions of all models correspond to forcing with the atmosphere, as specified by forcing, a NamedTuple of the form (;atmos, radiation), with atmos an AbstractAtmosphericDriver and radiation and AbstractRadiativeDriver. The leaf area index LAI must be provided (prescribed) as a TimeVaryingInput, and the domain must be a ClimaLand domain with a vertical extent.\n\n\n\n\n\n","category":"method"},{"location":"APIs/ClimaLand/#ClimaLand.LandSoilBiogeochemistry","page":"Integrated Models","title":"ClimaLand.LandSoilBiogeochemistry","text":"struct LandSoilBiogeochemistry{\n    FT,\n    SEH <: Soil.EnergyHydrology{FT},\n    SB <: Soil.Biogeochemistry.SoilCO2Model{FT},\n} <: AbstractLandModel{FT}\n\nA concrete type of land model used for simulating systems with a soil energy, hydrology, and biogeochemistry component.\n\nClimaLand v1: SoilCO2 is still under testing, but errors in soilco2 do not propagate into the other components.\n\nsoil: The soil model\nsoilco2: The biochemistry model\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.LandSoilBiogeochemistry-Union{Tuple{FT}, Tuple{Any, ClimaParams.ParamDict, Union{ClimaLand.Domains.Column, ClimaLand.Domains.SphericalShell}}} where FT","page":"Integrated Models","title":"ClimaLand.LandSoilBiogeochemistry","text":"LandSoilBiogeochemistry{FT}(\n    forcing,\n    toml_dict::CP.ParamDict,\n    domain::Union{ClimaLand.Domains.Column, ClimaLand.Domains.SphericalShell};\n    soil = Soil.EnergyHydrology{FT}(\n        domain,\n        forcing,\n        toml_dict;\n    ),\n    soilco2 = Soil.Biogeochemistry.SoilCO2Model{FT}(\n        domain,\n        Soil.Biogeochemistry.SoilDrivers(\n           Soil.Biogeochemistry.PrognosticMet(soil.parameters),\n            forcing.atmos,\n        ),\n        toml_dict,\n    ),\n) where {FT}\n\nA convenience constructor for setting up the default LandSoilBiogeochemistry, where all the parameterizations and parameter values are set to default values or passed in via the toml_dict. The boundary conditions of all models correspond to forcing with the atmosphere, as specified by forcing, a NamedTuple of the form (;atmos, radiation), with atmos an AbstractAtmosphericDriver and radiation an AbstractRadiativeDriver. The domain must be a ClimaLand domain with a vertical extent.\n\n\n\n\n\n","category":"method"},{"location":"APIs/ClimaLand/#ClimaLand.SoilSnowModel","page":"Integrated Models","title":"ClimaLand.SoilSnowModel","text":"struct SoilSnowModel{\n    FT,\n    SnM <: Snow.SnowModel{FT},\n    SoM <: Soil.EnergyHydrology{FT},\n} <: AbstractLandModel{FT}\n    \"The snow model to be used\"\n    snow::SnM\n    \"The soil model to be used\"\n    soil::SoM\nend\n\nA concrete type of land model used for simulating systems with snow and soil.\n\nThe inner constructor checks that the two models are consistent with respect to the forcing (atmos, radiation), the parameters, the domain, and the prognostic land components of the model.\n\nsnow: The snow model to be used\nsoil: The soil model to be used\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.SoilSnowModel-Union{Tuple{FT}, Tuple{Any, ClimaParams.ParamDict, Union{ClimaLand.Domains.Column, ClimaLand.Domains.SphericalShell}, Any}} where FT","page":"Integrated Models","title":"ClimaLand.SoilSnowModel","text":"SoilSnowModel{FT}(\n    forcing,\n    toml_dict::CP.ParamDict,\n    domain::Union{ClimaLand.Domains.Column, ClimaLand.Domains.SphericalShell},\n    Δt;\n    soil = Soil.EnergyHydrology{FT}(\n        domain,\n        forcing,\n        toml_dict;\n        prognostic_land_components = (:snow, :soil),\n        additional_sources = (),\n    ),\n    snow = Snow.SnowModel(\n        FT,\n        ClimaLand.Domains.obtain_surface_domain(domain),\n        forcing,\n        toml_dict,\n        Δt;\n        prognostic_land_components = (:snow, :soil,),\n    ),\n) where {FT}\n\nA convenience constructor for setting up the default SoilSnowModel, where all the parameterizations and parameter values are set to default values or passed in via the toml_dict. The boundary conditions of all models correspond to forcing with the atmosphere, as specified by forcing, a NamedTuple of the form (;atmos, radiation), with atmos an AbstractAtmosphericDriver and radiation an AbstractRadiativeDriver. The domain must be a ClimaLand domain with a vertical extent. Finally, since the snow model requires the timestep, that is a required argument as well.\n\n\n\n\n\n","category":"method"},{"location":"APIs/ClimaLand/#ClimaLand.LandHydrology","page":"Integrated Models","title":"ClimaLand.LandHydrology","text":"struct LandHydrology{\n    FT,\n    SM <: Soil.AbstractSoilModel{FT},\n    SW <: Pond.AbstractSurfaceWaterModel{FT},\n} <: AbstractLandModel{FT}\n\nA concrete type of land model used for simulating systems with a soil and surface water component.\n\nsoil: The soil model\nsurface_water: The surface water model\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.land_components","page":"Integrated Models","title":"ClimaLand.land_components","text":"land_components(land::AbstractLandModel)\n\nReturns the component names of the land model, by calling propertynames(land).\n\n\n\n\n\nClimaLand.land_components(land::LandModel)\n\nReturns the components of the LandModel.\n\nCurrently, this method is required in order to preserve an ordering in how we update the component models' auxiliary states. The canopy update_aux! step depends on snow and soil albedo, but those are only updated in the snow and soil update_aux! steps. So those must occur first (as controlled by the order of the components returned by land_components!.\n\nThis needs to be fixed.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.lsm_aux_vars","page":"Integrated Models","title":"ClimaLand.lsm_aux_vars","text":"lsm_aux_vars(m::AbstractLandModel)\n\nReturns the additional aux variable symbols for the model in the form of a tuple.\n\n\n\n\n\nlsm_aux_vars(m::SoilCanopyModel)\n\nThe names of the additional auxiliary variables that are included in the integrated Soil-Canopy model.\n\nThese include the broadband albedo of the land surface α_sfc, defined as the ratio of SWu/SWd, and T_sfc, defined as the temperature a blackbody with emissivity ϵ_sfc would have in order to emit the same LW_u as the land surface does. This is called the effective temperature in some fields, and is not the same as the skin temperature (defined e.g. Equation 7.13 of  Bonan, 2019, Climate Change and Terrestrial Ecosystem Modeling.  DOI: 10.1017/9781107339217).\n\n\n\n\n\nlsm_aux_vars(m::SoilSnowModel)\n\nThe names of the additional auxiliary variables that are included in the integrated Soil-Snow model.\n\n\n\n\n\nlsm_aux_vars(m::LandModel)\n\nThe names of the additional auxiliary variables that are included in the land model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.lsm_aux_types","page":"Integrated Models","title":"ClimaLand.lsm_aux_types","text":"lsm_aux_types(m::AbstractLandModel)\n\nReturns the shared additional aux variable types for the model in the form of a tuple.\n\n\n\n\n\nlsm_aux_types(m::SoilCanopyModel)\n\nThe types of the additional auxiliary variables that are included in the integrated Soil-Canopy model.\n\n\n\n\n\nlsm_aux_types(m::SoilSnowModel)\n\nThe types of the additional auxiliary variables that are included in the integrated Soil-Snow model.\n\n\n\n\n\nlsm_aux_types(m::LandModel)\n\nThe types of the additional auxiliary variables that are included in the land model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.lsm_aux_domain_names","page":"Integrated Models","title":"ClimaLand.lsm_aux_domain_names","text":"lsm_aux_domain_names(m::AbstractLandModel)\n\nReturns the additional domain symbols in the form of a tuple e.g. :surface or :subsurface.\n\nThis is only required for variables shared between land submodels, and only needed for multi-component models, not standalone components. Component-specific variables should be listed as prognostic or auxiliary variables which do not require this to initialize.\n\n\n\n\n\nlsm_aux_domain_names(m::SoilCanopyModel)\n\nThe domain names of the additional auxiliary variables that are included in the integrated Soil-Canopy model.\n\n\n\n\n\nlsm_aux_domain_names(m::SoilSnowModel)\n\nThe domain names of the additional auxiliary variables that are included in the integrated Soil-Snow model.\n\n\n\n\n\nlsm_aux_domain_names(m::LandModel)\n\nThe domain names of the additional auxiliary variables that are included in the land model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.infiltration_capacity","page":"Integrated Models","title":"ClimaLand.infiltration_capacity","text":"function infiltration_capacity(\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n)\n\nFunction which computes the infiltration capacity of the soil based on soil characteristics, moisture levels, and pond height.\n\nDefined such that positive means into soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.infiltration_at_point","page":"Integrated Models","title":"ClimaLand.infiltration_at_point","text":"infiltration_at_point(η::FT, i_c::FT, P::FT)\n\nReturns the infiltration given pond height η, infiltration capacity, and precipitation.\n\nThis is defined such that positive means into soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.PrognosticRunoff","page":"Integrated Models","title":"ClimaLand.PrognosticRunoff","text":"PrognosticRunoff <: Pond.AbstractSurfaceRunoff\n\nConcrete type of Pond.AbstractSurfaceRunoff for use in LSM models, where precipitation is passed in, but infiltration is computed prognostically.\n\nThis is paired with Soil.RunoffBC: both are used at the same time, ensuring the infiltration used for the boundary condition of soil is also used to compute the runoff for the surface water.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.RunoffBC","page":"Integrated Models","title":"ClimaLand.RunoffBC","text":"RunoffBC <: Soil.AbstractSoilBC\n\nConcrete type of Soil.AbstractSoilBC for use in LSM models, where precipitation is passed in, but infiltration is computed prognostically. This infiltration is then used to set an upper boundary condition for the soil.\n\nThis is paired with Pond.PrognosticRunoff: both are used at the same time, ensuring that the infiltration used for the boundary condition of soil is also used to compute the runoff for the surface water.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.RootExtraction","page":"Integrated Models","title":"ClimaLand.RootExtraction","text":"RootExtraction{FT} <: Soil.AbstractSoilSource{FT}\n\nConcrete type of Soil.AbstractSoilSource, used for dispatch in an LSM with both soil and plant hydraulic components.\n\nThis is paired with the source term Canopy.PrognosticSoil:both are used at the same time, ensuring that the water flux into the roots is extracted correctly from the soil; treated explicitly in all prognostic variables.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.PrognosticMet","page":"Integrated Models","title":"ClimaLand.PrognosticMet","text":"PrognosticMet <: AbstractSoilDriver\n\nA container which holds the soil parameters needed for running biogeochemistry model with the soil model.\n\nν: Soil porosity (m³ m⁻³)\nθ_a100: Air-filled porosity at soil water potential of -100 cm H₂O (~ 10 Pa)\nb: Absolute value of the slope of the line relating log(ψ) versus log(S) (unitless)\n\n\n\n\n\n","category":"type"},{"location":"generated/shared_utilities/timestepping/#Mixed-implicit-and-explicit-timestepping","page":"Intro to implicit/explicit timestepping","title":"Mixed implicit and explicit timestepping","text":"The goal of this tutorial is to describe how the timestepping of a ClimaLand model is carried out. We will use forward and backward Euler as a demonstration, but higher order methods are available in ClimaTimesteppers.","category":"section"},{"location":"generated/shared_utilities/timestepping/#Explicit-vs.-implicit-stepping","page":"Intro to implicit/explicit timestepping","title":"Explicit vs. implicit stepping","text":"Given a differential equation for a prognostic variable Y\n\nfracd Y dt = g(Y t) + h(Y t)\n\nan explicit (forward) Euler step would entail\n\nY(t+Delta t) = Y(t) + g(Y(t) t) + h(Y(t)t) times Delta t\n\nwhile an implicit (backward) Euler step would entail\n\nY(t+Delta t) = Y(t) + g(Y(t+Delta t) t) + h(Y(t+Delta t)t) times Delta t\n\nwhich reqires us to solve an implicit equation for  Y(t+ Δt). We usually do so using Newton's method, which requires the derivative of the entire right hand side with respect to the variable we are solving for, Y(t+ Δt). This is called the Jacobian.\n\nSometimes certain terms must be stepped implicit for numerical stability, while others are more slowly varying or stable. In this case, a mixed approach would be\n\nY(t+Delta t) = Y(t) + g(Y(t+Delta t) t) + h(Y(t)t) times Delta t\n\nassuming that h is the slow term, and g is the fast term. Note that solving this implicit equation for (Y(t+ Δt) with Newton's method would be similar to that of the fully implicit approach, but with an approximated Jacobian (neglecting ∂h/∂Y).\n\nIf our timestepping scheme involves evaluating all right-hand-side tendencies at the current (known) value of a prognostic variable, we refer to that prognostic variable as explicit. If any of the right-hand-side tendencies are evaluated at the next (unknown) value of the prognostic variable, we refer to it as implicit. In the latter case, the Jacobian would include a term like ∂ tendency/∂ variable, even if it is an approximate (not exact) form of the Jacobian.","category":"section"},{"location":"generated/shared_utilities/timestepping/#Implicit-and-explicit-prognostic-variables-of-the-land-model","page":"Intro to implicit/explicit timestepping","title":"Implicit and explicit prognostic variables of the land model","text":"We treat two prognostic variables of the soil model (ϑl, ρeint) and the canopy temperature implicitly, and the canopy water content, the soil ice content, and all prognostic variables of the snow model explicitly.","category":"section"},{"location":"generated/shared_utilities/timestepping/#Implicit-vs-explicit-tendencies-not-complete-as-of-4/23/25","page":"Intro to implicit/explicit timestepping","title":"Implicit vs explicit tendencies - not complete as of 4/23/25","text":"Implicit:\n\nVertical contribution of the divergence of the Darcy flux\nVertical contribution of the divergence of diffusive heat flux\nVertical contribution of the divergence of heat flux due to Darcy flow\nCanopy temperature (except root extraction of energy)\nSHF, LHF, evaporation, and sublimation of soil (note that these are explicit in θ_i!)\nSoil radiation (does not contribute to Jacobian)\nSubsurface runoff (this is computed in the same function the same time as surface runoff, but does not contribute to Jacobian.)\n\nExplicit\n\nPhase changes in soil\nRoot extraction\nall snow tendencies\nDarcy flux within the canopy\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/#Farquhar-Model","page":"Farquhar model","title":"Farquhar Model","text":"This section breaks down the Farquhar model that describes the biochemical process of photosynthesis in plants as environmental conditions change.\n\nThe biochemical processes within a leaf determine the rate of photosynthesis, particularly the diffusion of CO_2 into the leaf, the assimilation of CO_2 during photosynthesis, and the transpiration of water vapor. It takes into account factors such as light intensity, temperature, and CO_2 concentration to estimate the rate at which plants convert light energy into chemical energy through photosynthesis.\n\nThe net assimilation by a leaf (An) is calculated based on the biochemistry of C3 and C4 photosynthesis to determine potential (unstressed by water availability) leaf-level photosynthesis. This is calculated in terms of two potentially-limiting rates: the Rubisco-limited rate and light-limited rate.","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/#Rubisco-limited-rate","page":"Farquhar model","title":"Rubisco limited rate","text":"beginequation\na_1(T c_a VPD) =\nbegincases\n      V_cmax(T)  frac(c_i(T c_a VPD) - Gamma^*(T))(c_i(T c_a VPD) + K_c(T)*(1+o_iK_o(T)))  textfor C3\n      V_cmax(T)  textfor C4\nendcases\nendequation\n\nThe dependence on the atmospheric CO_2 concentration c_a (mol/mol) and vapor pressure deficit VPD arise in the expression for c_i,\n\nbeginalign\n    c_i(T c_a VPD) = max(c_a(1-1m(VPD)) Gamma^*(T))\nendalign\n\nwhere and m is the Medlyn factor (see Stomatal Conductance).\n\nWe also have\n\n    Gamma^*(T) = Gamma^*_25expleft(Delta H_Gamma^*fracT - T_oT_o R Tright)\n\nwhere Delta H_Gamma^* is the activation energy per mol for Gamma^*.","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/#Light-limited-rate","page":"Farquhar model","title":"Light limited rate","text":"beginequation\na_2 =\nbegincases\n      J(T PAR) (c_i - Gamma^*)4(c_i + 2  Gamma^*)  textfor C3\n      J(T PAR)  textfor C4\nendcases\nendequation\n\nwhere J is the rate of electron transport, which has units of mol photon per m^2 per s. It depends on PAR via APAR, as described below, and on T via the dependence on J_max.\n\nJ is given by the root of the equation\n\nbeginalign\n    theta_j J^2 - (I + J_max) J + I J_max = 0 nonumber \n    I = fracphi2 (APAR) nonumber \n    J_max(T) = V_cmax(T)times e expleft(Delta H_J_maxfracT - T_oT_o R Tright)nonumber \nJ(T PAR) = frac(I + J_max - sqrt(I + J_max)^2 - 4theta_j I times J_max2theta_j\nendalign\n\nwhere phi = 06 and theta_j = 09 are the quantum yield of photosystem II and a curvature function (Bonan's book), and Delta H_J_max is the energy of activation of J_max.\n\nThe total net carbon assimilation (A_n, mol CO_2 m^-2 s^-1) is given by the weighted sum of C3 and C4 net carbon assimilation fractions following:\n\nbeginalign\nA_n(T PAR VPD c_a) = textmax(0 textmin(a_1 beta a_2) - R_d)\nendalign\n\nwhere beta is the moisture stress factor which is related to the mean soil moisture concentration in the root zone and R_d is the leaf dark respiration calculated as\n\nbeginalign\n    R_d25(psi_l) = f V_cmax25beta(psi_l) nonumber \n    R_d (T psi_l)  = R_d25(psi_l)expleft(Delta H_R_dfracT - T_oT_o R Tright)\nendalign\n\nwhere f = 0015 is a constant, Delta H_R_d is the energy of activation for R_d, and finally Vcmax is calculated as\n\nbeginequation\nV_cmax(T) = V_cmax25 expleft(Delta H_VcmaxfracT - T_oT_o R Tright)\nendequation\n\nwith V_cmax25 is a parameter (Vcmax at the reference temperature 25 C), and Delta H_Vcmax = 65330 Jmol.\n\nThe moisture stress factor is related to the leaf water potential psi_l as\n\nbeginalign\n    beta = frac1+ exp(s_c psi_c)1+ exp(s_c(psi_c - psi_l))\nendalign\n\nwhere s_c = 4MPa^-1, psi_c = -2MPa, and psi_l is the leaf water potential computed by the plant hydraulics model.\n\nGPP is the total canopy photosynthesis calculated as the integral of leaf-level photosynthesis over the entire canopy leaf area index:\n\nbeginalign\nGPP(T PAR c_a VPD theta_s) = A_n  (1 - exp(-K LAI Omega))K\nendalign\n\nThis is not currently needed by other components, but is used for offline validation of the model.\n\nWe need to supply the following parameters and “drivers\"\n\nK_c25 and K_o25, V_cmax 25, Gamma^*_25phi, theta_j, o_i, s_c, psi_c\npsi_l, to compute beta\nTemperature T, PAR, c_a, VPD, theta_s.\n\nOutput Symbol Unit Range\nTotal net carbon assimilation A_n μmol CO_2 m^-2 s^-1 0–25\n\nDrivers Symbol Unit Range\nPhotosynthetically Active Radiation PAR μmol m⁻² s⁻¹ 0–1500\nTemperature T °C 0–50\n\nParameters Symbol Unit Range\nMoisture stress β - 0-1\nLeaf Area Index LAI m² m⁻² 1–10\nCO_2 concentration c_a ppm 300e–500\nVapor pressure deficit VPD kPa 1-10\n\nConstants Symbol Unit Value\nZenith angle θ_s rad 0.6\nLeaf angle distribution l_d - 0.5\nCanopy reflectance ρ_leaf - 0.1\nClumping index Ω - 0.69\nCO_2 compensation at 25°C Γ^*_25 mol/mol 4.275e-5\nEnergy of activation for Γ^* ΔH_Γ^* J/mol 37830\nStandard temperature T_o K 298.15\nUniversal gas constant R J/mol 8.314\nThe maximum rate of carboxylation of Rubisco V_cmax25 mol CO_2 m^-2 s^-1 5e-5\nEnergy of activation for J_max ΔH_J_max J/mol 43540\nCurvature parameter, a fitting constant to compute J θ_j - 0.9\nThe quantum yied of photosystem II phi - 0.6\nEnergy of activation for V_cmax ΔH_V_cmax J/mol 58520\nSlope parameter for stomatal conductance models g_1 - 141\nMichaelis Menten constant for CO_2 and at 25\u000e°C K_c25 mol/mol 4.049e-4\nEnergy of activation for CO_2 ΔH_K_c J/mol 79430\nMichaelis Menten constant for O_2 at 25 °C\u000e K_o25 mmol/mol 0.2874\nEnergy of activation for O_2 ΔH_K_o J/mol 36380\nIntercellular O_2 concentration o_i mol/mol 0.209\nConstant factor appearing the dark respiration term\u000e f - 0.015\nEnergy of activation for R_d ΔH_R_d J/mol 43390","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Perfect-Model-Site-Level-Calibration-Tutorial","page":"Single site perfect model","title":"Perfect Model Site-Level Calibration Tutorial","text":"This tutorial demonstrates how to perform a perfect model calibration experiment using ClimaLand. In a perfect model experiment, we generate synthetic observations from our model with known parameters, then use ensemble Kalman inversion to recover those parameters. This approach allows us to evaluate the calibration method without the influence of model structural errors.\n\nIn this tutorial we will calibrate the Vcmax25 parameter using latent heat flux observations from the FLUXNET site (US-MOz).","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Overview","page":"Single site perfect model","title":"Overview","text":"The tutorial covers:\n\nSetting up a land surface model for a FLUXNET site (US-MOz)\nCreating a synthetic observation dataset\nImplementing Ensemble Kalman Inversion\nAnalyzing the calibration results","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Setup-and-Imports","page":"Single site perfect model","title":"Setup and Imports","text":"Load all the necessary packages for land surface modeling, diagnostics, plotting, and ensemble methods:\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Canopy\nusing ClimaLand.Simulations\nimport ClimaLand.FluxnetSimulations as FluxnetSimulations\nimport ClimaLand.Parameters as LP\nimport ClimaLand.LandSimVis as LandSimVis\nimport ClimaDiagnostics\nimport EnsembleKalmanProcesses as EKP\nimport EnsembleKalmanProcesses.ParameterDistributions as PD\nusing CairoMakie\nCairoMakie.activate!()\nusing Statistics\nusing Logging\nimport Random\nusing Dates\nusing ClimaAnalysis, GeoMakie, Printf, StatsBase","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Configuration-and-Site-Setup","page":"Single site perfect model","title":"Configuration and Site Setup","text":"Configure the experiment parameters and set up the FLUXNET site (US-MOz) with its specific location, time settings, and atmospheric conditions.\n\nSet random seed for reproducibility and floating point precision\n\nrng_seed = 1234\nrng = Random.MersenneTwister(rng_seed)\nconst FT = Float32\n\nFloat32\n\nInitialize land parameters and site configuration.\n\ntoml_dict = LP.create_toml_dict(FT)\nsite_ID = \"US-MOz\"\nsite_ID_val = FluxnetSimulations.replace_hyphen(site_ID)\n\n:US_MOz\n\nGet site-specific information: location coordinates, time offset, and sensor height.\n\n(; time_offset, lat, long) =\n    FluxnetSimulations.get_location(FT, Val(site_ID_val))\n(; atmos_h) = FluxnetSimulations.get_fluxtower_height(FT, Val(site_ID_val))\n\n(atmos_h = 32.0f0,)\n\nGet maximum simulation start and end dates\n\n(start_date, stop_date) =\n    FluxnetSimulations.get_data_dates(site_ID, time_offset)\nstop_date = DateTime(2010, 4, 1, 6, 30)  # Set the stop date manually\nΔt = 450.0  # seconds\n\n450.0","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Domain-and-Forcing-Setup","page":"Single site perfect model","title":"Domain and Forcing Setup","text":"Create the computational domain and load the necessary forcing data for the land surface model.\n\nCreate a column domain representing a 2-meter deep soil column with 10 vertical layers.\n\nzmin = FT(-2)  # 2m depth\nzmax = FT(0)   # surface\ndomain = Column(; zlim = (zmin, zmax), nelements = 10, longlat = (long, lat));\n\nLoad prescribed atmospheric and radiative forcing from FLUXNET data\n\nforcing = FluxnetSimulations.prescribed_forcing_fluxnet(\n    site_ID,\n    lat,\n    long,\n    time_offset,\n    atmos_h,\n    start_date,\n    toml_dict,\n    FT,\n);\n\nGet Leaf Area Index (LAI) data from MODIS satellite observations.\n\nLAI = ClimaLand.Canopy.prescribed_lai_modis(\n    domain.space.surface,\n    start_date,\n    stop_date,\n);","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Model-Setup","page":"Single site perfect model","title":"Model Setup","text":"Create an integrated land model that couples canopy, snow, soil, and soil CO2 components. This comprehensive model allows us to simulate the full land surface system and its interactions.\n\nfunction model(Vcmax25)\n    Vcmax25 = FT(Vcmax25)\n\n    #md # Set up ground conditions and define which components to simulate prognostically\n    ground = ClimaLand.PrognosticGroundConditions{FT}()\n    prognostic_land_components = (:canopy, :snow, :soil, :soilco2)\n\n    #md # Prepare canopy domain and forcing\n    canopy_domain = ClimaLand.Domains.obtain_surface_domain(domain)\n    canopy_forcing = (; forcing.atmos, forcing.radiation, ground)\n\n    #md # Set up photosynthesis parameters using the Farquhar model\n    photosyn_defaults =\n        Canopy.clm_photosynthesis_parameters(canopy_domain.space.surface)\n    photosynthesis = Canopy.FarquharModel{FT}(\n        canopy_domain,\n        toml_dict;\n        photosynthesis_parameters = (;\n            is_c3 = photosyn_defaults.is_c3,\n            Vcmax25,\n        ),\n    )\n\n    conductance = Canopy.MedlynConductanceModel{FT}(\n        canopy_domain,\n        toml_dict;\n        g1 = FT(141),\n    )\n\n    #md # Create canopy model\n    canopy = ClimaLand.Canopy.CanopyModel{FT}(\n        canopy_domain,\n        canopy_forcing,\n        LAI,\n        toml_dict;\n        photosynthesis,\n        prognostic_land_components,\n        conductance,\n    )\n\n    #md # Create integrated land model\n    land_model = LandModel{FT}(\n        forcing,\n        LAI,\n        toml_dict,\n        domain,\n        Δt;\n        prognostic_land_components,\n        canopy,\n    )\n\n    #md # Set initial conditions from FLUXNET data\n    set_ic! = FluxnetSimulations.make_set_fluxnet_initial_conditions(\n        site_ID,\n        start_date,\n        time_offset,\n        land_model,\n    )\n\n    #md # Configure diagnostics to output sensible and latent heat fluxes hourly\n    output_vars = [\"shf\", \"lhf\"]\n    diagnostics = ClimaLand.default_diagnostics(\n        land_model,\n        start_date;\n        output_writer = ClimaDiagnostics.Writers.DictWriter(),\n        output_vars,\n        reduction_period = :hourly,\n    )\n\n    #md # Create and run the simulation\n    simulation = Simulations.LandSimulation(\n        start_date,\n        stop_date,\n        Δt,\n        land_model;\n        set_ic!,\n        user_callbacks = (),\n        diagnostics,\n    )\n    solve!(simulation)\n    return simulation\nend\n\nmodel (generic function with 1 method)","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Observation-and-Helper-Functions","page":"Single site perfect model","title":"Observation and Helper Functions","text":"Define the observation function G that maps from parameter space to observation space, along with supporting functions for data processing:\n\nThis function runs the model and computes diurnal average of latent heat flux\n\nfunction G(Vcmax25)\n    simulation = model(Vcmax25)\n    lhf = get_lhf(simulation)\n    observation =\n        Float64.(\n            get_diurnal_average(\n                lhf,\n                simulation.start_date,\n                simulation.start_date + Day(20),\n            ),\n        )\n    return observation\nend\n\nG (generic function with 1 method)\n\nHelper function: Extract latent heat flux from simulation diagnostics\n\nfunction get_lhf(simulation)\n    return ClimaLand.Diagnostics.diagnostic_as_vectors(\n        simulation.diagnostics[1].output_writer,\n        \"lhf_1h_average\",\n    )\nend\n\nget_lhf (generic function with 1 method)\n\nHelper function: Compute diurnal average of a variable\n\nfunction get_diurnal_average(var, start_date, spinup_date)\n    (times, data) = var\n    model_dates = if times isa Vector{DateTime}\n        times\n    else\n        Second.(getproperty.(times, :counter)) .+ start_date\n    end\n    spinup_idx = findfirst(spinup_date .<= model_dates)\n    model_dates = model_dates[spinup_idx:end]\n    data = data[spinup_idx:end]\n\n    hour_of_day = Hour.(model_dates)\n    mean_by_hour = [mean(data[hour_of_day .== Hour(i)]) for i in 0:23]\n    return mean_by_hour\nend\n\nget_diurnal_average (generic function with 1 method)","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Perfect-Model-Experiment-Setup","page":"Single site perfect model","title":"Perfect Model Experiment Setup","text":"Since this is a perfect model experiment, we generate synthetic observations from our target parameter value. This parameter will be recovered by the calibration.\n\ntrue_Vcmax25 = 0.0001 # [mol m-2 s-1]\nobservations = G(true_Vcmax25)\n\n24-element Vector{Float64}:\n 56.713233947753906\n 11.674813270568848\n  4.847160339355469\n  2.7448718547821045\n 12.527281761169434\n  5.648604869842529\n  3.1952598094940186\n  8.335795402526855\n  4.898887634277344\n  3.3732948303222656\n  6.51943826675415\n  4.313386917114258\n  3.0983338356018066\n  3.657754898071289\n  2.672222852706909\n  1.9511597156524658\n 27.80724334716797\n 30.942798614501953\n 32.04627990722656\n 54.01344299316406\n 57.48904037475586\n 65.11799621582031\n 53.44475555419922\n 54.17094802856445\n\nDefine observation noise covariance for the ensemble Kalman process. A flat covariance matrix is used here for simplicity.\n\nnoise_covariance = 0.05 * EKP.I\n\nLinearAlgebra.UniformScaling{Float64}\n0.05*I","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Prior-Distribution-and-Calibration-Configuration","page":"Single site perfect model","title":"Prior Distribution and Calibration Configuration","text":"Set up the prior distribution for the parameter and configure the ensemble Kalman inversion:\n\nConstrained Gaussian prior for Vcmax25 with bounds [0, 2e-3]\n\nprior = PD.constrained_gaussian(\"Vcmax25\", 1e-3, 5e-4, 0, 2e-3)\n\nParameterDistribution with 1 entries: \n'Vcmax25' with EnsembleKalmanProcesses.ParameterDistributions.Constraint{EnsembleKalmanProcesses.ParameterDistributions.Bounded}[Bounds: (0, 0.002)] over distribution EnsembleKalmanProcesses.ParameterDistributions.Parameterized(Distributions.Normal{Float64}(μ=0.0, σ=1.0253151205244289)) \n\n\nSet the ensemble size and number of iterations\n\nensemble_size = 10\nN_iterations = 3\n\n3","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Ensemble-Kalman-Inversion","page":"Single site perfect model","title":"Ensemble Kalman Inversion","text":"Initialize and run the ensemble Kalman process:\n\nSample the initial parameter ensemble from the prior distribution\n\ninitial_ensemble = EKP.construct_initial_ensemble(rng, prior, ensemble_size)\n\nensemble_kalman_process = EKP.EnsembleKalmanProcess(\n    initial_ensemble,\n    observations,\n    noise_covariance,\n    EKP.Inversion();\n    scheduler = EKP.DataMisfitController(\n        terminate_at = Inf,\n        on_terminate = \"continue\",\n    ),\n    rng,\n)\n\nEnsembleKalmanProcesses.EnsembleKalmanProcess{Float64, Int64, EnsembleKalmanProcesses.Inversion{Float64, Nothing, Nothing}, EnsembleKalmanProcesses.DataMisfitController{Float64, String}, EnsembleKalmanProcesses.NesterovAccelerator{Float64}, Vector{EnsembleKalmanProcesses.UpdateGroup}, Nothing}(EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}[EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}([-0.8325050664413828 2.6271025325751536 0.10590647419812717 -0.21741942508155152 2.620949938138978 0.01075406465127927 -0.7174310248175343 -0.8539057666932345 -1.4948703507073922 -0.8871392387754122])], EnsembleKalmanProcesses.ObservationSeries{Vector{EnsembleKalmanProcesses.Observation{Vector{Vector{Float64}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{String}, Vector{UnitRange{Int64}}, Nothing}}, EnsembleKalmanProcesses.FixedMinibatcher{Vector{Vector{Int64}}, String, Random.TaskLocalRNG}, Vector{String}, Vector{Vector{Vector{Int64}}}, Nothing}(EnsembleKalmanProcesses.Observation{Vector{Vector{Float64}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{String}, Vector{UnitRange{Int64}}, Nothing}[EnsembleKalmanProcesses.Observation{Vector{Vector{Float64}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, Vector{String}, Vector{UnitRange{Int64}}, Nothing}([[56.713233947753906, 11.674813270568848, 4.847160339355469, 2.7448718547821045, 12.527281761169434, 5.648604869842529, 3.1952598094940186, 8.335795402526855, 4.898887634277344, 3.3732948303222656, 6.51943826675415, 4.313386917114258, 3.0983338356018066, 3.657754898071289, 2.672222852706909, 1.9511597156524658, 27.80724334716797, 30.942798614501953, 32.04627990722656, 54.01344299316406, 57.48904037475586, 65.11799621582031, 53.44475555419922, 54.17094802856445]], LinearAlgebra.Diagonal{Float64, Vector{Float64}}[[0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05]], LinearAlgebra.Diagonal{Float64, Vector{Float64}}[[20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 20.0]], [\"observation\"], UnitRange{Int64}[1:24], nothing)], EnsembleKalmanProcesses.FixedMinibatcher{Vector{Vector{Int64}}, String, Random.TaskLocalRNG}([[1]], \"order\", Random.TaskLocalRNG()), [\"series_1\"], Dict(\"minibatch\" => 1, \"epoch\" => 1), [[[1]]], nothing), 10, EnsembleKalmanProcesses.DataContainers.DataContainer{Float64}[], Dict{String, Vector{Float64}}(), EnsembleKalmanProcesses.DataMisfitController{Float64, String}(Int64[], Inf, \"continue\"), EnsembleKalmanProcesses.NesterovAccelerator{Float64}([-0.8325050664413828 2.6271025325751536 0.10590647419812717 -0.21741942508155152 2.620949938138978 0.01075406465127927 -0.7174310248175343 -0.8539057666932345 -1.4948703507073922 -0.8871392387754122], 1.0), Float64[], EnsembleKalmanProcesses.UpdateGroup[EnsembleKalmanProcesses.UpdateGroup([1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], Dict(\"[1,...,1]\" => \"[1,...,24]\"))], EnsembleKalmanProcesses.Inversion{Float64, Nothing, Nothing}(nothing, nothing, false, 0.0), Random.MersenneTwister(1234, (0, 1002, 0, 11)), EnsembleKalmanProcesses.FailureHandler{EnsembleKalmanProcesses.Inversion, EnsembleKalmanProcesses.SampleSuccGauss}(EnsembleKalmanProcesses.var\"#failsafe_update#174\"()), EnsembleKalmanProcesses.Localizers.Localizer{EnsembleKalmanProcesses.Localizers.SECNice, Float64}(EnsembleKalmanProcesses.Localizers.var\"#13#14\"{EnsembleKalmanProcesses.Localizers.SECNice{Float64}}(EnsembleKalmanProcesses.Localizers.SECNice{Float64}(1000, 1.0, 1.0))), 0.1, nothing, false)\n\nRun the ensemble of forward models to iteratively update the parameter ensemble\n\nLogging.with_logger(SimpleLogger(devnull, Logging.Error)) do\n    for i in 1:N_iterations\n        println(\"Iteration $i\")\n        params_i = EKP.get_ϕ_final(prior, ensemble_kalman_process)\n        G_ens = hcat([G(params_i[:, j]...) for j in 1:ensemble_size]...)\n        EKP.update_ensemble!(ensemble_kalman_process, G_ens)\n    end\nend\n\nIteration 1\nIteration 2\nIteration 3\n","category":"section"},{"location":"generated/calibration/perfect_model_site_level_calibration/#Results-Analysis-and-Visualization","page":"Single site perfect model","title":"Results Analysis and Visualization","text":"Get the mean of the final parameter ensemble:\n\nEKP.get_ϕ_mean_final(prior, ensemble_kalman_process)\n\n1-element Vector{Float64}:\n 0.0011516112499381562\n\nNow, let's analyze the calibration results by examining parameter evolution and comparing model outputs across iterations.\n\nPlot the parameter ensemble evolution over iterations to visualize convergence:\n\ndim_size = sum(length.(EKP.batch(prior)))\nfig = CairoMakie.Figure(size = ((dim_size + 1) * 500, 500))\n\nfor i in 1:dim_size\n    EKP.Visualize.plot_ϕ_over_iters(\n        fig[1, i],\n        ensemble_kalman_process,\n        prior,\n        i,\n    )\nend\n\nEKP.Visualize.plot_error_over_iters(\n    fig[1, dim_size + 1],\n    ensemble_kalman_process,\n)\nCairoMakie.save(\"perfect_model_constrained_params_and_error.png\", fig);\n\n(Image: )\n\nCompare the model output between the first and last iterations to assess improvement:\n\nfig = CairoMakie.Figure(size = (900, 400))\n\nfirst_G_ensemble = EKP.get_g(ensemble_kalman_process, 1)\nlast_iter = EKP.get_N_iterations(ensemble_kalman_process)\nlast_G_ensemble = EKP.get_g(ensemble_kalman_process, last_iter)\nn_ens = EKP.get_N_ens(ensemble_kalman_process)\n\nax = Axis(\n    fig[1, 1];\n    title = \"G ensemble: first vs last iteration (n = $(n_ens), iters 1 vs $(last_iter))\",\n    xlabel = \"Observation index\",\n    ylabel = \"G\",\n)\n\nAxis with 0 plots:\n\n\nPlot model output of first vs last iteration ensemble\n\nfor g in eachcol(first_G_ensemble)\n    lines!(ax, 1:length(g), g; color = (:red, 0.6), linewidth = 1.5)\nend\n\nfor g in eachcol(last_G_ensemble)\n    lines!(ax, 1:length(g), g; color = (:blue, 0.6), linewidth = 1.5)\nend\n\nlines!(\n    ax,\n    1:length(observations),\n    observations;\n    color = (:black, 0.6),\n    linewidth = 3,\n)\n\naxislegend(\n    ax,\n    [\n        LineElement(color = :red, linewidth = 2),\n        LineElement(color = :blue, linewidth = 2),\n        LineElement(color = :black, linewidth = 4),\n    ],\n    [\"First ensemble\", \"Last ensemble\", \"Observations\"];\n    position = :rb,\n    framevisible = false,\n)\n\nCairoMakie.resize_to_layout!(fig)\nCairoMakie.save(\"perfect_model_G_first_and_last.png\", fig);\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"diagnostics/users_diagnostics/#Using-ClimaLand-Diagnostics-to-save-simulation-output","page":"For users","title":"Using ClimaLand Diagnostics to save simulation output","text":"When running a ClimaLand simulations, you have multiple options on how to write the outputs of that simulation. You may want all variables, or just a selected few. You may want instantaneous values, at the highest temporal and spatial resolution, or you may want to get averages at hourly or monthly time scale, and integrate in space (for example soil moisture from 0 to 1 meter depth). You may want to get more specific reductions, such as 10 days maximums, or compute a new variables as a function of others. You may want to get your outputs in memory in a Julia dictionary, or write them in a NetCDF file.\n\nThis is where ClimaLand Diagnostics comes in for users.\n\nIn this documentation page, we first explain how to use default diagnostics and what are the defaults, and then explain how to define your own diagnostics for more advanced users.","category":"section"},{"location":"diagnostics/users_diagnostics/#Default-Diagnostics","page":"For users","title":"Default Diagnostics","text":"Diagnostics refer to output saved during the simulation, which may be prognostic or diagnostic variables. Note that this is different from checkpointing the simulation, which has specific requirements. For information about checkpointing and restarting simulations, please see the page titled Restarting Simulations.\n\nThe main user-facing function in the ClimaLand.Diagnostics module is default_diagnostics. This function defines what diagnostic variables to compute by default for a specific model, and on what schedule (for example, hourly average).\n\ndefault_diagnostics takes in the following arguments:\n\nmodel: The ClimaLand model to generate diagnostics for. Currently the following models support diagnostics: CanopyModel, EnergyHydrologyModel, SoilCanopyModel, LandModel, BucketModel\nstart_date: The start date of the simulation.\noutput_writer: An object of type ClimaDiagnostics.AbstractWriter. Specifically this may be a NetCDFWriter, HDF5Writer, or DictWriter, which save output to a NetCDF file, HDF5 file, or dictionary in Julia memory, respectively. For more details about the diagnostics writers, please see the ClimaDiagnostics.jl documentation.\noutput_vars: This argument may be :short to output a default list of variables defined for each model, :long to output all\n\navailable variables for the model, or a user-defined list of variable \"short names\".\n\nreduction_period: How often to compute and save the provided temporal reduction of the diagnostics.\nreduction_type: A temporal reduction to apply to the diagnostics over each provided time period, e.g. :average, :max, :min, :instantaneous (no reduction)\ndt: Simulation timestep; only required for instantaneous diagnostics.","category":"section"},{"location":"diagnostics/users_diagnostics/#Example:-diagnostics-for-a-CanopyModel","page":"For users","title":"Example: diagnostics for a CanopyModel","text":"The following code sets up default short diagnostics to be averaged hourly and written in memory as a Julia dictionary:\n\ndiag_writer = ClimaDiagnostics.Writers.DictWriter();\ndiagnostics = ClimaLand.Diagnostics.default_diagnostics(\n    canopy,\n    start_date;\n    output_vars = :short,\n    output_writer = diag_writer,\n    reduction_period = :hourly,\n    reduction_type = :average,\n);\n\nTo instead output a list of specific diagnostics, you can change the value of output_vars. For example, to output gross primary productivity (GPP) and transpiration you would do the following:\n\ndiag_writer = ClimaDiagnostics.Writers.DictWriter();\ndiagnostics = ClimaLand.Diagnostics.default_diagnostics(\n    canopy,\n    start_date;\n    output_vars = [\"gpp\", \"trans\"],\n    output_writer = diag_writer,\n    reduction_period = :hourly,\n    reduction_type = :average,\n);\n\nA description of available diagnostics and their short names can be found on the Available diagnostic variables documentation page.\n\nTo write the diagnostics to a NetCDF file instead of saving it in memory, the diag_writer should be constructed as a NetCDFWriter and then passed to default_diagnostics as before:\n\noutdir = \"my_output_dir\"\nnc_writer =\n    ClimaDiagnostics.Writers.NetCDFWriter(space, outdir; start_date)\n\nnote: Note\nThe NetCDFWriter currently writes to file for each diagnostic output, which can be quite slow when saving variables at every step. On the other hand, the DictWriter saves output to memory which may be too large in global runs, so DictWriter usually should not be used for global runs. In general, we recommend using DictWriter for column simulations, and NetCDFWriter for global simulations.","category":"section"},{"location":"diagnostics/users_diagnostics/#Diagnostics-output-naming-and-format","page":"For users","title":"Diagnostics output naming and format","text":"Diagnostics are typically named using the format $(short_name)_$(period)_$(reduction). For example, with the NetCDFWriter, hourly-averaged GPP would be saved in an output file titled gpp_1h_average.nc.\n\nThe specific output format depends on which output writer is being used; for more details, please see the ClimaDiagnostics documentation.","category":"section"},{"location":"diagnostics/users_diagnostics/#Adding-new-diagnostics","page":"For users","title":"Adding new diagnostics","text":"To define a new, custom diagnostic, you must follow these steps:\n\nspecify how to compute the diagnostic\nmanually define the diagnostic via add_diagnostic_variable!\nadd the diagnostic to the list of possible diagnostics for the relevant model(s)","category":"section"},{"location":"diagnostics/users_diagnostics/#Define-how-to-compute-your-diagnostic-variable-from-your-model-state-and-cache.","page":"For users","title":"Define how to compute your diagnostic variable from your model state and cache.","text":"These functions are defined in src/diagnostics/land_compute_methods.jl and must be named in the format compute_[standard_name]!. Be sure to write method(s) for each model you want this diagnostic to be available for. For example, let's say you want the bowen ratio (ratio between sensible heat and latent heat) in the Bucket model.\n\nfunction compute_bowen_ratio!(out, Y, p, t, land_model::BucketModel)\n    if isnothing(out)\n        return copy(p.bucket.turbulent_fluxes.shf / p.bucket.turbulent_fluxes.lhf)\n    else\n        out .= p.bucket.turbulent_fluxes.shf / p.bucket.turbulent_fluxes.lhf\n    end\nend\n\nOr, for convenience, you can use the @diagnostic_compute macro which generates the same function. However, it is better to use that macro only if you are retrieving an existing variable, such as latent heat flux, rather than computing one, like the Bowen ratio above. For example,\n\n@diagnostic_compute \"latent_heat_flux\" BucketModel p.bucket.turbulent_fluxes.lhf","category":"section"},{"location":"diagnostics/users_diagnostics/#Add-that-diagnostic(s)-variable-to-your-list-of-variables","page":"For users","title":"Add that diagnostic(s) variable to your list of variables","text":"These functions are defined in src/diagnostics/define_diagnostics.jl.\n\n add_diagnostic_variable!(\n    short_name = \"bor\",\n    long_name = \"Bowen ratio\",\n    standard_name = \"bowen_ratio\",\n    units = \"\",\n    comments = \"Ratio of sensible to latent heat flux.\",\n    compute! = (out, Y, p, t) -> compute_bowen_ratio!(out, Y, p, t, land_model),\n)\n\nadd_diagnostic_variable!(\n    short_name = \"lhf\",\n    long_name = \"Latent Heat Flux\",\n    standard_name = \"latent_heat_flux\",\n    units = \"W m^-2\",\n    comments = \"Exchange of energy at the land-atmosphere interface due to water evaporation or sublimation.\",\n    compute! = (out, Y, p, t) ->\n    compute_latent_heat_flux!(out, Y, p, t, land_model),\n)","category":"section"},{"location":"diagnostics/users_diagnostics/#Define-how-often-to-output-your-variables,-and-how-to-combine-them.","page":"For users","title":"Define how often to output your variables, and how to combine them.","text":"We support a range of reduction periods and reduction types, defined in src/diagnostics/default_diagnostics.jl, which should be passed to default_diagnostics as Symbols. Currently, the following periods are supported:\n\n:every_dt (requires dt to be provided separately)\n:halfhourly\n:hourly\n:daily\n:tendaily\n:monthly\n\nAnd the following reduction types are supported:\n\n:instantaneous\n:average (requires pre_output_hook! = average_pre_output_hook! when creating the ScheduledDiagnostic)\n:max\n:min\n\nYou can also define your own output frequencies and reductions. For example, if you want the seasonal maximum of your variables, where season is defined as 90 days, you could add the following get_period function, and then provide this new reduction period to default_diagnostics.\n\nget_period(:seasonal) = Day(90)\ndefault_diagnostics(model, start_date, output_writer; output_vars, reduction_period = :seasonal, reduction_type = :max)","category":"section"},{"location":"diagnostics/users_diagnostics/#Analyze-your-simulation-output","page":"For users","title":"Analyze your simulation output","text":"Once you've run your simulation and created an output folder (e.g., output_dir) with diagnostics, you can use ClimaAnalysis to access and analyze your data. For in depth documentation about ClimaAnalysis, see its documentation.\n\nHere is an example of how to plot a variable:\n\nimport ClimaAnalysis\n\nimport ClimaAnalysis.Visualize as viz\n\nimport CairoMakie # the plotting package used by ClimaAnalysis\n\nsimdir = ClimaAnalysis.SimDir(output_dir) # where output_dir is where you saved your diagnostics.\n\nvar = get(simdir; \"lhf\") # assuming lhf, latent_heat_flux used as an example above, is one of your diagnostics variables.\n\nfig = CairoMakie.Figure() # creates an empty figure object\n\nviz.plot!(fig, var) # creates an axis inside fig, and plot your var in it.\n\nCairoMakie.save(fig) # saves the figure in current working directory","category":"section"},{"location":"diagnostics/users_diagnostics/#API","page":"For users","title":"API","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/#ClimaLand.Diagnostics.default_diagnostics","page":"For users","title":"ClimaLand.Diagnostics.default_diagnostics","text":"default_diagnostics(model::Union{\n                        CanopyModel{FT},\n                        SoilCanopyModel{FT},\n                        LandModel{FT},\n                        BucketModel{FT},\n                    },\n                    start_date::DateTime,\n                    outdir;\n                    output_writer = default_output_writer(get_domain(model), start_date, outdir),\n                    output_vars = :short,\n                    reduction_period = :monthly,\n                    reduction_type = :average,\n                    dt = nothing)\n\nConstruct a list of ScheduledDiagnostics that outputs the given variables at the specified average period.\n\nThe input output_vars can have 3 values:\n\n:long - all diagnostics are output\n:short - a short list of diagnostics is output\n_::Vector{String} - a user-defined list of diagnostics is output\n\nIf a user-defined list is provided for output_vars, it must be a vector of strings that are valid short names of diagnostics for the model. Please see the method get_possible_diagnostics for the list of available diagnostics for each model.\n\nreduction_period specifies the frequency at which to average the diagnostics, and reduction_type specifies the type of reduction to apply. Please see the docstring of get_period for the list of available periods, and the docstring of get_reduction for the list of available reduction types.\n\nThis method can be extended for any model that extends get_possible_diagnostics and get_short_diagnostics. Note that EnergyHydrology has a specialized method that handles conservation diagnostics.\n\n\n\n\n\ndefault_diagnostics(\n    land_model::EnergyHydrology{FT},\n    start_date::DateTime,\n    outdir;\n    output_writer = default_output_writer(get_domain(model), start_date, outdir),\n    output_vars = :short,\n    reduction_period = :monthly,\n    reduction_type = :average,\n    conservation = false,\n    conservation_period = Day(10),\n    dt = nothing,\n) where {FT}\n\nDefine a method specific to the EnergyHydrology model so that we can handle conservation diagnostics specially.\n\nThe input output_vars can have 3 values:\n\n:long - all diagnostics are output\n:short - a short list of diagnostics is output\n_::Vector{String} - a user-defined list of diagnostics is output\n\nIf a user-defined list is provided for output_vars, it must be a vector of strings that are valid short names of diagnostics for the model.\n\nreduction_period specifies the frequency at which to average the diagnostics, and reduction_type specifies the type of reduction to apply. Please see the docstring of get_period for the list of available periods, and the docstring of get_reduction for the list of available reduction types.\n\nConservation diagnostics should not be provided as part of the output_vars argument, but rather included by providing conservation = true. Please see the method get_possible_diagnostics for the list of available diagnostics.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/users_diagnostics/#ClimaLand.Diagnostics.close_output_writers","page":"For users","title":"ClimaLand.Diagnostics.close_output_writers","text":"close_output_writers(diagnostics)\n\nClose the output writers in the diagnostics, an iterable of ClimaDiagnostics.ScheduledDiagnostic or nothing.\n\nThis function should be called at the end of every simulation.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/users_diagnostics/#ClimaLand.total_energy_per_area!","page":"For users","title":"ClimaLand.total_energy_per_area!","text":"ClimaLand.total_energy_per_area!(\n    surface_field,\n    model::EnergyHydrology,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total energy per unit ground area for the EnergyHydrology.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::SnowModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total energy per unit ground area for the SnowModel.\n\nThis has already accounted for the area fraction of snow in the definition of S.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::BucketModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total energy per unit ground area for the BucketModel.\n\nThe ground of the bucket model has temperature Y.bucket.T, with volumetric specific heat approximated with the parameter ρc_soil. Additional energy is present due to the latent heat of fusion of frozen water, in the form of snow. We also add in this energy (below). We do not model or account for the sensible energy of snow (ρ_snow T_snow), as this is much smaller.\n\n\n\n\n\ntotal_energy_per_area!(cache, model::AbstractModel, Y, p, t)\n\nA function which updates cache in place with the total energy per unit ground area for the model, computed from Y, p, and t.\n\n\n\n\n\ntotal_energy_per_area!(\n    surface_field,\n    land::AbstractLandModel,\n    Y,\n    p,\n    t,\n    sfc_cache,\n)\n\nA function which computes the total energy per unit area and updates surface_field in place, for the land model land, by calling the same function for the component models.\n\nThe sfc_cache field is available as scratch space.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::BigLeafEnergyModel,\n    Y,\n    p,\n    t,\n\n)\n\nA function which updates surface_field in place with the value of the big leaf model's energy.\n\nNote that this assumes that there is at most a single canopy and stem component, and that the area index for them refers to the integrated area index (in height) - not the value per layer.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::AbstractCanopyEnergyModel,\n    Y,\n    p,\n    t,\n\n)\n\nA default function which errors for generic energy models for the canopy.\n\nNote that we only support two models for canopy energy. The BigLeafEnergyModel has a special method for this, and the other has the temperature prescribed and does not conserve energy.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::CanopyModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total energy per unit ground area for the CanopyModel.\n\nThis acts by calling the method for the energy component of the canopy model.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/users_diagnostics/#ClimaLand.total_liq_water_vol_per_area!","page":"For users","title":"ClimaLand.total_liq_water_vol_per_area!","text":"ClimaLand.total_liq_water_vol_per_area!(\n    surface_field,\n    model::RichardsModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total liquid water volume per unit ground area for the RichardsModel.\n\n\n\n\n\nClimaLand.total_liq_water_vol_per_area!(\n    surface_field,\n    model::EnergyHydrology,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total liquid water volume per unit ground area for the EnergyHydrology.\n\nThe water in all phases is accounted for by converting ice volume to liquid water volume using the ratio of the density of ice to the density of water.\n\n\n\n\n\nClimaLand.total_liq_water_vol_per_area!(\n    surface_field,\n    model::SnowModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total liquid water volume per unit ground area for the SnowModel.\n\nThis has already accounted for the area fraction of snow in the definition of S; it also accounts for both liquid and frozen water present in the snow, as the snow water equivalent is already the total liquid water volume present in the snow if all the snow melted, per unit ground area.\n\n\n\n\n\nClimaLand.total_liq_water_vol_per_area!(\n    surface_field,\n    model::BucketModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total liquid water volume per unit ground area for the BucketModel, in [m³ m⁻²].\n\nThe total water contained in the bucket is the sum of the subsurface water storage W, the snow water equivalent σS and surface water content Ws.\n\n\n\n\n\ntotal_liq_water_vol_per_area!(cache, model::AbstractModel, Y, p, t)\n\nA function which updates cache in place with the total liquid water volume per unit ground area for the model, computed from Y, p, and t.\n\nWhile water mass is the fundamentally conserved quantity, soil modelling represents water by an equivalent water volume using the density of water and ice at standard temperature and pressure. Because of that, we report here the total volume of water present in a model (per unit area) that would arise if all the water was in liquid phase. This can be converted to a mass using the density of liquid water.\n\nThis includes the water in multiple phases. For example, if ice is present, the water volume is computed using ratio of the density of ice to the density of liquid water.\n\n\n\n\n\ntotal_liq_water_vol_per_area!(\n    surface_field,\n    land::AbstractLandModel,\n    Y,\n    p,\n    t,\n    sfc_cache,\n)\n\nA function which computes the total liquid water volume per unit area and updates surface_field in place, for the land model land, by calling the same function for the component models.\n\nThe sfc_cache field is available as scratch space.\n\n\n\n\n\nClimaLand.total_liq_water_vol_per_area!(\n    surface_field,\n    model::CanopyModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total liquid water volume per unit ground area for the CanopyModel.\n\nThis acts by calling the method for the PlantHydraulics component of the canopy model.\n\n\n\n\n\nClimaLand.total_liq_water_vol_per_area!(\n    surface_field,\n    model::PlantHydraulicsModel,\n    Y,\n    p,\n    t,\n\n)\n\nA function which updates surface_field in place with the value of the plant hydraulic models total water volume.\n\nNote that this is general for any number of canopy layers, but it assumes that the LAI and SAI given are per layer. This is distinct from the BigLeaf approach, in which the LAI and SAI refer to the integrated area index with heigh.\n\n\n\n\n\n","category":"function"},{"location":"generated/standalone/Soil/changing_soil_parameterizations/#Changing-Soil-Parameterizations","page":"Changing soil parameterizations","title":"Changing Soil Parameterizations","text":"In Getting Started, we ran a simple soil model simulation using all of the default parameterizations and parameters. ClimaLand provides multiple options for many parameterizations; in this tutorial, we will demonstrate how to create a soil model with a non-default soil model parameterization.\n\nSpecifically, we'll switch from using the default CLMTwoBandSoilAlbedo soil albedo parameterization to the ConstantTwoBandSoilAlbedo parameterization. In both cases, the soil albedo is defined in two bands (PAR and NIR), and can spatially vary or be set to scalar. In the more complex CLMTwoBandSoilAlbedo scheme, the soil albedo varies temporally due to a dependence on soil water content at the surface, via the effective saturation S(θ_sfc): α = α_wetS + α_dry(1-S) In contrast, the ConstantTwoBandSoilAlbedo parameterization does not vary with soil water content (or with time). The ConstantTwoBandSoilAlbedo parameterization is useful for cases where the soil albedo is known to be constant over time, such as in some idealized simulations or when using a fixed albedo value.\n\nCLM reference: Lawrence and Chase [17]\n\nFirst we import the necessary Julia packages:\n\nimport ClimaParams as CP\nusing ClimaLand\nusing ClimaLand.Domains\nusing ClimaLand.Soil\nimport ClimaLand.Parameters as LP\nusing Dates\n\nChoose a floating point precision, and get the parameter set, which holds constants used across CliMA models.\n\nFT = Float32\ntoml_dict = LP.create_toml_dict(FT);\n\nWe will run this simulation on a column domain with 1 meter depth, at a lat/lon location near Pasadena, California.\n\nzmax = FT(0)\nzmin = FT(-1.0)\nlonglat = FT.((-118.1, 34.1));\ndomain = Domains.Column(; zlim = (zmin, zmax), nelements = 10, longlat);\nsurface_space = domain.space.surface;\n\nWe choose the start and stop dates, which are required to setup the forcing, which in turn is required by the model.\n\nstart_date = DateTime(2008);\nstop_date = start_date + Second(60 * 60 * 72);\n\nThe soil model takes in 2 forcing objects, atmosphere and radiation, which we read in from ERA5 data.\n\natmos, radiation = ClimaLand.prescribed_forcing_era5(\n    start_date,\n    stop_date,\n    surface_space,\n    toml_dict,\n    FT;\n    use_lowres_forcing = true,\n);\n\nNow, we can create the EnergyHydrology model.\n\nFirst, let's set up the ConstantTwoBandSoilAlbedo parameterization. This parameterization requires the PAR and NIR albedo values, which can be scalars or fields that vary spatially. Here, we set them to constant values. Note that this constructor call is also overriding the default values for PAR_albedo and NIR_albedo, which are 0.2 and 0.4, respectively. To use the default values, we would simply call: albedo = Soil.ConstantTwoBandSoilAlbedo{FT}()\n\nalbedo = Soil.ConstantTwoBandSoilAlbedo{FT}(\n    PAR_albedo = FT(0.2),\n    NIR_albedo = FT(0.4),\n);\n\nNow we can create the EnergyHydrology model with the specified albedo parameterization passed as a keyword argument.\n\nmodel =\n    Soil.EnergyHydrology{FT}(domain, (; atmos, radiation), toml_dict; albedo);\n\nThat's it! Now that you have the model, you can create the simulation, solve it, and make your plots like you would for any other ClimaLand simulation.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/Simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"APIs/Simulations/#ClimaLand.Simulations.LandSimulation","page":"Simulations","title":"ClimaLand.Simulations.LandSimulation","text":"LandSimulation{\n    M <: ClimaLand.AbstractModel,\n    T <: ClimaTimeSteppers.DistributedODEAlgorithm,\n    UC,\n    DI,\n    RC,\n    CA <: SciMLBase.CallbackSet,\n    I <: SciMLBase.DEIntegrator,\n}\n\nthe ClimaLand LandSimulation struct, which specifies\n\nthe discrete set of equations to solve (defined by the model);\nthe timestepping algorithm;\nuser callbacks (passed as a tuple) to be executed at specific times in the simulations;\nthe diagnostics to output (optional).\n\nUser callbacks are optional: examples currently include callbacks that estimate the time to solution and SYPD of the simulation as it runs, checkpoint the state, or check the solution for NaNs. Others can be added here.\n\nDiagnostics are implemented as callbacks, and are also optional. However, a default is provided. diagnostics is expected to be a list of ClimaDiagnostics.ScheduledDiagnostics.\n\nFinally, the private field requiredcallbacks consists of callbacks that are required for the simulation to run correctly. Currently, this includes the callbacks which update the atmospheric forcing and update the LAI using prescribed data.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Simulations/#ClimaLand.Simulations.step!","page":"Simulations","title":"ClimaLand.Simulations.step!","text":"step!(landsim::LandSimulation)\n\nAdvances the land simulation landsim forward in time by one step, updating landsim in place.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Simulations/#ClimaLand.Simulations.solve!","page":"Simulations","title":"ClimaLand.Simulations.solve!","text":"solve!(landsim::LandSimulation)\n\nAdvances the land simulation landsim forward from the initial to final time, updating landsim in place.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Simulations/#ClimaLand.Simulations.make_set_initial_state_from_file","page":"Simulations","title":"ClimaLand.Simulations.make_set_initial_state_from_file","text":"make_set_initial_state_from_file(ic_path, land::LandModel{FT}; enforce_constraints=false) where {FT}\n\nReturns a function which takes (Y,p,t0,land) as arguments, and updates the state Y in place with initial conditions from ic_path, a netCDF file. Fields in the cache p are used as pre-allocated memory and are updated as well, but this does not mean that the cache state is consitent with Y and t entirely.\n\nCurrently only tested and used for global simulations, but the same returned function should work for column simulations.\n\nThe returned function is a closure for ic_path. It could also be for land, as many other ClimaLand functions are, but we wish to preserve the argument land in set_ic! for users who wish to define their own initial condition function, which may require parameters, etc, stored in land.\n\nIf enforce_constraints = true, we ensure the soil water content is between porosity and the residual value, and that the temperature is bounded to be within the extrema of the air temperature at the surface.\n\nIt is assumed that in CoupledAtmosphere simulations that p.drivers.T has  been updated already.\n\n\n\n\n\nmake_set_initial_state_from_file(ic_path, land::SoilCanopyModel{FT}; enforce_constraints = false) where {FT}\n\nReturns a function which takes (Y,p,t0,land) as arguments, and updates the state Y in place with initial conditions from ic_path, a netCDF file. Fields in the cache p are used as pre-allocated memory and are updated as well, but this does not mean that the cache state is consitent with Y and t entirely.\n\nCurrently only tested and used for global simulations, but the same returned function should work for column simulations.\n\nThe returned function is a closure for ic_path. It could also be for land, as many other ClimaLand functions are, but we wish to preserve the argument land in set_ic! for users who wish to define their own initial condition function, which may require parameters, etc, stored in land.\n\nIf enforce_constraints = true, we ensure the soil water content is between porosity and the residual value, and that the temperature is bounded to be within the extrema of the air temperature at the surface.\n\nIt is assumed that in CoupledAtmosphere simulations that p.drivers.T has  been updated already.\n\n\n\n\n\nmake_set_initial_state_from_file(ic_path, model::ClimaLand.Soil.EnergyHydrology{FT}; enforce_constraints = false) where {FT}\n\nReturns a function which takes (Y,p,t0,model) as arguments, and updates the state Y in place with initial conditions from ic_path, a netCDF file. Fields in the cache p are used as pre-allocated memory and are updated as well, but this does not mean that the cache state is consitent with Y and t entirely.\n\nCurrently only tested and used for global simulations, but the same returned function should work for column simulations.\n\nThe returned function is a closure for ic_path. It could also be for model, as many other ClimaLand functions are, but we wish to preserve the argument model in set_ic! for users who wish to define their own initial condition function, which may require parameters, etc, stored in model.\n\nIf enforce_constraints = true, we ensure the soil water content is between porosity and the residual value, and that the temperature is bounded to be within the extrema of the air temperature at the surface.\n\nIt is assumed that in CoupledAtmosphere simulations that p.drivers.T has  been updated already.\n\n\n\n\n\n","category":"function"},{"location":"generated/standalone/Soil/phase_change_analytic/#The-Stefan-problem","page":"The Stefan problem","title":"The Stefan problem","text":"Before reading this tutorial, we recommend that you look over the coupled energy and water tutorial. That tutorial showed how to solve the heat equation for soil volumetric internal energy ρe_int, simultaneously with Richards equation for volumetric liquid water fraction ϑ_l, assuming zero volumetric ice fraction θ_i for all time, everywhere in the domain. In this example, we add in a source term to the right hand side for both θ_i and ϑ_l which models freezing and thawing and conserves water mass during the process.\n\nTo facilitate comparison to an analytically tractable problem (the Stefan problem), we set K_sat of the soil to zero. Then the simplified equations we solve are\n\nfrac ρe_int t =    κ(θ_l θ_i ν ) T\n\nfrac  ϑ_l t =  -fracF_Tρ_l\n\nfrac  θ_i t = fracF_Tρ_i\n\nHere\n\nt is the time (s),\n\nz is the location in the vertical (m),\n\nρe_int is the volumetric internal energy of the soil (J/m^3),\n\nT is the temperature of the soil (K),\n\nκ is the thermal conductivity (W/m/K),\n\nϑ_l is the augmented volumetric liquid water fraction,\n\nθ_i is the volumetric ice fraction,\n\nν  denotes parameters relating to soil type, such as porosity, and\n\nF_T is the freeze-thaw term.","category":"section"},{"location":"generated/standalone/Soil/phase_change_analytic/#Import-necessary-modules","page":"The Stefan problem","title":"Import necessary modules","text":"import SciMLBase\nimport ClimaTimeSteppers as CTS\nusing DelimitedFiles\nusing CairoMakie\n\nusing ClimaCore\nimport ClimaParams as CP\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nimport ClimaLand.Simulations: LandSimulation, solve!\nusing ClimaLand.Soil\n\nimport ClimaLand\nimport ClimaLand.Parameters as LP\n\nPreliminary set-up\n\nChoose a floating point precision, and get the parameter set, which holds constants used across CliMA models:\n\nFT = Float32\ntoml_dict = LP.create_toml_dict(FT);\n\nSet the values of other parameters required by the model:\n\nν = FT(0.535)\nK_sat = FT(0) # m/s; analytic solution only exists when water cannot flow\nS_s = FT(1e-3) #inverse meters\nvg_n = FT(1.48)\nvg_α = FT(1.11) # inverse meters\nhydrology_cm = vanGenuchten{FT}(; α = vg_α, n = vg_n);\n\nθ_r = FT(0.05)\nν_ss_om = FT(0.2)\nν_ss_quartz = FT(0.2)\nν_ss_gravel = FT(0.0)\nparams = Soil.EnergyHydrologyParameters(\n    toml_dict;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm,\n    K_sat,\n    S_s,\n    θ_r,\n);\n\nChoose the domain and discretization:\n\nzmax = FT(0)\nzmin = FT(-3)\nnelems = 40\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\n\nSet the boundary conditions:\n\nzero_water_flux_bc = WaterFluxBC((p, t) -> 0.0)\nzero_heat_flux_bc = HeatFluxBC((p, t) -> 0.0)\ntop_heat_state_bc = TemperatureStateBC((p, t) -> 263.15)\nbottom_heat_flux_bc = zero_heat_flux_bc\nboundary_fluxes = (;\n    top = WaterHeatBC(; water = zero_water_flux_bc, heat = top_heat_state_bc),\n    bottom = WaterHeatBC(;\n        water = zero_water_flux_bc,\n        heat = bottom_heat_flux_bc,\n    ),\n);\n\nSources are added as elements of a list of sources. Here we just add freezing and thawing.\n\nsources = (PhaseChange{FT}(),);\n\nNow we can package this up in the EnergyHydrology model struct:\n\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n);","category":"section"},{"location":"generated/standalone/Soil/phase_change_analytic/#Running-a-simulation","page":"The Stefan problem","title":"Running a simulation","text":"Specify the initial condition function We chose these to match the initial conditions of the Stefan problem:\n\nfunction set_ic!(Y, p, t0, model)\n    params = model.parameters\n    ν = params.ν\n    FT = eltype(Y.soil.ϑ_l)\n    Y.soil.ϑ_l .= FT(0.33)\n    Y.soil.θ_i .= FT(0.0)\n    T = FT(275.15)\n    ρc_s = Soil.volumetric_heat_capacity(\n        FT(0.33),\n        FT(0.0),\n        params.ρc_ds,\n        params.earth_param_set,\n    )\n    Y.soil.ρe_int .=\n        Soil.volumetric_internal_energy.(\n            FT(0.0),\n            ρc_s,\n            T,\n            params.earth_param_set,\n        )\nend\n\nset_ic! (generic function with 1 method)\n\nWe choose the initial and final simulation times:\n\nt0 = Float64(0)\ntf = Float64(60 * 60 * 24 * 20);\n\ndt = Float64(100)\n\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 3,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\n\nCallbacks\n\nsaveat = 3600.0\nsaving_cb = ClimaLand.NonInterpSavingCallback(t0, tf, saveat);\nsv = saving_cb.affect!.saved_values;\n\nNow we can create and solve the simulation\n\nsimulation = LandSimulation(\n    t0,\n    tf,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    user_callbacks = (saving_cb,),\n    diagnostics = (),\n);\n\nSolve\n\nsol = solve!(simulation);\nsol_T = parent(sv.saveval[end].soil.T)[:]\n\nfig = Figure(size = (500, 500), fontsize = 24)\nax1 = Axis(\n    fig[1, 1],\n    title = \"\",\n    xlabel = \"T (K)\",\n    ylabel = \"Depth (m)\",\n    xgridvisible = false,\n    ygridvisible = false,\n    xticks = 263:3:275,\n)\nlimits!(ax1, 262, 276, -3, 0.0)\n\nz = parent(soil.domain.fields.z)[:];\n\nlines!(ax1, sol_T, z, label = \"Model\", color = :blue, linewidth = 3)\n\nMakieCore.Lines{Tuple{Vector{GeometryBasics.Point{2, Float32}}}}","category":"section"},{"location":"generated/standalone/Soil/phase_change_analytic/#Analytic-Solution-of-Neumann","page":"The Stefan problem","title":"Analytic Solution of Neumann","text":"All details here are taken from M. Dall’Amico et al. [8] (see also Carslaw and Jaeger [12]), and the reader is referred to that for further information on the solution. It takes the form of a function for T(z) on each side of the freezing front interface, which depends on the thermal properties in that region, and which is also parameterized by a parameter (ζ), which we show how to solve for below. In computing the thermal properties, we evaluate the conductivity and heat capacity assuming that all of the water is either in liquid or frozen form, with total mass proportional to θ_l0ρ_l (as we have no water flow).\n\nCompute the thermal conductivity and heat capacity in the frozen region - subscript 1.\n\nθ_0 = FT(0.33)\nLH_f0 = FT(3.33e5)\nρ_liq = FT(1000)\nρ_ice = FT(917)\nkdry = params.κ_dry\nksat = ClimaLand.Soil.κ_sat(\n    FT(0.0),\n    θ_0 * ρ_liq / ρ_ice,\n    params.κ_sat_unfrozen,\n    params.κ_sat_frozen,\n)\nKe = ClimaLand.Soil.kersten_number(\n    θ_0 * ρ_liq / ρ_ice,\n    ClimaLand.Soil.relative_saturation(FT(0), θ_0 * ρ_liq / ρ_ice, ν),\n    params.α,\n    params.β,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n)\n\nλ1 = ClimaLand.Soil.thermal_conductivity(kdry, Ke, ksat)\nc1 = ClimaLand.Soil.volumetric_heat_capacity(\n    FT(0.0),\n    θ_0 * ρ_liq / ρ_ice,\n    params.ρc_ds,\n    params.earth_param_set,\n)\nd1 = λ1 / c1;\n\nCompute the thermal conductivity and heat capacity in the region with liquid water - subscript 2.\n\nksat = ClimaLand.Soil.κ_sat(\n    θ_0 * ρ_liq / ρ_ice,\n    FT(0.0),\n    params.κ_sat_unfrozen,\n    params.κ_sat_frozen,\n)\nKe = ClimaLand.Soil.kersten_number(\n    θ_0 * ρ_liq / ρ_ice,\n    ClimaLand.Soil.relative_saturation(θ_0 * ρ_liq / ρ_ice, FT(0), ν),\n    params.α,\n    params.β,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n)\n\nλ2 = ClimaLand.Soil.thermal_conductivity(kdry, Ke, ksat)\nc2 = ClimaLand.Soil.volumetric_heat_capacity(\n    θ_0 * ρ_liq / ρ_ice,\n    FT(0.0),\n    params.ρc_ds,\n    params.earth_param_set,\n)\nd2 = λ2 / c2;\n\nInitial T and surface T, in Celsius\n\nTi = FT(2)\nTs = FT(-10.0);\n\nThe solution requires the root of the implicit equation below\n\nusing Roots\nusing SpecialFunctions\nfunction implicit(ζ)\n    term1 = exp(-ζ^2) / ζ / erf(ζ)\n    term2 =\n        -λ2 * sqrt(d1) * (Ti - 0) /\n        (λ1 * sqrt(d2) * (0 - Ts) * ζ * erfc(ζ * sqrt(d1 / d2))) *\n        exp(-d1 / d2 * ζ^2)\n    term3 = -LH_f0 * ρ_liq * θ_0 * sqrt(π) / c1 / (0 - Ts)\n    return (term1 + term2 + term3)\nend\nζ = find_zero(implicit, (0.25, 0.27), Bisection())\ndepth = Array(0:0.01:3)\nt = FT(sol.t[end])\nzf = 2.0 * ζ * sqrt(d1 * t)\nanalytic_unfrozen_profile(depth, zf) =\n    erfc(depth / (zf / ζ / (d1 / d2)^0.5)) / erfc(ζ * (d1 / d2)^0.5)\nanalytic_frozen_profile(depth, zf) = (erf(depth / (zf / ζ))) / erf(ζ)\nmask_unfrozen = depth .>= zf\nmask_frozen = depth .<= zf\nT_frozen = Ts .+ (0.0 - Ts) .* analytic_frozen_profile.(depth, zf) .+ 273.15\nT_unfrozen = Ti .- (Ti - 0.0) .* analytic_unfrozen_profile.(depth, zf) .+ 273.15\nlines!(\n    ax1,\n    T_frozen[mask_frozen],\n    -1 .* depth[mask_frozen],\n    label = \"Analytic Solution\",\n    color = \"orange\",\n    linewidth = 3,\n)\nlines!(\n    ax1,\n    T_unfrozen[mask_unfrozen],\n    -1 .* depth[mask_unfrozen],\n    color = \"orange\",\n    linewidth = 3,\n)\naxislegend(ax1, position = :lb, framevisible = false)\n\nsave(\"phase_change_analytic.png\", fig);\n\nWARNING: using Roots.solve! in module ##271 conflicts with an existing identifier.\n\n\n(Image: )","category":"section"},{"location":"generated/standalone/Soil/phase_change_analytic/#References","page":"The Stefan problem","title":"References","text":"M. Dall’Amico et al.: The Cryosphere, 5, 469–484 (2011).\nCarslaw, H. and Jaeger, J.: Conduction of heat in solids, Clarendon Press Oxford, 1959.\nBonan, G.: Climate Change and Terrestrial Ecosystem Modeling, Cambridge University Press 2019\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/Callbacks/#ClimaLand-Shared-Callbacks","page":"Callbacks","title":"ClimaLand Shared Callbacks","text":"","category":"section"},{"location":"APIs/Callbacks/#ClimaLand.IntervalBasedCallback","page":"Callbacks","title":"ClimaLand.IntervalBasedCallback","text":"IntervalBasedCallback(\n    period::Dates.Period,\n    t0::ITime,\n    dt::Union{ITime, Nothing},\n    affect!;\n    initialize = (_, _, _, _) -> nothing,\n    callback_start::ITime = t0,\n)\n\nReturns a SciML DiscreteCallback that calls affect! every period. This method is used when the type of period is a Dates.Period\n\nThe returned callback has a condition function that is built on a ClimaDiagnostics EveryCalendarDtSchedule. The initialize argument is passed to the DiscreteCallback as keyword arguments. Excluding initialization, the first time the callback will be called is when the simulation is at or past period + callback_start.\n\n\n\n\n\nIntervalBasedCallback(\n    period::Union{Number, ITime},\n    t0::Union{Number, ITime},\n    dt::Union{Number, ITime, Nothing},\n    affect!;\n    initialize = (_, _, _, _) -> nothing,\n    callback_start::Union{Number, ITime} = t0,\n)\n\nReturns a SciML DiscreteCallback that calls affect! every period. This method is used when period is not a Dates.Period.\n\nThe returned callback has a condition function that is built on a ClimaDiagnostics EveryDtSchedule. The initialize argument is passed to the DiscreteCallback as keyword arguments. Excluding initialization, the first time the callback will be called is when the simulation is at or past period + callback_start.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Callbacks/#ClimaLand.ReportCallback","page":"Callbacks","title":"ClimaLand.ReportCallback","text":"ReportCallback(period, t0; dt = nothing)\n\nReturn a callback that prints performance and progress summaries every period\n\n\n\n\n\n","category":"function"},{"location":"APIs/Callbacks/#ClimaLand.NaNCheckCallback","page":"Callbacks","title":"ClimaLand.NaNCheckCallback","text":"NaNCheckCallback(\n    nancheck_period::Union{Number, Dates.Period, ITime},\n    t0;\n    dt = nothing,\n    mask = nothing,\n)\n\nConstructs a DiscreteCallback which counts the number of NaNs in the state and produces a warning if any are found.\n\nArguments\n\nnancheck_period: The interrval between times when the state is checked for NaNs. Can be specified as an ITime, a Number, or a Dates.Period.\nt0: The start of the simulation.\ndt: The timestep of the model (optional), used to check for consistency.\nmask: NaNs will not be counted in areas where mask is zero\n\nThe callback uses ClimaDiagnostics schedules to determine when to check for NaNs based on the nancheck_period.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Callbacks/#ClimaLand.NonInterpSavingCallback","page":"Callbacks","title":"ClimaLand.NonInterpSavingCallback","text":"NonInterpSavingCallback(\n    start_date::Dates.DateTime,\n    stop_date::Dates.DateTime,\n    callback_period::Dates.Period;\n    first_save_date = start_date,\n)\n\nConstructs a DiscreteCallback which saves the time and cache p at first_save_date and every callback_period after. Times are saved as DateTimes, and the saved times and caches are each saved in a vector. They are stored in a NamedTuple, which is the saved_values property of the affect! property of the DiscreteCallback. For example:\n\ncb = NonInterpSavingCallback(start_date, stop_date, callback_period) saved_values = cb.affect!.saved_values saved_times = saved_values.t - Vector of DateTimes saved_cache = saved_values.saveval - A vector of caches\n\nNote: This method constructs a callback that uses ITime for scheduling, and should only be used with simulations that are run with ITime.\n\n\n\n\n\nNonInterpSavingCallback(t0, tf, callback_period; t_first_save = t0)\n\nConstructs a DiscreteCallback which saves the time and cache p at t_first_save and every callback_period after. Times are saved as the same type as t0, and the saved times and caches are each saved in a vector. They are stored in a NamedTuple, which is the saved_values property of the affect! property of the DiscreteCallback. For example:\n\ncb = NonInterpSavingCallback(t0, tf, callback_period) saved_values = cb.affect!.saved_values saved_times = saved_values.t - Vector of typeof(t0) saved_cache = saved_values.saveval - A vector of caches\n\nNote: This method constructs a callback that uses ITime for scheduling, and should only be used with simulations that are run with ITime.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Callbacks/#ClimaLand.DriverUpdateCallback","page":"Callbacks","title":"ClimaLand.DriverUpdateCallback","text":"DriverUpdateCallback(\n    updatefunc,\n    update_period,\n    t0;\n    dt = nothing,\n)\n\nConstructs a DiscreteCallback which updates the cache p.drivers at each time specified by updateat, using the function updatefunc which takes as arguments (p,t). If update_period is nothing, then updatefunc will not be called during the simulation or during intialization. This can be used to disable the driver update for a simulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Callbacks/#ClimaLand.CheckpointCallback","page":"Callbacks","title":"ClimaLand.CheckpointCallback","text":"CheckpointCallback(\n    checkpoint_period::Union{Number, Dates.Period, ITime},\n    output_dir,\n    t0;\n    model,\n    dt = nothing,\n)\n\nConstructs a DiscreteCallback which saves the state to disk with the save_checkpoint function.\n\nArguments\n\ncheckpoint_period: The interval between times where checkpoints are saved. Can be specified as a float (in seconds) Dates.Period, or ITime.\noutput_dir: The directory where the checkpoint files will be saved.\nt0: The start of the simulation.\nmodel: The ClimaLand model object.\ndt: The timestep of the model (optional), used to check for consistency.\n\nThe callback uses ClimaDiagnostics.EveryCalendarDtSchedule to determine when to save checkpoints based on the checkpoint_period. The schedule is initialized with the t0 to ensure that the first checkpoint is saved at the correct time.\n\nThe save_checkpoint function is called with the current state vector u, the current time t, and the output_dir to save the checkpoint to disk.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Callbacks/#ClimaLand.get_model_callbacks","page":"Callbacks","title":"ClimaLand.get_model_callbacks","text":"get_model_callbacks(model::AbstractModel; kwargs...)\n\nReturns the a tuple of required callbacks for the model, not including the forcing callbacks for radiation and atmospheric state, which are handled separately.\n\nThese are used in the LandSimulation struct; model callbacks are evaluated after the user_callbacks (optional), forcing callbacks (required), but prior to the diagnostic callbacks (optional).\n\n\n\n\n\n get_model_callbacks(model::AbstractLandModel{FT};\n                     kwargs...\n                     ) where {FT}\n\nCreates the tuple of model callbacks for any AbstractLandModel by calling get_model_callbacks on each component model.\n\nDo not rely on the callbacks being in a particular order based on component order.\n\n\n\n\n\nget_model_callbacks(component::AbstractCanopyComponent, canopy; kwargs...)\n\nCreates an empty tuple as a default set of model callbacks for canopy component models.\n\n\n\n\n\nget_model_callbacks(component::AbstractCanopyComponent, canopy; kwargs...)\n\nCreates the pmodel callback and returns it as a single element tuple of model callbacks; we add the callback for the photosynthesis component, and not for the conductance component(PModelConductance).\n\nNote that the Δt passed here is an ITime because it is the Δt used in the simulation.\n\n\n\n\n\n get_model_callbacks(model::CanopyModel{FT}; start_date, Δt) where {FT}\n\nCreates the tuple of model callbacks for a CanopyModel by calling get_model_callbacks on each component model.\n\n\n\n\n\n","category":"function"},{"location":"generated/standalone/Canopy/default_canopy/#Default-Canopy-Model-Tutorial","page":"Default canopy","title":"Default Canopy Model Tutorial","text":"Now that we've run a simple default soil model simulation in Getting Started, let's try doing the same with the canopy model.\n\nThis tutorial sets up our CanopyModel on a column domain. The model prognoses canopy temperature and liquid water content, and diagnoses many more variables. Here you'll see that the setup for different models is very similar, and we'll highlight the changes between them.\n\nNote: we use SI units unless otherwise specified. See our Physical Units documentation for more information.\n\nFirst import the Julia packages we'll need.\n\nimport ClimaParams as CP\nusing ClimaUtilities.TimeVaryingInputs: TimeVaryingInput\nusing ClimaLand\nusing ClimaLand.Domains\nusing ClimaLand.Canopy\nimport ClimaLand.Simulations: LandSimulation, solve!\nimport ClimaLand.Parameters as LP\nusing Dates\nimport ClimaDiagnostics\nusing CairoMakie, ClimaAnalysis, GeoMakie, Printf, StatsBase\nimport ClimaLand.LandSimVis as LandSimVis\n\nChoose a floating point precision, and get the parameter set, which holds constants used across CliMA models.\n\nFT = Float32\ntoml_dict = LP.create_toml_dict(FT);\n\nWe will run this simulation on a point domain at a lat/lon location near Yellowstone National Park. This is different from the soil example, which ran on a column, because the soil model has depth and the canopy model does not.\n\nlonglat = FT.((-110.6, 44.6))\ndomain = Domains.Point(; z_sfc = FT(0.0), longlat);\nsurface_space = domain.space.surface;\n\nWe choose the initial and final simulation times as DatesTimes, and a timestep in seconds.\n\nstart_date = DateTime(2008);\nstop_date = start_date + Second(60 * 60 * 72);\ndt = 900.0;\n\nWhereas the soil model takes in 2 forcing objects (atmosphere and radiation), the canopy takes in 3 (atmosphere, radiation, and ground). Here we read in the first two from ERA5 data, and specify that the following ground conditions will be prescribed: emissivity, albedo, temperature, and soil moisture. We also set up a constant leaf area index (LAI); for an example reading LAI from MODIS data, please see the canopy_tutorial.jl tutorial. This differs from the soil example because we have the extra inputs of the ground conditions and LAI.\n\natmos, radiation = ClimaLand.prescribed_forcing_era5(\n    start_date,\n    stop_date,\n    surface_space,\n    toml_dict,\n    FT;\n    use_lowres_forcing = true,\n);\nground = PrescribedGroundConditions{FT}();\nLAI = TimeVaryingInput((t) -> FT(1.0));\n\nNow, we can create the canopy model. This constructor uses default parameters and parameterizations, but these can also be overwritten, which we'll demonstrate in later tutorials. Of course, this model construction differs from the soil example because we're using a different model type, but the approach remains the same.\n\nmodel =\n    Canopy.CanopyModel{FT}(domain, (; atmos, radiation, ground), LAI, toml_dict);\n\nDefine a function to set initial conditions for the prognostic variables. Since these are specific to the model physics, the contents here differ from the soil example, but the function structure remains the same. The variables initialized here are described in the Model Equations section of the documentation.\n\nfunction set_ic!(Y, p, t0, model)\n    ψ_leaf_0 = FT(-2e5 / 9800)\n    (; retention_model, ν, S_s) = model.hydraulics.parameters\n    S_l_ini = Canopy.PlantHydraulics.inverse_water_retention_curve(\n        retention_model,\n        ψ_leaf_0,\n        ν,\n        S_s,\n    )\n    Y.canopy.hydraulics.ϑ_l.:1 .=\n        Canopy.PlantHydraulics.augmented_liquid_fraction.(ν, S_l_ini)\n    evaluate!(Y.canopy.energy.T, atmos.T, t0)\nend\n\nset_ic! (generic function with 1 method)\n\nSince we'll want to make some plots, let's set up an object to save the model output periodically, as we did for the soil tutorial.\n\ndiag_writer = ClimaDiagnostics.Writers.DictWriter();\ndiagnostics = ClimaLand.Diagnostics.default_diagnostics(\n    model,\n    start_date;\n    output_vars = [\"ct\", \"trans\"],\n    output_writer = diag_writer,\n    reduction_period = :hourly,\n);\n\nNow construct the LandSimulation object, which contains the model and additional timestepping information. This is identical to the soil example.\n\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    dt,\n    model;\n    set_ic!,\n    updateat = Second(dt),\n    user_callbacks = (),\n    diagnostics,\n);\n\nNow we can run the simulation!\n\nsolve!(simulation);\n\nWe can optionally save the simulation parameters to a file for later reference. Here we specify the filepath where we want to save the parameters, and then ClimaParams handles the saving. Note that any parameters overwritten via keyword arguments when constructing models will not be reflected in this file (in this example there are none).\n\nparameter_log_file = \"default_canopy_parameters.toml\"\nCP.log_parameter_information(toml_dict, parameter_log_file)\n\n┌ Warning: Keys are present in parameter file but not used in the simulation. \n│  Typically this is due to a mismatch in parameter name in toml and in source. Offending keys: Any[\"beta_min\", \"bucket_z_0m\", \"pmodel_Ha_Vcmax\", \"f_over\", \"pmodel_ϕ0_c3\", \"molar_mass_oxygen\", \"z0\", \"pmodel_ϕ0_c4\", \"pmodel_ϕa1_c4\", \"pmodel_bRd\", \"bucket_z_0b\", \"critical_snow_fraction\", \"molar_mass_carbon\", \"michaelis_constant\", \"soil_C_substrate_diffusivity\", \"alpha_0\", \"oxygen_diffusion_coefficient\", \"moisture_stress_c\", \"x0\", \"pmodel_oi\", \"delta_S\", \"bucket_beta_decay_exponent\", \"bucket_capacity_fraction\", \"soilCO2_activation_energy\", \"pmodel_ΔHko\", \"k\", \"alpha_snow\", \"pmodel_α\", \"pmodel_ΔHkc\", \"pmodel_aRd\", \"pmodel_ϕa0_c3\", \"pmodel_Kc25\", \"pmodel_ϕa2_c4\", \"pmodel_Hd_Vcmax\", \"pmodel_Γstar25\", \"pmodel_ϕa1_c3\", \"pmodel_Ha_Jmax\", \"delta_alpha\", \"R_sb\", \"pmodel_Hd_Jmax\", \"pmodel_aS_Vcmax\", \"pmodel_bS_Vcmax\", \"bucket_soil_conductivity\", \"O2_michaelis_constant\", \"pmodel_aS_Jmax\", \"CO2_diffusion_coefficient\", \"soilCO2_pre_exponential_factor\", \"critical_snow_water_equivalent\", \"pmodel_fC3\", \"pmodel_cstar\", \"pmodel_ΔHΓstar\", \"beta_0\", \"pmodel_bS_Jmax\", \"pmodel_ϕa2_c3\", \"land_bucket_capacity\", \"bucket_soil_heat_capacity\", \"pmodel_Ko25\", \"soluble_soil_carbon_fraction\", \"beta\", \"pmodel_β\", \"pmodel_ϕa0_c4\", \"gamma\"]\n└ @ ClimaParams ~/.julia/packages/ClimaParams/FGt0m/src/ClimaParams.jl:370\n\n\nLet's plot some results, for example diurnally averaged canopy temperature and transpiration over time:\n\nLandSimVis.make_diurnal_timeseries(\n    simulation;\n    short_names = [\"ct\", \"trans\"],\n    plot_stem_name = \"default_canopy\",\n);\n\n(Image: ) (Image: )\n\nAtmospheric forcing data: Hersbach et al. [18]\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/global/snowy_land/#Global-full-land-(snowsoilcanopy)-run","page":"Snow, soil, canopy","title":"Global full land (snow+soil+canopy) run","text":"The code sets up the ClimaLand land model  on a spherical domain, forcing with ERA5 data, but does not actually run the simulation. To run the simulation, we strongly recommend using a GPU.\n\nFirst we import a lot of packages:\n\nimport ClimaComms\nClimaComms.@import_required_backends\nusing ClimaUtilities\nimport Interpolations\nimport ClimaUtilities.TimeVaryingInputs:\n    TimeVaryingInput, LinearInterpolation, PeriodicCalendar\nimport ClimaParams as CP\nimport ClimaLand\nimport ClimaLand.Parameters as LP\nimport ClimaLand.Simulations: LandSimulation, solve!\nusing Dates\nusing CairoMakie, ClimaAnalysis, GeoMakie, Printf, StatsBase\nimport ClimaLand.LandSimVis as LandSimVis;\n\nSet the simulation float type, determine the context (MPI or on a single node), and device type (CPU or GPU). Create a default output directory for diagnostics.\n\nconst FT = Float64;\ncontext = ClimaComms.context()\nClimaComms.init(context)\ndevice = ClimaComms.device()\ndevice_suffix = device isa ClimaComms.CPUSingleThreaded ? \"cpu\" : \"gpu\"\nroot_path = \"land_longrun_$(device_suffix)\"\ndiagnostics_outdir = joinpath(root_path, \"global_diagnostics\")\noutdir =\n    ClimaUtilities.OutputPathGenerator.generate_output_path(diagnostics_outdir);\ntoml_dict = LP.create_toml_dict(FT)\n\nParamDict{Float64} with 669 parameters\n\nWe can optionally save the simulation parameters to a file for later reference. Here we specify the filepath where we want to save the parameters, and then ClimaParams handles the saving. Note that any parameters overwritten via keyword arguments when constructing models will not be reflected in this file.\n\nparameter_log_file = joinpath(root_path, \"parameters.toml\")\nCP.log_parameter_information(toml_dict, parameter_log_file)\n\n┌ Warning: Keys are present in parameter file but not used in the simulation. \n│  Typically this is due to a mismatch in parameter name in toml and in source. Offending keys: Any[\"beta_min\", \"bucket_z_0m\", \"leaf_Cd\", \"pmodel_Ha_Vcmax\", \"kf\", \"f_over\", \"moisture_stress_pc\", \"pmodel_ϕ0_c3\", \"molar_mass_oxygen\", \"kd_p2\", \"z0\", \"pmodel_ϕ0_c4\", \"pmodel_ϕa1_c4\", \"pmodel_bRd\", \"bucket_z_0b\", \"critical_snow_fraction\", \"molar_mass_carbon\", \"canopy_height\", \"michaelis_constant\", \"soil_C_substrate_diffusivity\", \"canopy_z_0min\", \"plant_S_s\", \"kn_p2\", \"RAI\", \"alpha_0\", \"oxygen_diffusion_coefficient\", \"moisture_stress_c\", \"x0\", \"pmodel_oi\", \"kappa_p2\", \"delta_S\", \"bucket_beta_decay_exponent\", \"bucket_capacity_fraction\", \"soilCO2_activation_energy\", \"pmodel_ΔHko\", \"canopy_z_0m_coeff\", \"K_sat_plant\", \"k\", \"alpha_snow\", \"Weibull_c\", \"SAI\", \"canopy_z_0b_coeff\", \"pmodel_α\", \"min_kd\", \"pmodel_ΔHkc\", \"psi_63\", \"pmodel_aRd\", \"pmodel_ϕa0_c3\", \"canopy_d_coeff\", \"pmodel_Kc25\", \"moisture_stress_sc\", \"pmodel_ϕa2_c4\", \"pmodel_Hd_Vcmax\", \"kn_p1\", \"pmodel_Γstar25\", \"pmodel_ϕa1_c3\", \"pmodel_Ha_Jmax\", \"delta_alpha\", \"R_sb\", \"pmodel_Hd_Jmax\", \"pmodel_aS_Vcmax\", \"pmodel_bS_Vcmax\", \"bucket_soil_conductivity\", \"O2_michaelis_constant\", \"pmodel_aS_Jmax\", \"plant_nu\", \"CO2_diffusion_coefficient\", \"soilCO2_pre_exponential_factor\", \"critical_snow_water_equivalent\", \"pmodel_fC3\", \"a\", \"pmodel_cstar\", \"pmodel_ΔHΓstar\", \"beta_0\", \"pmodel_bS_Jmax\", \"pmodel_ϕa2_c3\", \"ac_canopy\", \"land_bucket_capacity\", \"bucket_soil_heat_capacity\", \"pmodel_Ko25\", \"kd_p1\", \"kp\", \"soluble_soil_carbon_fraction\", \"beta\", \"pmodel_β\", \"pmodel_ϕa0_c4\", \"kappa_p1\", \"gamma\"]\n└ @ ClimaParams ~/.julia/packages/ClimaParams/FGt0m/src/ClimaParams.jl:370\n\n\nSet timestep, start_date, stop_date:\n\nΔt = 450.0\nstart_date = DateTime(2008)\nstop_date = DateTime(2009);\n\nCreate the domain - this is intentionally low resolution, about 4.5 x 4.5 degrees horizontally, to avoid allocating a lot of memory when building the documentation. By default and for testing runs we use nelements = (101, 15), which is about 0.9 x 0.9 degrees horizontally with 15 layers vertically.\n\nnelements = (20, 7)\ndomain = ClimaLand.Domains.global_domain(FT; context, nelements);\n\nLow-resolution forcing data from ERA5 is used here, but high-resolution should be used for production runs.\n\nforcing = ClimaLand.prescribed_forcing_era5(\n    start_date,\n    stop_date,\n    domain.space.surface,\n    toml_dict,\n    FT;\n    use_lowres_forcing = true,\n    max_wind_speed = 25.0,\n    time_interpolation_method = LinearInterpolation(PeriodicCalendar()),\n    regridder_type = :InterpolationsRegridder,\n    context,\n);\n\nMODIS LAI is prescribed for the canopy model:\n\nLAI = ClimaLand.Canopy.prescribed_lai_modis(\n    domain.space.surface,\n    start_date,\n    stop_date,\n);\n\nMake the model:\n\nmodel = ClimaLand.LandModel{FT}(forcing, LAI, toml_dict, domain, Δt);\nsimulation = ClimaLand.Simulations.LandSimulation(\n    start_date,\n    stop_date,\n    Δt,\n    model;\n    outdir,\n    user_callbacks = (),\n);\n\nRun the simulation and make plots:\n\nClimaLand.Simulations.solve!(simulation)\nLandSimVis.make_annual_timeseries(simulation; savedir = root_path)\nLandSimVis.make_heatmaps(simulation;date = stop_date, savedir = root_path)\nLandSimVis.make_leaderboard_plots(simulation, savedir = root_path)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/#Optimality-Model","page":"Optimality Model","title":"Optimality Model","text":"Photosynthetic coordination theory, originally proposed by Von Caemmerer & Farquhar (1981), provides an approach to predict dynamic responses of photosynthetic capacity to environmental constraints. It primarily focuses on how leaf nitrogen (N) affects the photosynthetic capacity. Photosynthetic capacity varies both among plant types and over time and space, and a major determinant of photosynthetic capacity is the maximum rate of Rubisco carboxylation (V_textcmax). \n\nIn this optimality model, Smith et al. (2019) assumes that plants are able to acquire the N necessary to build leaves that can photosynthesize at the fastest possible rate given light availability and biophysical constraints. The Vcmax model estimates V_textcmax and J_textmax as a function of environmental variables as follows:\n\nbeginequation\n    V_textcmax^* = varphi I left(fracmm_cright)left(fracoverlineomega^*8thetaright)\nendequation\n\nwhere\n\nbeginequation\n    overlineomega^* = 1 + overlineomega - sqrt(1 + overlineomega)^2 - 4thetaoverlineomega\nendequation\n\nand\n\nbeginequation\n    overlineomega = -(1 - 2theta) + sqrt(1 - theta)left(frac1frac4cmleft(1 - thetafrac4cmright) - 4thetaright)\nendequation\n\nand\n\nbeginequation\n    c = fracm8thetaleft(1 - fracvarphi I + J_textmax - 2thetavarphi Isqrt(varphi I + J_textmax)^2 - 4thetavarphi I J_textmaxright)\nendequation\n\nand\n\nbeginequation\n    J_textmax = varphi I overlineomega\nendequation\n\nbeginequation\n    m = fracC_i - Gamma^*C_i + 2Gamma^*\nendequation\n\nbeginequation\n    C_i = Gamma^* + (C_a - Gamma^*)fracxixi + sqrtD_g\nendequation\n\nbeginequation\n    xi = sqrtbeta fracK + Gamma^*16eta^*\nendequation\n\nbeginequation\n    K = K_cleft(1 + fracO_iK_oright)\nendequation\n\nbeginequation\n    m_c = fracC_i - Gamma^*C_i + K\nendequation\n\nGamma^*\n\nis the CO_2 compensation point in the absence of mitochondrial respiration\n\nbeginequation\n    Gamma^* = Gamma^*_0 f(T Delta H_a) pp_0\nendequation\n\nwhere Gamma^*_0 = 4332 Pa, p is the atmospheric pressure, p_0 = 101325 Pa, and Delta H_a = 37830 J/mol.\n\nThe model has the following parameters:\n\nvarphi is the realized quantum yield of photosynthetic electron transport (dimensionless). Estimated at 0.257.\ntheta is the curvature of the light response curve (dimensionless). Estimated at 0.85.\nbeta is the ratio of the carbon cost of maintaining photosynthetic proteins to the carbon cost of maintaining a transpiration stream (dimensionless). Estimated at 146.\n\nFor Smith et al. (2019) Vcmax model:\n\nAltitude\nD_g is the vapor pressure deficit (VPD) at altitude\nC_a is the CO_2 partial pressure\nI is the incident photosynthetically active photon flux (PAR)\nT is the temperature","category":"section"},{"location":"APIs/Drivers/#Drivers","page":"Drivers","title":"Drivers","text":"","category":"section"},{"location":"APIs/Drivers/#ClimaLand.PrescribedAtmosphere","page":"Drivers","title":"ClimaLand.PrescribedAtmosphere","text":"PrescribedAtmosphere{FT, CA, DT} <: AbstractAtmosphericDrivers{FT}\n\nContainer for holding prescribed atmospheric drivers and other information needed for computing turbulent surface fluxes when driving land models in standalone mode.\n\nThe default CO2 concentration is a constant as a function of time, equal to 4.2e-4 mol/mol.\n\nSince not all models require co2 concentration, the default for that is nothing.\n\nliquid_precip: Precipitation (m/s) function of time: positive by definition\nsnow_precip: Snow precipitation (m/s) function of time: positive by definition\nT: Prescribed atmospheric temperature (function of time)  at the reference height (K)\nu: Prescribed wind speed (function of time)  at the reference height (m/s)\nq: Prescribed specific humidity (function of time)  at the reference height (_)\nP: Prescribed air pressure (function of time)  at the reference height (Pa)\nc_co2: CO2 concentration in atmosphere (mol/mol)\nstart_date: Start date - the datetime corresponding to t=0 for the simulation\nh: Reference height (m), relative to surface elevation\ngustiness: Minimum wind speed (gustiness; m/s)\nthermo_params: Thermodynamic parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/Drivers/#ClimaLand.PrescribedPrecipitation","page":"Drivers","title":"ClimaLand.PrescribedPrecipitation","text":"PrescribedPrecipitation{FT, LP} <: AbstractAtmosphericDrivers{FT}\n\nContainer for holding prescribed precipitation driver for models which only require precipitation (RichardsModel).\n\nliquid_precip: Precipitation (m/s) function of time: positive by definition\n\n\n\n\n\n","category":"type"},{"location":"APIs/Drivers/#ClimaLand.PrescribedRadiativeFluxes","page":"Drivers","title":"ClimaLand.PrescribedRadiativeFluxes","text":"PrescribedRadiativeFluxes{FT, SW, LW, DT, T, TP} <: AbstractRadiativeDrivers{FT}\n\nContainer for the prescribed radiation functions needed to drive land models in standalone mode.\n\nNote that some models require the zenith angle AND diffuse fraction. The diffuse fraction may be provided directly (of type TimeVaryingInput), or it may be computed empirically. In the latter case, it requires the thermodynamic parameters as well to compute.\n\nTherefore, the allowed combinations are:\n\nZenith angle and diffuse fraction not needed: zenith angle=nothing, thermo_params=nothing, diffuse fraction=nothing\nZenith angle provided and diffuse fraction computed empirically:  thermo params used, diffuse fraction=nothing\nZenith angle provided and diffuse fraction provided: thermo_params not used, diffuse fraction TimeVaryingInput\n\nSW_d: Downward shortwave radiation function of time (W/m^2): positive indicates towards surface\nfrac_diff: Diffuse Fraction of shortwave radiation (unitless, [0,1])\nLW_d: Downward longwave radiation function of time (W/m^2): positive indicates towards surface\nstart_date: Start date - the datetime corresponding to t=0 for the simulation\nθs: Sun zenith angle, in radians\nthermo_params: Thermodynamic parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/Drivers/#ClimaLand.CoupledAtmosphere","page":"Drivers","title":"ClimaLand.CoupledAtmosphere","text":"CoupledAtmosphere{FT} <: AbstractAtmosphericDrivers{FT}\n\nTo be used when coupling to an atmosphere model. Contains fields that are used to compute surface fluxes in the coupled setup.\n\nWhen constructed without a space, the struct doesn't contain anything, but it still acts as a flag that fluxes have been updated by the coupler and don't need to be recomputed. When constructed with a space, the struct contains the fields needed to compute surface fluxes in the coupled setup, which are accessed by ClimaCoupler.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Drivers/#ClimaLand.CoupledRadiativeFluxes","page":"Drivers","title":"ClimaLand.CoupledRadiativeFluxes","text":"CoupledRadiativeFluxes{\n    FT,\n    F <: Union{Function, Nothing},\n    T,\n} <: AbstractRadiativeDrivers{FT}\n\nTo be used when coupling to an atmosphere model. Either both θs and start_date must be nothing, or both must not be nothing`.\n\nDuring the driver update, cosθs is unchanged if θs is nothing. This behavior differs from the PrescribedRadiativeFluxes where cosθs set to NaN if θs is nothing. Otherwise, θs recieves the following arguments: (time_from_start, start_date), and is expected to return zenith angle at the given time.\n\nθs: Function that fills a climacore field with the zenith angle given the following arguments: (timefromstart, start_date)\nstart_date: Start date - the datetime corresponding to t=0 for the simulation\n\n\n\n\n\n","category":"type"},{"location":"APIs/Drivers/#ClimaLand.PrescribedGroundConditions","page":"Drivers","title":"ClimaLand.PrescribedGroundConditions","text":" PrescribedGroundConditions <: AbstractGroundConditions\n\nA container for holding prescribed ground conditions needed by the canopy model when running the canopy in standalone mode, including the surface temperature, albedo, and emissivity, and soil water content, porosity, residual water fraction, and hydrology closure model.\n\nNote that internally we enforce that the soil water content θ must be within the range (θ\\_r, ν].\n\nθ: Prescribed soil water content (m^3/m^3) in the root zone as a function of time\nT: Prescribed ground surface temperature (K) as a function of time\nα_PAR: Ground albedo for PAR\nα_NIR: Ground albedo for NIR\nϵ: Ground emissivity\nν: Soil porosity (m^3/m^3\nθ_r: The soil residual water fraction (m^3/m^3)\nhydrology_cm: The soil hydrology closure model: van Genuchten or Brooks and Corey\n\n\n\n\n\n","category":"type"},{"location":"APIs/Drivers/#ClimaLand.PrognosticGroundConditions","page":"Drivers","title":"ClimaLand.PrognosticGroundConditions","text":" PrognosticGroundConditions <: Canopy.AbstractGroundConditions\n\nA type of AbstractGroundConditions to use when running the CanopyModel as part of an integrated model, i.e. with a prognostic EnergyHydrology soil model and either with or without a snow model.\n\nNote that this struct is linked with the EnergyHydrology/SnowModel models. If we ever had a different soil model, we might need to construct a different PrognosticGroundConditions because the fields may be stored in different places.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Drivers/#ClimaLand.AbstractAtmosphericDrivers","page":"Drivers","title":"ClimaLand.AbstractAtmosphericDrivers","text":" AbstractAtmosphericDrivers{FT}\n\nAn abstract type of atmospheric drivers of land models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Drivers/#ClimaLand.AbstractRadiativeDrivers","page":"Drivers","title":"ClimaLand.AbstractRadiativeDrivers","text":" AbstractRadiativeDrivers{FT}\n\nAn abstract type of radiative drivers of land models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Drivers/#ClimaLand.turbulent_fluxes!","page":"Drivers","title":"ClimaLand.turbulent_fluxes!","text":"turbulent_fluxes!(dest,\n                atmos::CoupledAtmosphere,\n                model::BucketModel,\n                Y,\n                p,\n                t)\n\nComputes the turbulent surface fluxes terms at the ground for a coupled bucket. In this case, the coupler has already computed turbulent fluxes and updated them in each of the component models, so this function does nothing.\n\nNote that this function is not used for the full land model; in that case, the turbulent fluxes are computed by the full land model during each step.\n\n\n\n\n\nturbulent_fluxes!(dest,\n                  atmos::AbstractAtmosphericDrivers,\n                  model::AbstractModel,\n                  Y,\n                  p,\n                  t\n                  )\n\nComputes the turbulent surface flux terms at the ground, including turbulent energy fluxes as well as the water vapor flux (in units of m^3/m^2/s of water). Positive fluxes indicate flow from the ground to the atmosphere.\n\nIt solves for these given atmospheric conditions, model parameters, and the surface conditions.\n\nTo maintain backwards capability with ClimaLandv1.0.1, we also provide a method which does nothing when called with a CoupledAtmosphere.\n\n\n\n\n\nfunction ClimaLand.turbulent_fluxes!(\n    dest,\n    atmos::AbstractAtmosphericDrivers,\n    sf_parameterization::MoninObukhovCanopyFluxes,\n    model::CanopyModel,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nA canopy specific function for compute turbulent fluxes with the atmosphere; returns the latent heat flux, sensible heat flux, vapor flux, and aerodynamic resistance.\n\nWe cannot use the default version in src/shared_utilities/drivers.jl because the canopy requires a different resistance for vapor and sensible heat fluxes, and the resistances depend on ustar, which we must compute using SurfaceFluxes before adjusting to account for these resistances.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.turbulent_fluxes_at_a_point","page":"Drivers","title":"ClimaLand.turbulent_fluxes_at_a_point","text":"turbulent_fluxes_at_a_point(return_extra_fluxes, args...)\n\nThis is a wrapper function that allows us to dispatch on the type of return_extra_fluxes as we compute the turbulent fluxes pointwise. This is needed because space for the extra fluxes is only allocated in the cache when running with a CoupledAtmosphere. The function compute_turbulent_fluxes_at_a_point does the actual flux computation.\n\nThe return_extra_fluxes argument indicates whether to return the following:\n\nmomentum fluxes (ρτxz, ρτyz)\nbuoyancy flux (buoy_flux)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.set_atmos_ts!","page":"Drivers","title":"ClimaLand.set_atmos_ts!","text":"set_atmos_ts!(ts_in, atmos::PrescribedAtmosphere{FT}, p)\n\nFill the pre-allocated ts_in Field with a thermodynamic state computed from the atmosphere.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.surface_air_density","page":"Drivers","title":"ClimaLand.surface_air_density","text":"ClimaLand.surface_air_density(\n                atmos::CoupledAtmosphere,\n                model::BucketModel,\n                Y,\n                p,\n                _...,\n            )\n\nReturns the air density at the surface in the case of a coupled simulation.\n\nThis requires the field ρ_sfc to be present in the cache p under the name of the model.\n\n\n\n\n\nsurface_air_density(\n                    atmos::AbstractAtmosphericDrivers,\n                    model::AbstractModel,\n                    Y,\n                    p,\n                    t,\n                    T_sfc,\n                    )\n\nA helper function which returns the surface air density.\n\nThis assumes the atmospheric thermal state is stored in p.drivers.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.surface_temperature","page":"Drivers","title":"ClimaLand.surface_temperature","text":"ClimaLand.surface_temperature(\n    model::EnergyHydrology{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nReturns the surface temperature field of the EnergyHydrology soil model.\n\nThe assumption is that the soil surface temperature is the same as the temperature at the center of the first soil layer.\n\n\n\n\n\nClimaLand.surface_temperature(model::SnowModel, Y, p)\n\na helper function which returns the surface temperature for the snow model, which is stored in the aux state.\n\n\n\n\n\nClimaLand.surface_temperature(model::BucketModel, Y, p)\n\na helper function which returns the surface temperature for the bucket model, which is stored in the aux state.\n\n\n\n\n\nsurface_temperature(model::AbstractModel, Y, p, t)\n\nA helper function which returns the surface temperature for a given model, needed because different models compute and store surface temperature in different ways and places.\n\nExtending this function for your model is only necessary if you need to compute surface fluxes and radiative fluxes at the surface using the functions in this file.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.surface_resistance","page":"Drivers","title":"ClimaLand.surface_resistance","text":"surface_resistance(model::AbstractModel, Y, p, t)\n\nA helper function which returns the surface resistance for a given model, needed because different models compute and store surface resistance in different ways and places.\n\nExtending this function for your model is only necessary if you need to compute surface fluxes and radiative fluxes at the surface using the functions in this file.\n\nThe default is 0, which is no additional resistance aside from the usual aerodynamic resistance from MOST.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.surface_specific_humidity","page":"Drivers","title":"ClimaLand.surface_specific_humidity","text":"ClimaLand.surface_specific_humidity(model::SnowModel, Y, p, _...)\n\nReturns the precomputed specific humidity over snow as a weighted fraction of the saturated specific humidity over liquid and frozen water.\n\nThis asumes the atmospheric surface state is stored in p.drivers.\n\n\n\n\n\nClimaLand.surface_specific_humidity(model::BucketModel, Y, p)\n\na helper function which returns the surface specific humidity for the bucket model, which is stored in the aux state.\n\n\n\n\n\nsurface_specific_humidity(model::AbstractModel, Y, p, T_sfc, ρ_sfc)\n\nA helper function which returns the surface specific humidity for a given model, needed because different models compute and store q_sfc in different ways and places.\n\nExtending this function for your model is only necessary if you need to compute surface fluxes and radiative fluxes at the surface using the functions in this file.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.displacement_height","page":"Drivers","title":"ClimaLand.displacement_height","text":"displacement_height(model::AbstractModel, Y, p)\n\nA helper function which returns the displacement height  for a given model; the default is zero.\n\nExtending this function for your model is only necessary if you need to compute surface fluxes and radiative fluxes at the surface using the functions in this file.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.default_zenith_angle","page":"Drivers","title":"ClimaLand.default_zenith_angle","text":"default_zenith_angle(\n    t::T,\n    start_date::Dates.DateTime;\n    latitude::LT,\n    longitude::LT,\n    insol_params::Insolation.Parameters.InsolationParameters{FT},\n)\n\nCalculate zenith angle with Insolation for the given start date, insolation parameters, latitude, and longitude.\n\nlatitude and longitude can be a collections or a Number.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.prescribed_forcing_era5","page":"Drivers","title":"ClimaLand.prescribed_forcing_era5","text":"prescribed_forcing_era5(start_date,\n                        stop_date,\n                        surface_space,\n                        toml_dict::CP.ParamDict,\n                        FT;\n                        use_lowres_forcing = false,\n                        gustiness=1,\n                        max_wind_speed = nothing,\n                        c_co2 = TimeVaryingInput((t) -> 4.2e-4),\n                        time_interpolation_method = LinearInterpolation(PeriodicCalendar()),\n                        regridder_type = :InterpolationsRegridder,\n                        context = nothing,\n                        )\n\nA helper function which constructs the PrescribedAtmosphere and PrescribedRadiativeFluxes from ERA5 data stored in NetCDF files.\n\nThere are two versions of the ERA5 data available through ClimaLand:\n\na high resolution version (1° x 1°) available for the years 1979-2024\na low resolution version (8° x 8°) available only for the year 2008\n\nThe high resolution version will be used if use_lowres_forcing = false (the default). This artifact is used for global runs on compute clusters, but is too large to be used for local testing, and requires you to have acquired the data in advance. The low resolution version will be used if use_lowres_forcing = true. If the simulation dates are outside of 2008, the 2008 data will be reused for each year of simulation. This artifact is recommended for local testing or quick runs where accuracy is less critical.\n\nThe method for temporal interpolation is controlled via the time_interpolation_method kwarg. We suggest LinearInterpolation(PeriodicCalendar()), which implies linear interpolation in time; the inner argument implies how extrapolation outside the bounds of the data is handled. For example, the ERA5 forcing data we use is hourly, which implies Dec 31 of the last year of the data, at midnight, is not in the data. With the PeriodicCalendar() option, the interpolated value in the data at Jan 1 at timestamp 00 of the first year of the simulation will be used. For the low-resolution forcing data, which only exists for 2008, multi-year runs will repeat the forcing. If this behavior is not what you want, you can change the extrapolation argument to error LinearInterpolation(Throw()) or extrapolate by using the last value `LinearInterpolation(Flat()). More information is available in the ClimaUtilities documentation: https://clima.github.io/ClimaUtilities.jl/dev/inputs/#Extrapolation-boundary-conditions.\n\nThe ClimaLand default is to use nearest neighbor spatial interpolation for low resolution forcing, and linear spatial interpolation for high resolution forcing.\n\nwarning: Clipped values\nHigh wind speed anomalies (10-100x increase and decrease over a period of a several hours) appear in the ERA5 reanalysis data. These generate very large surface fluxes (due to wind speeds up to 300 m/s), which lead to instability. The kwarg max_wind_speed, with a value give in m/s, is used to clip these if it is not nothing. See here.\n\nnote: Full high resolution dataset available on clima cluster only\nThe full 40 year dataset of high resolution ERA5 data is only available on the clima cluster.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.prescribed_perturbed_temperature_era5","page":"Drivers","title":"ClimaLand.prescribed_perturbed_temperature_era5","text":"prescribed_perturbed_temperature_era5(era5_ncdata_path,\n                         surface_space,\n                         start_date,\n                         toml_dict::CP.ParamDict,\n                         ΔT,\n                         FT;\n                         gustiness=1,\n                         max_wind_speed = nothing,\n                         c_co2 = TimeVaryingInput((t) -> 4.2e-4),\n                         time_interpolation_method = LinearInterpolation(PeriodicCalendar(Dates.Year(1), DateTime(Dates.year(stop_date)))),\n                         regridder_type = :InterpolationsRegridder,\n                         interpolation_method = Interpolations.Constant(),)\n\nA helper function which constructs the PrescribedAtmosphere and PrescribedRadiativeFluxes from a file path pointing to the ERA5 data in a netcdf file, the surfacespace, the start date, and the `tomldict`, applying a change in the instantaneous temperature at each point of ΔT, while keeping the relative humidity fixed. The LWd shifts as LWd -> LW_d + aΔT, with a= 2W/m^2/K a surface climate sensitivity parameter.\n\nPlease see the documentation for prescribed_forcing_era5 for more information.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.prescribed_perturbed_rh_era5","page":"Drivers","title":"ClimaLand.prescribed_perturbed_rh_era5","text":" prescribed_perturbed_rh_era5(era5_ncdata_path,\n                         surface_space,\n                         start_date,\n                         toml_dict::CP.ParamDict,\n                         Δrh,\n                         FT;\n                         gustiness=1,\n                         max_wind_speed = nothing,\n                         c_co2 = TimeVaryingInput((t) -> 4.2e-4),\n                         time_interpolation_method = LinearInterpolation(PeriodicCalendar(Dates.Year(1), DateTime(Dates.year(stop_date)))),\n                         regridder_type = :InterpolationsRegridder,\n                         interpolation_method = Interpolations.Constant(),)\n\nA helper function which constructs the PrescribedAtmosphere and PrescribedRadiativeFluxes from a file path pointing to the ERA5 data in a netcdf file, the surfacespace, the start date, and the `tomldict`, applying a change in the instantaneous change to relative humidity at each point of Δrh. The perturbed rh is clipped to be within the range (0,1].\n\nPlease see the documentation for prescribed_forcing_era5 for more information.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.prescribed_analytic_forcing","page":"Drivers","title":"ClimaLand.prescribed_analytic_forcing","text":" prescribed_analytic_forcing(FT = Float32;\n                             toml_dict::CP.ParamDict,\n                             start_date = DateTime(2005),\n                             SW_d = (t) -> 0,\n                             LW_d = (t) -> 5.67e-8 * 280.0^4.0,\n                             precip = (t) -> 0, # no precipitation\n                             T_atmos = (t) -> 280.0,\n                             u_atmos = (t) -> 1.0,\n                             q_atmos = (t) -> 0.0, # no atmos water\n                             h_atmos = FT(1e-8),\n                             P_atmos = (t) -> 101325,\n                             atmos = PrescribedAtmosphere(\n                                 TimeVaryingInput(precip),\n                                 TimeVaryingInput(precip),\n                                 TimeVaryingInput(T_atmos),\n                                 TimeVaryingInput(u_atmos),\n                                 TimeVaryingInput(q_atmos),\n                                 TimeVaryingInput(P_atmos),\n                                 start_date,\n                                 h_atmos,\n                                 LP.LandParameters(toml_dict),\n                             ),\n                             radiation = PrescribedRadiativeFluxes(\n                                 FT,\n                                 TimeVaryingInput(SW_d),\n                                 TimeVaryingInput(LW_d),\n                                 start_date,\n                             ),\n                         )\n\nA helper function which constructs the PrescribedAtmosphere and PrescribedRadiativeFluxes for a simple analytic case.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.net_radiation!","page":"Drivers","title":"ClimaLand.net_radiation!","text":"net_radiation!(dest::ClimaCore.Fields.Field,\n               radiation::PrescribedRadiativeFluxes{FT},\n               model::AbstractModel{FT},\n               Y::ClimaCore.Fields.FieldVector,\n               p::NamedTuple,\n               t,\n               ) where {FT}\n\nComputes net radiative  fluxes for a prescribed incoming  longwave and shortwave radiation.\n\n\n\n\n\nnet_radiation!(dest,\n              radiation::CoupledRadiativeFluxes,\n              model::AbstractModel,\n              Y,\n              p,\n              t)\n\nComputes the net radiative flux at the ground for a coupled simulation. Your model cache must contain the field R_n.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.vapor_pressure_deficit","page":"Drivers","title":"ClimaLand.vapor_pressure_deficit","text":"vapor_pressure_deficit(T_air, P_air, q_air, thermo_params)\n\nComputes the vapor pressure deficit for air with temperature Tair, pressure Pair, and specific humidity qair, using thermoparams, a Thermodynamics.jl param set.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.get_drivers","page":"Drivers","title":"ClimaLand.get_drivers","text":"ClimaLand.get_drivers(model::RichardsModel)\n\nReturns the driver variable symbols for the RichardsModel; these depend on the boundary condition type and currently only are required for the RichardsAtmosDrivenFluxBC, which is driven by a prescribed time and space varying precipitation.\n\n\n\n\n\nClimaLand.get_drivers(model::SnowModel)\n\nReturns the driver variable symbols for the SnowModel.\n\n\n\n\n\nget_drivers(model::AbstractModel)\n\nReturns the driver objects for the model - atmospheric and radiative forcing, etc - as a tuple (atmos, radiation, ...). If no drivers are needed by a model, an empty tuple should be returned\n\n\n\n\n\nClimaLand.get_drivers(model::LandModel)\n\nReturns the \"drivers\", or forcing variables, for the LandModel.\n\nThese consist of atmospheric and radiative forcing.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Drivers/#ClimaLand.make_update_drivers","page":"Drivers","title":"ClimaLand.make_update_drivers","text":"make_update_drivers(::AbstractClimaLandDrivers)\n\nCreates and returns a function which updates the driver variables in the default case of no drivers. More generally, this should return a function which updates the driver fields stored in p.drivers.\n\n\n\n\n\nmake_update_drivers(driver_tuple)\n\nCreates and returns a function which updates the forcing variables (\"drivers\"). If no drivers are being used, driver_tuple is empty, and the update function does nothing.\n\n\n\n\n\nmake_update_drivers(a::PrescribedGroundConditions{FT}) where {FT}\n\nCreates and returns a function which updates the driver variables in the case of a PrescribedGroundConditions.\n\n\n\n\n\nmake_update_drivers(a::PrescribedAtmosphere{FT}) where {FT}\n\nCreates and returns a function which updates the driver variables in the case of a PrescribedAtmosphere.\n\n\n\n\n\nmake_update_drivers(a::PrescribedPrecipitation{FT}) where {FT}\n\nCreates and returns a function which updates the driver variables in the case of a PrescribedPrecipitation.\n\n\n\n\n\nmake_update_drivers(r::CoupledRadiativeFluxes{FT}) where {FT}\n\nCreates and returns a function which updates the driver variables in the case of a CoupledRadiativeFluxes.\n\nWhen r.θs is nothing, the cosine zenith angle not changed, and should be updated by the coupler. This differs from the behavior of PrescribedRadiativeFluxes, where the cosine zenith angle is set to NaN if θs is nothing.\n\nOtherwise, the cosine zenith angle is computed using cos.(r.θs(t, r.start_date)).\n\n\n\n\n\nmake_update_drivers(r::PrescribedRadiativeFluxes{FT}) where {FT}\n\nCreates and returns a function which updates the driver variables in the case of a PrescribedRadiativeFluxes.\n\n\n\n\n\n","category":"function"},{"location":"repo_structure/#ClimaLand-folder-structure","page":"Repository structure","title":"ClimaLand folder structure","text":"The ClimaLand home directory has 6 main folders:\n\ndocs: contains files to generate the documentation website.\nexperiments: contains example simulations of ClimaLand models. Most of these experiments are run as part of our continuous integration (CI) pipeline.\next: contains a package extension for the ML-based Neural Snow model and an extension for model parameters\nlib: contains a package, ClimaLandSimulations, that extends ClimaLand functionality and is currently under development\nsrc: contains the code that implements ClimaLand models.\ntest: contains unit tests for the source code, which are meant to ensure individual pieces of the codebase work as intended before merging pull requests.\n\nThe repo also has 3 CI-related folders, containing workflows that are run at each pull request.\n\n.buildkite: contains a script that runs a variety of ClimaLand simulations, largely from the experiments and tests folders. These runs are carried out as part of CI and must run without error in order to merge a PR.\n.dev: contains useful tools for developers, such as a format checker for Julia (which is run as part of CI and must pass before a PR can be merged into main).\n.github: contains various Github Actions scripts, for example, this documentation website is built each time a change is push to ClimaLand.\n\nas well as 9 files:\n\n.gitignore: commonly used git file, contains files, files type, and folders that should be ignored by git.\nLICENSE: License file of ClimaLand, you can read it to learn about legal practice regarding use of ClimaLand open source code.\nProject.toml: The Julia programming language requires a Project.toml file to create an environment, which specify dependencies of a project as well as its version, name, authors and a unique identifier number (uuid). Every Julia registered package has a Project.toml file.\nREADME.md: This markdown file contains the info that you can read on ClimaLand GitHub web page\nlogo.svg and logo-white.svg: The logos used in the README\nArtifacts.toml: This file contains Pkg artifacts declarations\nNEWS.md: Release notes file with descriptions of new features and changes in each release and main\nNOTICE: This contains the copyright and states what the project is licensed under","category":"section"},{"location":"repo_structure/#/docs-folder","page":"Repository structure","title":"/docs folder","text":"Julia packages are recommended to have a /docs folder that builds a standardised documentation following the official documentation generator for Julia: Documenter.jl.\n\nThe folder /docs contains:\n\na /src folder: It is recommended to put your markdown pages inside this folder. Each markdown file (.md extension text file) is a page accessible through the menu of the documentation. For example, docs/src/contributing.md contains the text you can read on the documentation \"contribution guide\" menu. The path to this .md file and the name of the menu is set in the docs/make.jl file.\na make.jl file: This Julia file contains your documentation website structure. Running this file will build your website pages, you can run it locally, but it is commonly built remotely via .github/workflows/docs.yml to generate the github static page hosted on the gh-pages branch.\n\nNote: the documentation can have submenu. For example, APIs have submenu ClimaLand which has many submenu... This structure is built in our current framework via a file docs/list_of_apis.jl in that example, which is then included in docs/make.jl.","category":"section"},{"location":"repo_structure/#/experiments-folder","page":"Repository structure","title":"/experiments folder","text":"The experiments folder contains four folders. It contains a folder for integrated models and a folder for standalone models. These two folders are meant to provide users with simple examples of ClimaLand runs. The files contains meteorological inputs (such as precipitation), values for every parameters, and the domains and timestepper are specified.\n\nFor example, /experiments/integrated/fluxnet/ contains:\n\ndata_tools.jl: Provides utilities for running fluxnet site experiments\nfluxnet_domain.jl: Sets up the domain to run Clima Land on a fluxtower site\nfluxnet_simulation.jl: Contains the site-generic time variables for running ClimaLand on\n\nfluxtower sites\n\npull_MODIS.jl: provides methods for interacting with the MODIS REST API at a site\nmetdriversFLUXNET.jl: Construct the drivers. This script includes pull_MODIS.jl\n\ndefined by plant functional types instead of fully site-specific parameters.\n\nplot_utils.jl: Plotting utilities for the integrated fluxnet site experiments\nozark_pft.jl: Runs the Ozark site (US-MOz) using plant parameters. Running this script\n\nwill include all of the above scripts.\n\nrun_fluxnet.jl: Sets up integrated models and runs fluxnet expirement on a given site.\n\nRunning this script will include all of the above scripts, except ozark_pft.jl\n\nand folders for four fluxnet sites. For example /experiments/integrated/fluxnet/US-MOz contains:\n\nUS-MOz_parameters.jl: Contains site-specific model parameters for running Clima Land on the Ozark\n\nfluxtower site\n\nUS-MOz_simulation.jl: Contains simulation variables for running Clima Land on the US-MOz\n\nfluxtower site\n\nThe experiments folder also contains a benchmarks folder and a long_runs folder. These contain experiments that are run as part of CI on the Caltech cluster. benchmarks is ran to ensure the model runs in a similar amount of time after changes are made. long_runs create outputs that can be checked for validity.","category":"section"},{"location":"repo_structure/#/src-folder","page":"Repository structure","title":"/src folder","text":"The /src folder contains the source code of ClimaLand models. It contains 4 folders:\n\nsharedutilities: This is a core folder that defines functions and data structures used across all modules and models types of ClimaLand. For example, `sharedutilities/models.jldefines and export the functionmakeupdateauxwhich will be used to create a function which updates the auxiliary parameters, stored in the vectorp,sharedutilities/boundaryconditions.jl` defines functions for setting boundary condition for PDE domains, etc.\nstandalone: This folder contains standalone models, which are submodels that can be run independently of each other. This is an important aspect of ClimaLand code design: to maximize modularity, sub-models can be run alone, and many different methods of the same sub-model can be defined via Julia multiple dispatch. The standalone folder is independent from the integrated folder.\nintegrated: This folder contains integrated models. It assembles standalone models together, as one would assemble pieces of a puzzle. Thanks to the modularity of ClimaLand design, many configuration of LSM can be assembled in integrated models. The same functions (update_aux!, exp_tendency!, etc.) can be used for standalone and integrated models, and an can be stepped  in the same way.\ndiagnostics: This folder contains diagnostics methods for different\n\nClimaLand models. The diagnostics contains metadata such as where diagnostics variables are stored in those models, what is there names (short, long, standard) and physical units, with additional comment\n\nAs well as two files:\n\nClimaLand.jl: This file is the main Julia module of ClimaLand.jl repository. It contains all functions defined in /src in a nested way, for example ClimaLand.X, ClimaLand.Soil.X, ClimaLand.Canopy.X, etc. When a Julia user install and uses ClimaLand via ]add ClimaLand, using ClimaLand, they are loading those functions, and are ready to use ClimaLand codebase.\nArtifacts.jl: Contains functions that return the path of the given artifact name in the current context","category":"section"},{"location":"repo_structure/#/lib-folder","page":"Repository structure","title":"/lib folder","text":"This folder contains a subfolder, /ClimaLandSimulations, which contains a library of methods to easily and conveniently run ClimaLand at a variety of sites and globally. There are 3 subfolders:\n\nexperiments: This folder contains scripts to run ClimaLand at a fluxnet site using ClimaLandSimulations\nsrc: Contains source code for the ClimaLandSimulations package. There are 3 subfolders and\n\n1 file.\n\nDashboards: Contains scripts to create dashboards for running simulations at fluxnet sites\nFluxnet: Contains scripts to setup a ClimaLand simulation at a fluxnet site\nutilities: Contains utilities used in setup of ClimaLand simulation at a fluxnet sites\ntest: Contains tests for the ClimaLandSimulations package","category":"section"},{"location":"repo_structure/#/ext-folder","page":"Repository structure","title":"/ext folder","text":"This folder has one subfolder, /neural_snow, which contains tools to create the neural network for snow and process its data. There are also two files\n\nCreateParametersExt.jl: An extension for ClimaLand that contains constructors for model\n\nparameters\n\nNeuralSnowExt.jl: Contains all functions in /neural_snow","category":"section"},{"location":"repo_structure/#/test-folder","page":"Repository structure","title":"/test folder","text":"The /test folder contains a test suite that can be run with make test. It contains 4 subfolders:\n\ndiagnostics: This folder contains tests for ClimaLand.Diagnostics\nintegrated: This folder contains tests for the integrated LSMs\nsharedutilities: This folder tests ClimaLand utilities. It contains four files and a subfolder, `implicittimestepping`, which contains tests for Richards and full soil model implicit timestepping tests\nstandalone: This contains 5 subfolders, Bucket, Snow, Soil, SurfaceWater, and Vegetation. These contain tests for each of the respective standalone models.\n\n/test also contains 3 files:\n\naqua.jl: Contains code quality assurance tests tha use Aqua.jl\nProject.toml: Specifies dependencies needed for testing\nruntests.jl: When test is ran from the package manager, this file is ran. It can also be\n\nmanually ran using the test environment. This file runs all the other test scripts.","category":"section"},{"location":"generated/standalone/Canopy/canopy_tutorial/#Introduction-to-the-Canopy-Model","page":"Default canopy fluxtower simulation ","title":"Introduction to the Canopy Model","text":"This tutorial shows how to instantiate and run a simulation of the canopy biophysics model in ClimaLand. A CanopyModel including all component models is initialized, then an example simulation is run. The initial conditions, atmospheric and radiative flux conditions, and canopy properties are set up to match those observed at the US-MOz flux tower, a flux tower located within an oak-hickory forest in Ozark, Missouri, USA. See Wang et al. [19] for details on the site and canopy parameters.\n\nThe canopy biophysics model in ClimaLand combines a photosynthesis model with a canopy radiative transfer scheme, plant hydraulics model, and stomatal conductance model, placing them under either prescribed or simulated (as in a full Earth System Model) atmospheric and radiative flux conditions.\n\nClimaLand supports either Beer-Lambert law or a Two-Stream model for radiative transfer. For this tutorial, we will use the Beer-Lambert law, in which the intensity of light absorbed is a negative exponential function of depth in the canopy and an exinction coefficient determined by optical depth.\n\nThe model of photosynthesis in Clima Land is the Farquhar Model in which GPP is calculated based on C3 and C4 photosynthesis, which determines potential leaf-level photosynthesis.\n\nThe plant hydraulics model in ClimaLand solves for the water content within bulk root-stem-canopy system using Richards equation discretized into an arbitrary number of layers. The water content is related to the water potential using a retention curve relationship, and the water potential is used to simulate the effect moisture stress has on transpiration and GPP.","category":"section"},{"location":"generated/standalone/Canopy/canopy_tutorial/#Preliminary-Setup","page":"Default canopy fluxtower simulation ","title":"Preliminary Setup","text":"Load External Packages:\n\nimport SciMLBase\nusing Plots\nusing Statistics\nusing Dates\nusing Insolation\n\nLoad CliMA Packages and ClimaLand Modules:\n\nusing ClimaCore\nimport ClimaParams as CP\nimport ClimaTimeSteppers as CTS\nusing StaticArrays\nusing ClimaLand\nimport ClimaLand.Domains\nusing ClimaLand.Canopy\nusing ClimaLand.Canopy.PlantHydraulics\nimport ClimaLand.Simulations: LandSimulation, solve!\nimport ClimaLand\nimport ClimaLand.Parameters as LP\nimport ClimaDiagnostics\nusing DelimitedFiles\nimport ClimaLand.FluxnetSimulations as FluxnetSimulations\nusing CairoMakie, ClimaAnalysis, GeoMakie, Printf, StatsBase\nimport ClimaLand.LandSimVis as LandSimVis\n\nDefine the floating point precision desired (64 or 32 bit), and get the parameter set holding constants used across CliMA Models:\n\nconst FT = Float32;\ntoml_dict = LP.create_toml_dict(FT);\n\nWe will use prescribed atmospheric and radiative forcing from the US-MOz tower.\n\nsite_ID = \"US-MOz\";\nsite_ID_val = FluxnetSimulations.replace_hyphen(site_ID);\n\nGet the latitude and longitude in degrees, as well as the time offset in hours of local time from UTC\n\n(; time_offset, lat, long) =\n    FluxnetSimulations.get_location(FT, Val(site_ID_val));\n\nGet the height of the sensors in m\n\n(; atmos_h) = FluxnetSimulations.get_fluxtower_height(FT, Val(site_ID_val));\n\nSet a start and stop date of the simulation in UTC, as well as a timestep in seconds\n\nstart_date = DateTime(\"2010-05-01\", \"yyyy-mm-dd\")\nstop_date = DateTime(\"2010-09-01\", \"yyyy-mm-dd\")\ndt = 450.0\n\n450.0\n\nSite latitude and longitude\n\nlat = FT(38.7441) # degree\nlong = FT(-92.2000) # degree\n\n-92.2f0","category":"section"},{"location":"generated/standalone/Canopy/canopy_tutorial/#Setup-the-Canopy-Model","page":"Default canopy fluxtower simulation ","title":"Setup the Canopy Model","text":"We want to simulate a vegetative canopy in standalone mode, without coupling the canopy to atmospheric or soil physics models, so we choose a CanopyModel. Here we will use the default parameterizations and parameters for ease of setting up the model, but these can be overridden by constructing and passing canopy components to the CanopyModel constructor. This will be explored in a later tutorial.\n\nNow we define the parameters of the model domain. These values are needed by some of the component models. Here we are performing a 1-dimensional simulation in a Point domain and will use single stem and leaf compartments, but for 2D simulations, the parameters of the domain would change.\n\ndomain = ClimaLand.Domains.Point(; z_sfc = FT(0.0), longlat = (long, lat));\n\nWe will be using prescribed atmospheric and radiative drivers from the US-MOz tower, which we read in here. We are using prescribed atmospheric and radiative flux conditions, but it is also possible to couple the simulation with atmospheric and radiative flux models.\n\n(; atmos, radiation) = FluxnetSimulations.prescribed_forcing_fluxnet(\n    site_ID,\n    lat,\n    long,\n    time_offset,\n    atmos_h,\n    start_date,\n    toml_dict,\n    FT,\n);\n\nFor this canopy, we are running in standalone mode, which means we need to use a prescribed soil driver, defined as follows:\n\nθ_soil = FT(0.47)\nT_soil = FT(298.0)\nground = PrescribedGroundConditions{FT}(;\n    α_PAR = FT(0.2),\n    α_NIR = FT(0.4),\n    T = TimeVaryingInput(t -> T_soil),\n    θ = TimeVaryingInput(t -> θ_soil),\n    ϵ = FT(0.99),\n);\nforcing = (; atmos, radiation, ground);\n\nNow we read in time-varying LAI from a global MODIS dataset.\n\nsurface_space = domain.space.surface;\nLAI =\n    ClimaLand.Canopy.prescribed_lai_modis(surface_space, start_date, stop_date);\n\nGet the maximum LAI at this site over the first year of the simulation\n\nmaxLAI = FluxnetSimulations.get_maxLAI_at_site(start_date, lat, long);\n\nConstruct radiative transfer model, overwriting some default parameters.\n\nradiation_parameters = (;\n    Ω = FT(0.69),\n    G_Function = ConstantGFunction(FT(0.5)),\n    α_PAR_leaf = FT(0.1),\n    α_NIR_leaf = FT(0.45),\n    τ_PAR_leaf = FT(0.05),\n    τ_NIR_leaf = FT(0.25),\n)\nradiative_transfer = Canopy.TwoStreamModel{FT}(\n    domain,\n    toml_dict;\n    radiation_parameters,\n    ϵ_canopy = FT(0.99),\n);\n\nConstruct canopy hydraulics with 1 stem and 1 leaf compartment. By default, the model is constructed with a single leaf compartment and no stem.\n\nn_stem = Int64(1)\nn_leaf = Int64(1)\nh_stem = FT(9)\nh_leaf = FT(9.5)\nSAI = FT(0.00242)\nf_root_to_shoot = FT(3.5)\nRAI = FT((SAI + maxLAI) * f_root_to_shoot)\nplant_ν = FT(0.7)\nplant_S_s = FT(1e-2 * 0.0098)\nK_sat_plant = FT(1.8e-8)\nψ63 = FT(-4 / 0.0098)\nWeibull_param = FT(4)\nconductivity_model =\n    PlantHydraulics.Weibull{FT}(K_sat_plant, ψ63, Weibull_param)\nhydraulics = Canopy.PlantHydraulicsModel{FT}(\n    domain,\n    toml_dict;\n    n_stem,\n    n_leaf,\n    h_stem,\n    h_leaf,\n    ν = plant_ν,\n    S_s = plant_S_s,\n    conductivity_model,\n);\nrooting_depth = FT(1)\nheight = FT(18)\nbiomass =\n    Canopy.PrescribedBiomassModel{FT}(; LAI, SAI, RAI, rooting_depth, height);\n\nConstruct the conductance model.\n\nconductance = Canopy.MedlynConductanceModel{FT}(domain, toml_dict; g1 = FT(141));\n\nConstruct the photosynthesis model.\n\nphotosynthesis_parameters = (; is_c3 = FT(1), Vcmax25 = FT(5e-5))\nphotosynthesis =\n    Canopy.FarquharModel{FT}(domain, toml_dict; photosynthesis_parameters);\n\nSet up the canopy model using defaults for all parameterizations and parameters, except for the hydraulics model defined above.\n\ncanopy = ClimaLand.Canopy.CanopyModel{FT}(\n    domain,\n    forcing,\n    LAI,\n    toml_dict;\n    hydraulics,\n    radiative_transfer,\n    conductance,\n    photosynthesis,\n    biomass,\n);\n\nProvide initial conditions for the canopy hydraulics model\n\nfunction set_ic!(Y, p, t0, model)\n    (; retention_model, ν, S_s) = model.hydraulics.parameters\n    ψ_stem_0 = FT(-1e5 / 9800)\n    ψ_leaf_0 = FT(-2e5 / 9800)\n\n    S_l_ini =\n        inverse_water_retention_curve.(\n            retention_model,\n            [ψ_stem_0, ψ_leaf_0],\n            ν,\n            S_s,\n        )\n    for i in 1:2\n        Y.canopy.hydraulics.ϑ_l.:($i) .=\n            augmented_liquid_fraction.(ν, S_l_ini[i])\n    end\n    evaluate!(Y.canopy.energy.T, atmos.T, t0)\nend\n\nset_ic! (generic function with 1 method)\n\nSet up the diagnostics writer, which will save model variables throughout the course of the simulation.\n\ndiag_writer = ClimaDiagnostics.Writers.DictWriter();\ndiagnostics = ClimaLand.Diagnostics.default_diagnostics(\n    canopy,\n    start_date;\n    output_vars = [\"gpp\", \"trans\"],\n    output_writer = diag_writer,\n    reduction_period = :hourly,\n);\n\nSelect a timestepping algorithm and setup the ODE problem.\n\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 6,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\n\nCreate the LandSimulation object, which will also create and initialize the state vectors, the cache, the driver callbacks, and set the initial conditions.\n\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    dt,\n    canopy;\n    set_ic!,\n    updateat = Second(1800),\n    timestepper = ode_algo,\n    user_callbacks = (),\n    diagnostics,\n);\n\nNow we can solve the simulation, which will run the model forward in time.\n\nsol = solve!(simulation);","category":"section"},{"location":"generated/standalone/Canopy/canopy_tutorial/#Create-some-plots","page":"Default canopy fluxtower simulation ","title":"Create some plots","text":"We can now plot the data produced in the simulation. For example, GPP and transpiration:\n\nLandSimVis.make_diurnal_timeseries(\n    simulation;\n    short_names = [\"gpp\", \"trans\"],\n    plot_stem_name = \"canopy\",\n)\n\n(Image: ) (Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/standalone/Bucket/bucket_tutorial/#Introduction-to-the-Land-Bucket-Model","page":"Bucket","title":"Introduction to the Land Bucket Model","text":"The land bucket model implemented in ClimaLand is based off of the models of Manabe [1], Milly and Shmakin [2], Laguë et al. [3] model, with small changes, as noted.\n\nThis tutorial explains in brief the core equations and the necessary parameters of the bucket model, and shows how to set up a simulation in standalone mode. More detail for coupled runs can be found in the ClimaCoupler.jl documentation and in the coupled simulation tutorial.\n\nAt each coordinate point on the surface, we solve ordinary differential equations for the subsurface water storage of land (W, m), the snow water equivalent multiplied by the snow cover fraction (σS, m), and the surface water content of land (Ws, m). We additionally solve a partial differential equation for the land temperature as a function of depth (T, K). The snow cover fraction is given by a heaviside function in the current code.\n\nIn what follows, surface fluxes over soil generally indicate fluxes over non-snow-covered regions. The exception is the albedo of vegetated and non-vegetated surfaces, for which we use the symbol α_sfc.\n\nAll equation variables are defined immediately below. We have:\n\nfracd Wdt = -I\n\nfracd Wsdt = -(P_liq + σM + (1-σ) E_soil - I)\n\nfracd σSdt = -(P_snow + σE_snow - σM)\n\nρc fracpartial Tpartial t = κ_soil fracpartial Tpartial z\n\nF_bot = 00 = -κ_soil fracpartial Tpartial z_z = z_bot\n\n(1-σ) (R_n+ SHF + LHF)_soil + σG_undersnow = -κ_soil fracpartial Tpartial z_z = z_sfc\n\nG_undersnow = (R_n+ SHF + LHF)_snow - F_intosnow\n\nF_intosnow = -ρ_l L_f0 (P_snow + E_snow-M)\n\nR_n = -(1-α)*SW -LW + σ_SB T_sfc^4\n\nwhere the water fluxes are : I the infiltration as defined in [1], P_liq (m/s) the water volume flux of precipitation, P_snow (m/s) the water volume flux in the form of snow, (1-σ)E_soil (m/s) the water volume flux in evaporation, σE_snow the water volume flux in sublimation from snow, and σM (m/s) the water volume flux in melting of snow. The melt rate is defined via the net surface flux when surface temperatures are above freezing. All fluxes are defined to be positive if towards the atmosphere (cooling land or decreasing water mass in land) and negative if towards land (warming land or increasing water mass). Hence the melting flux is negative since it warms land, and precipitation fluxes are negative since they increase water mass on land.\n\nFor heat fluxes, we have R_n the net radiation, SHF the sensible heat flux, LHF the latent heat flux, G_undersnow the heat flux into snow-covered soil, and F_intosnow the heat flux into the snowpack itself. Note that the water balance equation for snow is equivalent to the heat balance equation, since we neglect the sensible heat contribution and only track the latent heat contribution. We neglect the energy in liquid precipitation.\n\nFinally, we have α_bareground_func(lat, lon) the (snow-free) surface albedo, ρc the volumetric heat capacity of the land, σ_SB the Stefan-Boltzmann constant,  and κ_soil the thermal conductivity. The albedo is a linear interpolation between the albedo of surface and snow, as decribed in [3]. The surface temperature is taken to be equal to the temperature T at the first grid point, assumed to be the same for soil and snow. At present the snow cover fraction is a heaviside function, and only one set of surface fluxes is computed per grid point.\n\nTurbulent surface fluxes of sensible heat, latent heat, and water vapor (SHF, LHF, E) are computed using Monin-Obukhov theory; SW↓ and LW↓ are the downward fluxes in short and long wavelength bands. We use the same roughness lengths for snow and soil. Note that with the exception of precipitation and downwelling radiation, all fluxes are defined such that positive is towards the atmosphere.\n\nAs the temperature at the surface of the soil and snow is the same, only the evaporation changes between the two surface coverage types. We have\n\nE_soil =  β(W W_f) E(q_sat(T_sfc ρ_sfc liquid)\n\nwhere β is the factor used in [1] which accounts for the fact that soil does not evaporate at the potential rate when it is not saturated. This makes use of the field capacity parameter W_f. We also have\n\nE_snow = E(q_sat(T_sfc ρ_sfc ice)","category":"section"},{"location":"generated/standalone/Bucket/bucket_tutorial/#Simulating-a-standalone-bucket-model","page":"Bucket","title":"Simulating a standalone bucket model","text":"First, we need to import necessary packages. We use SciMLBase.jl and ClimaTimeSteppers.jl for the timestepping.\n\nimport SciMLBase\nimport ClimaTimeSteppers as CTS\n\nWe use ClimaCore for setting up the domain/coordinate points. While this infrastructure isn't really necessary for standalone simulations, adhering to it makes setting up coupled simulations very easy. It also is nice to rely on ClimaCore utilities because they have been designed in advance for running distributed simulations.\n\nusing ClimaCore\n\nWe also use ClimaParams, which strives to ensure a common set of parameters across all Clima models, and to make parameter estimation more seamless.\n\nimport ClimaParams as CP\n\nWe also use Insolation to calculate solar zenith angle and solar insolation.\n\nLastly, let's bring in the bucket model types (from ClimaLand) that we will need access to.\n\nusing ClimaLand.Bucket:\n    BucketModel, BucketModelParameters, PrescribedBaregroundAlbedo\nusing ClimaLand.Domains: coordinates, Column\nimport ClimaLand.Simulations: LandSimulation, solve!\nusing ClimaLand: PrescribedAtmosphere, PrescribedRadiativeFluxes\nusing ClimaUtilities.TimeVaryingInputs: TimeVaryingInput\n\nWe also want to plot the solution, for which we import ClimaLand utilities for plotting and saving.\n\nimport ClimaDiagnostics\nusing CairoMakie, ClimaAnalysis, GeoMakie\nimport ClimaLand.LandSimVis as LandSimVis\n\nAnd we need to use the DateTime type to store start dates\n\nusing Dates\n\nFT = Float32;\n\nAs mentioned we use ClimaParams for earth parameters that are required across models (e.g. the density of water and ice, the latent heat of fusion at a reference temperature, etc). The land model requires additional parameters as described in the text above. These two sets are combined in the object BucketModelParameters as follows:\n\nimport ClimaLand\nimport ClimaLand.Parameters as LP\ntoml_dict = LP.create_toml_dict(FT);\n\nSet up the model domain. At every surface coordinate point, we'll solve an ODE for W and Ws, and for every subsurface point, we solve for T. In coupled simulations run at the same resolution as the atmosphere, the bucket horizontal resolution would match the horizontal resolution at the lowest level of the atmosphere model. In general, however, the two resolutions do not need to match. Here we just set up something simple - a Column.\n\nsoil_depth = FT(3.5);\nbucket_domain = Column(; zlim = (-soil_depth, FT(0.0)), nelements = 10);\nsurface_space = bucket_domain.space.surface\n\nClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}}, SubArray{Float32, 1, Matrix{Float32}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}(ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}(ClimaComms.CPUSingleThreaded()), ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, ClimaCore.Geometry.AxisTensor{Float32, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float32, 1}}}, SubArray{Float32, 1, Matrix{Float32}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}\n  Float32[0.0, 0.35, 0.175, 2.85714, 0.35, 2.85714, 8.16327, 0.1225])\n\nDefine our PrescribedBaregroundAlbedo model using a constant bareground surface and snow albedo: The bareground albedo is a function of coordinates, which would be (x,y) on a plane, and (lat,lon) on a sphere. It is also an option to supply a netcdf file with the bareground albedo.\n\nα_bareground_func = (coordinate_point) -> 0.2;\nα_snow = FT(0.8);\nalbedo =\n    PrescribedBaregroundAlbedo{FT}(α_snow, α_bareground_func, surface_space);\n\nThe critical snow level setting the scale for when we interpolate between snow and surface albedo\n\nσS_c = FT(0.2);\n\nThe field capacity of the soil\n\nW_f = FT(0.15);\n\nRoughness lengths (meters)\n\nz_0m = FT(1e-2);\nz_0b = FT(1e-3);\n\nThermal parameters of soil\n\nκ_soil = FT(0.7);\nρc_soil = FT(2e6);\n\nSnow melt timescale\n\nτc = FT(3600);\n\nbucket_parameters = BucketModelParameters(toml_dict; albedo, z_0m, z_0b, τc);\n\nThe PrescribedAtmosphere and PrescribedRadiation need to take in a reference time, the date of the start of the simulation. In this tutorial we will consider this January 1, 2005.\n\nstart_date = DateTime(2005);\n\nSimulation start date, end time, and timestep\n\nstop_date = start_date + Second(7 * 86400);\nΔt = 3600.0;\n\nTo drive the system in standalone mode, the user must provide prescribed functions of time for the water volume flux in precipitation,  for the net downward shortwave and longwave radiative energy fluxes (SW↓, LW↓, W/m^2), for the atmospheric temperature T_a, wind speed u_a (m/s), specific humidity q_a, and air density ρ_a (kg/m^3) at a reference height h_a (m).\n\nHere we define the model drivers Prescribed atmospheric variables\n\nPrecipitation:\n\nprecip = (t) -> 0;\nsnow_precip = (t) -> -5e-7 * (FT(t) > 3 * 86400) * (FT(t) < 4 * 86400);\n\nDiurnal temperature variations:\n\nT_atmos = (t) -> 275.0 + 5.0 * sin(2.0 * π * FT(t) / 86400 - π / 2);\n\nConstant otherwise:\n\nu_atmos = (t) -> 3.0;\nq_atmos = (t) -> 0.005;\nh_atmos = FT(2);\nP_atmos = (t) -> 101325;\n\nWe need to warp all these objects in TimeVaryingInputs (this is because in general PrescribedAtmosphere could take numerical data)\n\nbucket_atmos = PrescribedAtmosphere(\n    TimeVaryingInput(precip),\n    TimeVaryingInput(snow_precip),\n    TimeVaryingInput(T_atmos),\n    TimeVaryingInput(u_atmos),\n    TimeVaryingInput(q_atmos),\n    TimeVaryingInput(P_atmos),\n    start_date,\n    h_atmos,\n    toml_dict,\n);\n\nPrescribed radiation – a prescribed downwelling SW diurnal cycle, with a peak at local noon, and a prescribed downwelling LW radiative flux, assuming the air temperature is on average 275 degrees K with a diurnal amplitude of 5 degrees K:\n\nSW_d = (t) -> @. max(1361 * sin(2π * FT(t) / 86400 - π / 2));\nLW_d = (t) -> 5.67e-8 * (275.0 + 5.0 * sin(2.0 * π * FT(t) / 86400 - π / 2))^4;\nbucket_rad = PrescribedRadiativeFluxes(\n    FT,\n    TimeVaryingInput(SW_d),\n    TimeVaryingInput(LW_d),\n    start_date,\n);\n\nThen, we create the model object, which contains the drivers, parameters, domain, and is associated with the correct differential equations for the bucket model:\n\nmodel = BucketModel(\n    parameters = bucket_parameters,\n    domain = bucket_domain,\n    atmosphere = bucket_atmos,\n    radiation = bucket_rad,\n);\n\nNote the holder structs for the radiation and atmosphere functions: they are named Prescribed. In coupled simulations, we would use a different type and rely on multiple dispatch to obtain the atmospheric and radiative quantitites from the coupler.\n\nNext is to create a function to set initial conditions.\n\nfunction set_ic!(Y, p, t0, model)\n    Y.bucket.T .= FT(270)\n    Y.bucket.W .= FT(0.05)\n    Y.bucket.Ws .= FT(0.0)\n    Y.bucket.σS .= FT(0.08)\nend\n\nset_ic! (generic function with 1 method)\n\nNow we choose our timestepping algorithm.\n\ntimestepper = CTS.RK4()\node_algo = CTS.ExplicitAlgorithm(timestepper)\n\nClimaTimeSteppers.IMEXAlgorithm{ClimaTimeSteppers.Unconstrained, ClimaTimeSteppers.RK4, ClimaTimeSteppers.IMEXTableau{ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}}, Nothing}(ClimaTimeSteppers.Unconstrained(), ClimaTimeSteppers.RK4(), ClimaTimeSteppers.IMEXTableau{ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}}(ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}([0.0 0.0 0.0 0.0; 0.5 0.0 0.0 0.0; 0.0 0.5 0.0 0.0; 0.0 0.0 1.0 0.0]), ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.16666666666666666, 0.3333333333333333, 0.3333333333333333, 0.16666666666666666]), ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.0, 0.5, 0.5, 1.0]), ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}([0.0 0.0 0.0 0.0; 0.5 0.0 0.0 0.0; 0.0 0.5 0.0 0.0; 0.0 0.0 1.0 0.0]), ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.16666666666666666, 0.3333333333333333, 0.3333333333333333, 0.16666666666666666]), ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.0, 0.5, 0.5, 1.0])), nothing)\n\nTo store diagnostic variables, as they are not stored by default, we use ClimaDiagnostics (for details, see here). The output is saved at an hourly resolution (cf. Δt = 3600 s above). Note that for each of the prognostic variables, there is a corresponding diagnostic (see the full list of diagnostics here):\n\nSubsurface water storage W: wsoil\nSnow water equivalent times snow cover fraction σS: ssfc\nSurface water content Ws: wsfc\nLand temperature T: tsoil\n\nsaveat = Second(Δt)\ndiag_writer = ClimaDiagnostics.Writers.DictWriter();\ndiagnostics = ClimaLand.Diagnostics.default_diagnostics(\n    model,\n    start_date;\n    output_vars = [\"lhf\", \"shf\", \"rn\", \"wsoil\", \"ssfc\", \"wsfc\", \"tsoil\"],\n    output_writer = diag_writer,\n    reduction_period = :hourly,\n);\n\nCreate the LandSimulation object, which will also create and initialize the state vectors, the cache, the driver callbacks, and set the initial conditions.\n\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    Δt,\n    model;\n    set_ic! = set_ic!,\n    updateat = Second(Δt),\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    diagnostics = diagnostics,\n);\nY = simulation._integrator.u;\np = simulation._integrator.p;\n\nWe can inspect the prognostic and auxiliary variables of the model:\n\nClimaLand.prognostic_vars(model)\nY.bucket |> propertynames\n\n(:W, :T, :Ws, :σS)\n\nThe auxiliary variables in this case are the surface temperature, the turbulent fluxes, the net radiation, and the surface specific humidity.\n\nClimaLand.auxiliary_vars(model)\np.bucket |> propertynames\nsolve!(simulation);\n\n┌ Info: Progress\n│   simulation_time = \"17 hours\"\n│   n_steps_completed = 17\n│   wall_time_per_step = \"0 seconds\"\n│   wall_time_total = \"0 seconds\"\n│   wall_time_remaining = \"0 seconds\"\n│   wall_time_spent = \"0 seconds\"\n│   percent_complete = \"10.1%\"\n│   estimated_sypd = \"Inf\"\n│   date_now = 2026-01-13T14:25:04.499\n└   estimated_finish_date = 2026-01-13T14:25:04.499\n┌ Info: Progress\n│   simulation_time = \"1 day, 10 hours\"\n│   n_steps_completed = 34\n│   wall_time_per_step = \"25 milliseconds, 188 microseconds\"\n│   wall_time_total = \"4 seconds, 231 milliseconds\"\n│   wall_time_remaining = \"3 seconds, 375 milliseconds\"\n│   wall_time_spent = \"856 milliseconds, 396 microseconds\"\n│   percent_complete = \"20.2%\"\n│   estimated_sypd = \"391.306\"\n│   date_now = 2026-01-13T14:25:05.080\n└   estimated_finish_date = 2026-01-13T14:25:09.080\n┌ Info: Progress\n│   simulation_time = \"2 days, 3 hours\"\n│   n_steps_completed = 51\n│   wall_time_per_step = \"20 milliseconds, 167 microseconds\"\n│   wall_time_total = \"3 seconds, 388 milliseconds\"\n│   wall_time_remaining = \"2 seconds, 359 milliseconds\"\n│   wall_time_spent = \"1 second, 28 milliseconds\"\n│   percent_complete = \"30.4%\"\n│   estimated_sypd = \"488.715\"\n│   date_now = 2026-01-13T14:25:05.085\n└   estimated_finish_date = 2026-01-13T14:25:08.085\n┌ Info: Progress\n│   simulation_time = \"2 days, 20 hours\"\n│   n_steps_completed = 68\n│   wall_time_per_step = \"15 milliseconds, 190 microseconds\"\n│   wall_time_total = \"2 seconds, 551 milliseconds\"\n│   wall_time_remaining = \"1 second, 519 milliseconds\"\n│   wall_time_spent = \"1 second, 32 milliseconds\"\n│   percent_complete = \"40.5%\"\n│   estimated_sypd = \"648.86\"\n│   date_now = 2026-01-13T14:25:05.089\n└   estimated_finish_date = 2026-01-13T14:25:07.089\n┌ Info: Progress\n│   simulation_time = \"3 days, 13 hours\"\n│   n_steps_completed = 85\n│   wall_time_per_step = \"12 milliseconds, 206 microseconds\"\n│   wall_time_total = \"2 seconds, 50 milliseconds\"\n│   wall_time_remaining = \"1 second, 13 milliseconds\"\n│   wall_time_spent = \"1 second, 37 milliseconds\"\n│   percent_complete = \"50.6%\"\n│   estimated_sypd = \"807.489\"\n│   date_now = 2026-01-13T14:25:05.094\n└   estimated_finish_date = 2026-01-13T14:25:07.094\n┌ Info: Progress\n│   simulation_time = \"4 days, 6 hours\"\n│   n_steps_completed = 102\n│   wall_time_per_step = \"10 milliseconds, 212 microseconds\"\n│   wall_time_total = \"1 second, 715 milliseconds\"\n│   wall_time_remaining = \"673 milliseconds, 997 microseconds\"\n│   wall_time_spent = \"1 second, 41 milliseconds\"\n│   percent_complete = \"60.7%\"\n│   estimated_sypd = \"965.156\"\n│   date_now = 2026-01-13T14:25:05.098\n└   estimated_finish_date = 2026-01-13T14:25:06.098\n┌ Info: Progress\n│   simulation_time = \"4 days, 23 hours\"\n│   n_steps_completed = 119\n│   wall_time_per_step = \"8 milliseconds, 788 microseconds\"\n│   wall_time_total = \"1 second, 476 milliseconds\"\n│   wall_time_remaining = \"430 milliseconds, 660 microseconds\"\n│   wall_time_spent = \"1 second, 45 milliseconds\"\n│   percent_complete = \"70.8%\"\n│   estimated_sypd = \"1121.434\"\n│   date_now = 2026-01-13T14:25:05.102\n└   estimated_finish_date = 2026-01-13T14:25:06.102\n┌ Info: Progress\n│   simulation_time = \"5 days, 16 hours\"\n│   n_steps_completed = 136\n│   wall_time_per_step = \"7 milliseconds, 724 microseconds\"\n│   wall_time_total = \"1 second, 297 milliseconds\"\n│   wall_time_remaining = \"247 milliseconds, 182 microseconds\"\n│   wall_time_spent = \"1 second, 50 milliseconds\"\n│   percent_complete = \"81.0%\"\n│   estimated_sypd = \"1275.984\"\n│   date_now = 2026-01-13T14:25:05.107\n└   estimated_finish_date = 2026-01-13T14:25:06.107\n┌ Info: Progress\n│   simulation_time = \"6 days, 9 hours\"\n│   n_steps_completed = 153\n│   wall_time_per_step = \"6 milliseconds, 894 microseconds\"\n│   wall_time_total = \"1 second, 158 milliseconds\"\n│   wall_time_remaining = \"103 milliseconds, 410 microseconds\"\n│   wall_time_spent = \"1 second, 54 milliseconds\"\n│   percent_complete = \"91.1%\"\n│   estimated_sypd = \"1429.68\"\n│   date_now = 2026-01-13T14:25:05.111\n└   estimated_finish_date = 2026-01-13T14:25:06.111\n\n\nNow we can easily visualize the results using LandSimVis:\n\nLandSimVis.make_timeseries(simulation;)\n\nSome prognostic variables:: (Image: ) (Image: ) (Image: )\n\nSome diagnostic variables:: (Image: ) (Image: ) (Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/#The-Two-Stream-Scheme","page":"Two-Stream model","title":"The Two-Stream Scheme","text":"In order to treat the effects of multiple scattering by cloud particles, aerosols and air molecules, the two-stream approximations are employed in most shortwave radiation (i.e., solar, 300-2500 nm) schemes presently used in LSMs for numerical weather prediction and climate modelling. In two-stream approximations, the radiation field is divided into the direct solar beam, plus the diffuse solar radiation (i.e., radiation scattered at least once), and in two directions, downward and upward fluxes. The angular distribution of scattered radiation is not computed in any further detail, which means they are considered to be isotropic (Raisaenen, 2002).\n\nThe two-stream approximation, or scheme has been used to deal with radiative transfer in the atmosphere for many years. The basic procedure in applying it to vegetation is to expand a complex function in the control equations into Legendre functions and then truncate them to the first order closure to get a simple solution (Dai, 2007). After reviewing several variants of the two-stream approximation model in the calculation of atmospheric radiation, Meador (1980) presented a unified form of the variants and introduced a new and improved method.\n\nDickinson 1983 introduced this new two-stream method to estimate radiative transfer in a vegetated canopy, and Sellers 1985 used the two-stream approximation to calculate values of hemispheric canopy reflectance in the visible or photosynthecially active radiation (PAR) and near-infrared (NIR) wavelength intervals. The two-stream approximation treatment has been widely used in land surface process models until nowadays. The approximation assumes that diffuse radiative fluxes are isotropic in the upward and downward directions. Supposing that the upper and lower leaf optical properties are identical, the two-stream approximation used to model radiative transfer in plant canopies is given in the following form:\n\n-overlinemu(dI^uparrow)dL + 1 - (1 - beta)omegaI^uparrow - omega beta I^downarrow = omega overlinemu K beta_0 exp(-KL)\n-overlinemu(dI^downarrow)dL + 1 - (1 - beta)omegaI^downarrow - omega beta I^uparrow = omega overlinemu K (1-beta_0) exp(-KL)\n\nwhere I↑ and I↓ are the upward and downward diffuse radiative fluxes normalized by the incident flux respectively, μ is the cosine of the zenith angle of the incident beam, K is the optical depth of direct beam per unit leaf area and is equal to G(μ)/μ, G(μ) is the relative projected area of leaf elements in the direction cos−1μ, μ is the average inverse diffuse optical depth per unit leaf area and is equal to\n\nint_0^1mu^primeG(mu^prime)dmu^prime\n\nμ′ is the direction of scattered flux, ω is the scattering coefficient and is equal to αleaf +τleaf , and L is the cumulative LAI. β and β0 are upscattering parameters for the diffuse and direct beams respectively. (See Sellers 1985 for details)\n\nThese equations can be solved as an exact solution with appropriate boundary conditions. For direct incident radiation, the appropriate top boundary condition is I↓ = 0 for L = 0, and the bottom boundary condition is I↑ = αs[I↓ + exp (−kLT )] for L = LT , where αs is the soil reflectance and LT is the total LAI. The corresponding solution yielded is then:\n\nI^uparrow = frach_1exp(-KL)sigma + h_2exp(-hL) + h_3exp(hL)\nI^downarrow = frach_4exp(-KL)sigma + h_5exp(-hL) + h_6exp(hL)\n\nFor diffuse radiation, the appropriate top boundary condition is I↓ = 1 for L = 0, and the bottom boundary condition is I↑ = αsI↓ for L = LT. Then, the corresponding solution is:\n\nI^uparrow = h_7exp(-hL) + h_8exp(hL)\nI^downarrow = h_9exp(-hL) + h_10exp(hL)\n\nwhere coefficients such as σ and h1 to h10 are given in Sellers 1985. Note that there is an error in the expression for h4 in the appendix of Sellers 1985. The correct expression may be found in Sellers 1996.\n\nThe model has the following variables:\n\nOutput Symbol Unit Range\nAbsorbed fraction of radiative flux per band abs_λ W m⁻² 0–1\nReflected fraction of radiative flux per band refl_λ W m⁻² 0–1\nTransmitted fraction of radiative flux per band trans_λ W m⁻² 0–1\n\nInput Symbol Unit Range\nPhotosynthetically Active Radiation PAR μmol m⁻² s⁻¹ 0–1500\nLeaf Area Index LAI m² m⁻² 0–10\nCanopy Reflectance alpha_rmleafλ - 0–1\nCanopy Transmittance tau_rmleafλ - 0–1\nClumping index Ω - 0–1\nZenith angle θ_s rad 0–π\nLeaf angle distribution l_d - 0–1\nGround albedo α_rmgroundλ - 0–1","category":"section"},{"location":"APIs/soil/SoilAlbedo/#Parameterizing-Soil-Albedo","page":"Soil Albedo","title":"Parameterizing Soil Albedo","text":"We currently support two parameterizations for the soil albedo. These options are defined using Julia types, using simplified code, as follows. We first introduce the abstract type AbstractSoilAlbedoParameterization, and then the two albedo parameterizations are concrete examples of that abstract type:\n\nConstantTwoBandSoilAlbedo <: AbstractSoilAlbedoParameterization\nCLMTwoBandSoilAlbedo <: AbstractSoilAlbedoParameterization\n\nEach of these types define a method for update_albedo!, which is called in the soils tendency functions, and each stores the parameters required to compute the albedo for that parameterizations. For example, the parameterization based off of CLM's approach requires the wet and dry soil albedos in the PAR and NIR wavelength bands. For each band, the actual albedo is a linear combination of the wet and dry values, with a weight depending on the soil moisture. The method of update_albedo! for this parameterization computes this linear combination using a helper function albedo_from_moisture and ultimately sets\n\n@. p.soil.PAR_albedo =\n    albedo_from_moisture(S_sfc, PAR_albedo_dry, PAR_albedo_wet)\n@. p.soil.NIR_albedo =\n    albedo_from_moisture(S_sfc, NIR_albedo_dry, NIR_albedo_wet)\n\nwhere S_sfc is the effective saturation at the surface.","category":"section"},{"location":"APIs/soil/SoilAlbedo/#Creating-a-new-albedo-parameterization","page":"Soil Albedo","title":"Creating a new albedo parameterization","text":"Suppose you want to define a new parameterization which models albedo as a linear combination of the albedos of quartz, organic matter, minerals and water, treating NIR and PAR albedos the same.\n\nFirst, create the type:\n\nstruct SoilAlbedoFromComposition{FT <: AbstractFloat} <: AbstractSoilAlbedoParameterization\n    α_quartz::FT\n    α_minerals::FT\n    α_om::FT\n    α_water::FT\nend\n\nAnd then create the method. For now, don't worry about the other arguments and their types:\n\nfunction update_albedo!(\n    bc::AtmosDrivenFluxBC,\n    albedo::SoilAlbedoFromComposition,\n    p,\n    soil_domain,\n    model_parameters,\n    )\n    # unpack parameters of the albedo model\n    (; α_quartz, α_minerals, α_om, α_water) = albedo\n    # unpack composition parameters from the soil parameters\n    (; ν_ss_om, ν_ss_quartz) = model_parameters\n    # Extract the values at the top level\n    ν_ss_om_sfc = ClimaLand.Domains.top_center_to_surface(ν_ss_om)\n    ν_ss_quartz_sfc = ClimaLand.Domains.top_center_to_surface(ν_ss_quartz)\n    # Extract the top layer's volumetric water content\n    θ_l_sfc = ClimaLand.Domains.top_center_to_surface(p.soil.θ_l)\n\n    # Compute the linear combination\n    @. p.soil.PAR_albedo = α_water * θ_l_sfc + (1-θ_l_sfc)* (α_quartz * ν_ss_quartz_sfc + α_om * ν_ss_om_sfc + α_minerals * (1-ν_ss_om - ν_ss_quartz))\n    p.soil.NIR_albedo .= p.soil.PAR_albedo\nend","category":"section"},{"location":"APIs/soil/SoilAlbedo/#ClimaLand.Soil.CLMTwoBandSoilAlbedo","page":"Soil Albedo","title":"ClimaLand.Soil.CLMTwoBandSoilAlbedo","text":" CLMTwoBandSoilAlbedo{\n    FT <: AbstractFloat,\n    SF <: Union{FT, ClimaCore.Fields.Field},\n} <: AbstractSoilAlbedoParameterization\n\nA parameterization for soil albedo: the soil albedo is defined in two bands (PAR and NIR), and can spatially vary or be set to scalar. However, it varies temporally due to a dependence on soil water content at the surface, via the effective saturation S(θ_sfc): α = α_wetS + α_dry(1-S)\n\nWe use a value for θ_sfc averaged over the depth albedo_calc_top_thickness. If the model resolution is such that the first layer is thicker than this depth, the value from the first layer is used.\n\nCLM reference: Lawrence, P.J., and Chase, T.N. 2007. Representing a MODIS consistent land surface in the Community Land Model (CLM 3.0). J. Geophys. Res. 112:G01023. DOI:10.1029/2006JG000168.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilAlbedo/#ClimaLand.Soil.ConstantTwoBandSoilAlbedo","page":"Soil Albedo","title":"ClimaLand.Soil.ConstantTwoBandSoilAlbedo","text":"ConstantTwoBandSoilAlbedo{\n    SF <: Union{AbstractFloat, ClimaCore.Fields.Field},\n} <: AbstractSoilAlbedoParameterization\n\nA parameterization for soil albedo: the soil albedo is  defined in two bands (PAR and NIR), can spatially vary or be set to scalar, but is assumed not to vary in time (or with water content).\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilAlbedo/#ClimaLand.Soil.update_albedo!","page":"Soil Albedo","title":"ClimaLand.Soil.update_albedo!","text":"update_albedo!(bc::AtmosDrivenFluxBC, albedo::ConstantTwoBandSoilAlbedo, p, soil_domain, model_parameters)\n\nUpdates PAR and NIR albedo using the temporally-constant parameters  provided in albedo; these values may be spatially varying.\n\nFor the temporally-constant albedo model, there is no need to update  the values each step, or have an allocated spot in the cache for them. This can be optimized in the future.\n\n\n\n\n\nupdate_albedo!(bc::AtmosDrivenFluxBC, albedo::CLMTwoBandSoilAlbedo, p, soil_domain, model_parameters)\n\nCalculates and updates PAR and NIR albedo as a function of volumetric soil water content at the top of the soil. If the soil layers are larger than the specified albedo_calc_top_thickness, the water content of the top layer is used in the calclulation. For the PAR and NIR bands,\n\nα_band = α_{band,dry} * (1 - S_e) +  α_{band,wet} * (S_e)\n\nwhere S_e is the relative soil wetness above some depth, albedo_calc_top_thickness. This is a modified version of Equation (1) of:\n\nBraghiere, R. K., Wang, Y., Gagné-Landmann, A., Brodrick, P. G., Bloom, A. A., Norton, A. J., et al. (2023). The importance of hyperspectral soil albedo information for improving Earth system model projections. AGU Advances, 4, e2023AV000910. https://doi.org/10.1029/2023AV000910\n\nwhere effective saturation is used in place of volumetric soil water content. The dry and wet albedo values come from a global soil color map and soil color to albedo map from CLM.\n\nCLM reference: Lawrence, P.J., and Chase, T.N. 2007. Representing a MODIS consistent land surface in the Community Land Model (CLM 3.0). J. Geophys. Res. 112:G01023. DOI:10.1029/2006JG000168.\n\n\n\n\n\nupdate_albedo!(bc::AbstractEnergyHydrologyBC, _...)\n\nDoes nothing for boundary conditions where albedo is not used.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Bucket/#Bucket","page":"Bucket Model","title":"Bucket","text":"","category":"section"},{"location":"APIs/Bucket/#Types-and-Constructors","page":"Bucket Model","title":"Types and Constructors","text":"","category":"section"},{"location":"APIs/Bucket/#Misc-Functions","page":"Bucket Model","title":"Misc Functions","text":"","category":"section"},{"location":"APIs/Bucket/#ClimaLand.Bucket.BucketModelParameters","page":"Bucket Model","title":"ClimaLand.Bucket.BucketModelParameters","text":"struct BucketModelParameters{\n    FT <: AbstractFloat,\n    PSE,\n}\n\nContainer for holding the parameters of the bucket model.\n\nκ_soil: Conductivity of the soil (W/K/m); constant\nρc_soil: Volumetric heat capacity of the soil (J/m^3/K); constant\nalbedo: Albedo Model\nσS_c: Critical σSWE amount (m) where surface transitions from to snow-covered\nf_snow: Fraction of critical amount of snow at which sublimation β begins to decay to zero (unitless)\nW_f: Capacity of the land bucket (m)\nf_bucket: Fraction of bucket capacity at which evaporation β begins to decay to zero (unitless)\np: Exponent used in β decay (unitless)\nz_0m: Roughness length for momentum (m)\nz_0b: Roughness length for scalars (m)\nτc: τc timescale on which snow melts\nearth_param_set: Earth Parameter set; physical constants, etc\n\n\n\n\n\n","category":"type"},{"location":"APIs/Bucket/#ClimaLand.Bucket.BucketModelParameters-Tuple{ClimaParams.ParamDict}","page":"Bucket Model","title":"ClimaLand.Bucket.BucketModelParameters","text":"BucketModelParameters(\n    toml_dict::CP.ParamDict;\n    albedo,\n    W_f = toml_dict[\"land_bucket_capacity\"],\n    f_bucket = toml_dict[\"bucket_capacity_fraction\"],\n    z_0b = toml_dict[\"bucket_z_0b\"],\n    ρc_soil = toml_dict[\"bucket_soil_heat_capacity\"],\n    f_snow = toml_dict[\"critical_snow_fraction\"],\n    z_0m = toml_dict[\"bucket_z_0m\"],\n    σS_c = toml_dict[\"critical_snow_water_equivalent\"],\n    p = toml_dict[\"bucket_beta_decay_exponent\"],\n    κ_soil = toml_dict[\"bucket_soil_conductivity\"],\n    τc = toml_dict[\"tau_c\"],\n)\n\nConstruct a BucketModelParameters from a TOML dict.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Bucket/#ClimaLand.Bucket.PrescribedBaregroundAlbedo","page":"Bucket Model","title":"ClimaLand.Bucket.PrescribedBaregroundAlbedo","text":"PrescribedBaregroundAlbedo{FT, F <: ClimaCore.Fields.Field} <: AbstractBucketAlbedoModel\n\nAn albedo model where the static snow-free bareground albedo is prescribed as a function of space or using data from a file, and the land surface albedo is computed each timestep as a linear combination of the snow albedo and the bareground albedo, following the SLIM model (Lague et al 2019).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Bucket/#ClimaLand.Bucket.PrescribedSurfaceAlbedo","page":"Bucket Model","title":"ClimaLand.Bucket.PrescribedSurfaceAlbedo","text":"PrescribedSurfaceAlbedo{FT, TV <: AbstractTimeVaryingInput}\n                   <: AbstractBucketAlbedoModel\n\nAn albedo model where the albedo of different surface types is specified. Albedo is specified via a NetCDF file which is a function of time and covers all surface types (soil, vegetation, snow, etc). This albedo type changes over time according to the input file.\n\nNote that this option should only be used with global simulations, i.e. with a ClimaLand.LSMSphericalShellDomain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Bucket/#ClimaLand.Bucket.BucketModel","page":"Bucket Model","title":"ClimaLand.Bucket.BucketModel","text":"struct BucketModel{\n     FT,\n     PS <: BucketModelParameters{FT},\n     ATM <: AbstractAtmosphericDrivers{FT},\n     RAD <: AbstractRadiativeDrivers{FT},\n     D,\n } <: AbstractBucketModel{FT}\n\nConcrete type for the BucketModel, which store the model domain and parameters, as well as the necessary atmosphere and radiation fields for driving the model.\n\nparameters: Parameters required by the bucket model\natmos: The atmospheric drivers: Prescribed or Coupled\nradiation: The radiation drivers: Prescribed or Coupled\ndomain: The domain of the model\n\n\n\n\n\n","category":"type"},{"location":"APIs/Bucket/#ClimaLand.surface_albedo","page":"Bucket Model","title":"ClimaLand.surface_albedo","text":"ClimaLand.surface_albedo(\n    model::EnergyHydrology{FT},\n    Y,\n    p,\n) where {FT}\n\nReturns the surface albedo field of the EnergyHydrology soil model.\n\n\n\n\n\nsurface_albedo(model::SnowModel, Y, p)\n\nA helper function which computes and returns the snow albedo.\n\n\n\n\n\nsurface_albedo(model::BucketModel, Y, p)\n\nReturns the bulk surface albedo, which gets updated in update_aux via next_albedo.\n\n\n\n\n\nsurface_albedo(model::AbstractModel, Y, p)\n\nA helper function which returns the surface albedo for a given model, needed because different models compute and store α_sfc in different ways and places.\n\nExtending this function for your model is only necessary if you need to compute surface fluxes and radiative fluxes at the surface using the functions in this file.\n\n\n\n\n\nClimaLand.surface_albedo(::LandModel, Y, p)\n\nReturns the surface albedo for the land model, which is computed from the ratio of the upwelling and downwelling shortwave radiation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Bucket/#ClimaLand.Bucket.beta_factor","page":"Bucket Model","title":"ClimaLand.Bucket.beta_factor","text":"beta_factor(W::FT, σS::FT, fW_f::FT, fσS_c::FT, p::FT) where {FT}\n\nComputes the beta factor which scales the evaporation/sublimation from the potential rate. The beta factor is given by:\n\nβ = (x/x_c)^p x < x_c     1         otherwise\n\nwhere x = W and x_c = f_bucket * W_f for the bucket, and x = σS and x_c = f_snow *σS_c for snow.\n\n\n\n\n\n","category":"function"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#Coupled-heat-and-water-equations-tending-towards-equilibrium","page":"Energy and Hydrology","title":"Coupled heat and water equations tending towards equilibrium","text":"The Richards equation tutorial demonstrates how to solve for water flow in soil, without considering heat transfer, phase changes, or the effect of temperature and the effect of ice on the hydraulic properties of the soil.\n\nHere we show how to solve the interacting heat and water equations, in sand, but without phase changes. This allows us to capture behavior that is not present in Richards equation alone.\n\nThe equations are:\n\nfrac ρe_int t =    κ(θ_l θ_i ν ) T +   ρe_int_liq K (Tθ_l θ_i ν ) nabla h( ϑ_l z ν )\n\nfrac  ϑ_l t =   K (Tθ_l θ_i ν ) h( ϑ_l z ν )\n\nHere\n\nt is the time (s),\n\nz is the location in the vertical (m),\n\nρe_int is the volumetric internal energy of the soil (J/m^3),\n\nT is the temperature of the soil (K),\n\nκ is the thermal conductivity (W/m/K),\n\nρe_int_liq is the volumetric internal energy of liquid water (J/m^3),\n\nK is the hydraulic conductivity (m/s),\n\nh is the hydraulic head (m),\n\nϑ_l is the augmented volumetric liquid water fraction,\n\nθ_i is the volumetric ice fraction, and\n\nν  denotes parameters relating to soil type, such as porosity.\n\nWe will solve this equation in an effectively 1-d domain with z  -10, and with the following boundary and initial conditions:\n\n- κ T(t z = 0) = 0 ẑ\n\n-κ T(t z = -1) = 0 ẑ\n\nT(t = 0 z) = T_min + (T_max-T_min) e^Cz\n\n- K h(t z = 0) = 0 ẑ\n\n-K h(t z = -1) = 0 ẑ\n\nϑ(t = 0 z) = ϑ_min + (ϑ_max-ϑ_min) e^Cz\n\nwhere C T_min T_max ϑ_min and ϑ_max are constants.\n\nIf we evolve this system for times long compared to the dynamical timescales of the system, we expect it to reach an equilibrium where the LHS of these equations tends to zero. Assuming zero fluxes at the boundaries, the resulting equilibrium state should satisfy hz = 0 and Tz = 0. Physically, this means that the water settles into a vertical profile in which the resulting pressure balances gravity and that the temperature is constant across the domain.\n\nWe verify that the system is approaching this equilibrium, and we also sketch out an analytic calculation for the final temperature in equilibrium.","category":"section"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#Import-necessary-modules","page":"Energy and Hydrology","title":"Import necessary modules","text":"External (non - CliMA) modules\n\nimport SciMLBase\nusing Statistics\nusing Plots\n\nCliMA packages and ClimaLand modules\n\nusing ClimaCore\nimport ClimaParams as CP\nimport ClimaTimeSteppers as CTS\nusing ClimaLand\nusing ClimaLand.Domains: Column\nimport ClimaLand.Simulations: LandSimulation, solve!\nusing ClimaLand.Soil\n\nimport ClimaLand\nimport ClimaLand.Parameters as LP\n\nChoose a floating point precision, and get the parameter set, which holds constants used across CliMA models:\n\nFT = Float32\ntoml_dict = LP.create_toml_dict(FT);","category":"section"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#Create-the-model","page":"Energy and Hydrology","title":"Create the model","text":"Set the values of other parameters required by the model:\n\nν = FT(0.395);\n\nSoil solids are the components of soil besides water, ice, gases, and air. We specify the soil component fractions, relative to all soil solids. These do not sum to unity; the remainder is νssminerals (=0.08, in this case).\n\nν_ss_quartz = FT(0.92);\nν_ss_om = FT(0.0);\nν_ss_gravel = FT(0.0);\n\nOther parameters include the hydraulic conductivity at saturation, the specific storage, and the van Genuchten parameters for sand. We recommend Chapter 8 of Bonan [5] for finding parameters for other soil types.\n\nKsat = FT(4.42 / 3600 / 100) # m/s\nS_s = FT(1e-3) #inverse meters\nvg_n = FT(1.89)\nvg_α = FT(7.5) # inverse meters\nhydrology_cm = vanGenuchten{FT}(; α = vg_α, n = vg_n)\nθ_r = FT(0.0)\nparams = Soil.EnergyHydrologyParameters(\n    toml_dict;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm,\n    K_sat = Ksat,\n    S_s,\n    θ_r,\n);\n\nWe also need to pick a domain on which to solve the equations:\n\nzmax = FT(0)\nzmin = FT(-1.0)\nnelems = 50\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\n\nThe boundary value problem in this case requires a boundary condition at the top and the bottom of the domain for each equation being solved. We support conditions on the state (ϑ_l or T), or on the fluxes (-K∇h or -κ∇T). In the case of fluxes, we return the magnitude of the flux, assumed to point along ẑ. And, in each case, the boundary conditions are supplied in the form of a function of auxiliary variables p and time t.  Here we choose flux boundary conditions. The flux boundary condition requires a function of the cache and simulation time which returns the boundary flux.\n\nWater boundary conditions:\n\nsurface_water_flux = WaterFluxBC((p, t) -> 0.0)\nbottom_water_flux = WaterFluxBC((p, t) -> 0.0);\n\nThe boundary conditions for the heat equation:\n\nsurface_heat_flux = HeatFluxBC((p, t) -> 0.0)\nbottom_heat_flux = HeatFluxBC((p, t) -> 0.0);\n\nWe wrap up all of those in a WaterHeatBC struct:\n\nboundary_fluxes = (;\n    top = WaterHeatBC(; water = surface_water_flux, heat = surface_heat_flux),\n    bottom = WaterHeatBC(; water = bottom_water_flux, heat = bottom_heat_flux),\n);\n\nWe aren't using any sources or sinks in the equations here, but this is where freeze/thaw terms, runoff, root extraction, etc. would go.\n\nsources = ();\n\nLastly, we can create the EnergyHydrology model. As always, the model encodes and stores all of the information (parameters, continous equations, prognostic variables, etc) which are needed to turn the PDE system into a set of ODEs, properly spatially discretized for the domain of interest.\n\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n);\n\n\n\nfunction set_ic!(Y, p, t0, model)\n    params = model.parameters\n    z = model.domain.fields.z\n    ν = params.ν\n    θ_r = params.θ_r\n    FT = eltype(Y.soil.ϑ_l)\n    zmax = FT(0)\n    zmin = FT(-1)\n\n    theta_max = FT(ν * 0.5)\n    theta_min = FT(ν * 0.4)\n    T_max = FT(289.0)\n    T_min = FT(288.0)\n\n    c = FT(20.0)\n    @. Y.soil.ϑ_l =\n        theta_min +\n        (theta_max - theta_min) * exp(-(z - zmax) / (zmin - zmax) * c)\n    Y.soil.θ_i .= FT(0.0)\n\n    T = @.(T_min + (T_max - T_min) * exp(-(z - zmax) / (zmin - zmax) * c))\n\n    θ_l = Soil.volumetric_liquid_fraction.(Y.soil.ϑ_l, ν, θ_r)\n    ρc_s =\n        Soil.volumetric_heat_capacity.(\n            θ_l,\n            Y.soil.θ_i,\n            params.ρc_ds,\n            params.earth_param_set,\n        )\n    Y.soil.ρe_int .=\n        Soil.volumetric_internal_energy.(\n            Y.soil.θ_i,\n            ρc_s,\n            T,\n            params.earth_param_set,\n        )\nend\n\nset_ic! (generic function with 1 method)\n\nWe choose the initial and final simulation times:\n\nt0 = Float64(0)\ntf = Float64(60 * 60 * 72);\n\nWe use ClimaTimesteppers.jl for carrying out the time integration.\n\nChoose a timestepper and set up the ODE problem:\n\ndt = Float64(1000.0);\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\n\nBy default, it only returns Y and t at each time we request output (saveat, below). We use a callback in order to also get the auxiliary vector p back:\n\nsaveat = FT(30000)\ncb = ClimaLand.NonInterpSavingCallback(t0, tf, saveat);\nsaved_values = cb.affect!.saved_values;\nsimulation = LandSimulation(\n    t0,\n    tf,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    user_callbacks = (cb,),\n    diagnostics = (),\n);\n\n┌ Warning: Callback period (10800.0 seconds [counter = 10800, period = 1 second]) is not an integer multiple of dt 1000.0 seconds [counter = 1000, period = 1 second]\n└ @ ClimaLand ~/work/ClimaLand.jl/ClimaLand.jl/src/shared_utilities/utils.jl:753\n\n\nNow we can solve the problem.\n\nsol = solve!(simulation);\n\nExtract output\n\nz = parent(soil.domain.fields.z)\nt = parent(FT.(sol.t))\nϑ_l = [parent(sol.u[k].soil.ϑ_l) for k in 1:length(t)]\nT = [parent(saved_values.saveval[k].soil.T) for k in 1:length(t)];\n\nLet's look at the initial and final times:\n\nplot(\n    ϑ_l[1],\n    z,\n    xlabel = \"ϑ_l\",\n    ylabel = \"z (m)\",\n    label = \"t = 0d\",\n    title = \"Moisture Equilibration from t = 0d to t = 3d\",\n)\nplot!(ϑ_l[4], z, label = \"t = 1.5d\")\nplot!(ϑ_l[end], z, label = \"t = 3d\")\nsavefig(\"eq_moisture_plot.png\");\n\nGKS: cannot open display - headless operation mode active\n\n\n(Image: )\n\nplot(\n    T[1],\n    z,\n    xlabel = \"T (K)\",\n    ylabel = \"z (m)\",\n    label = \"t = 0d\",\n    title = \"Temperature Equilibration from t = 0d to t = 3d\",\n)\nplot!(T[4], z, xlabel = \"T (K)\", ylabel = \"z (m)\", label = \"t = 1.5d\")\nplot!(T[end], z, xlabel = \"T (K)\", ylabel = \"z (m)\", label = \"t = 3d\")\nsavefig(\"eq_temperature_plot.png\");\n\n(Image: )","category":"section"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#Analytic-Expectations","page":"Energy and Hydrology","title":"Analytic Expectations","text":"We can determine a priori what we expect the final temperature to be in equilibrium.\n\nRegardless of the final water profile in equilibrium, we know that the final temperature T_f will be a constant across the domain. All water that began with a temperature above this point will cool to T_f, and water that began with a temperature below this point will warm to T_f. The initial function T(z) is equal to T_f at a value of z = z̃. This is the location in space which divides these two groups (water that warms over time and water that cools over time) spatially. We can solve for z̃(T_f) using T_f = T(z̃).\n\nNext, we can determine the change in energy required to cool the water above z̃ to T_f: it is the integral from z̃ to the surface at z = 0 of c θ(z) T(z), where c is the volumetric heat capacity - a constant here - and θ(z) is the initial water profile. Compute the energy required to warm the water below z̃ to T_f in a similar way, set equal, and solve for T_f. This results in T_f = 288.056, which is very close to the mean T we observe after 3 days, of 288.054.\n\nOne could also solve the equation for ϑ_l specified by  h z = 0 to determine the functional form of the equilibrium profile of the liquid water.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/standalone/Soil/layered_soil/#Single-column-soil-model","page":"Layered Soil","title":"Single column soil model","text":"This shows how to run single column soil model, in standalone mode with spatially varying properties. We are mimicking the experiment carried out in Huang et al. [13], which measured the infiltration of layered soil in Fort McMurray, Alberta, Canada. We thank Mingbin Huang and S. Lee Barbour for correspondence and support, including sharing of data, with us. Note that all data used in this tutorial is available in their publication.\n\nusing Plots\nimport ClimaUtilities.SpaceVaryingInputs: SpaceVaryingInput\nimport SciMLBase\nimport ClimaTimeSteppers as CTS\nusing ClimaCore\nimport ClimaParams as CP\nusing DelimitedFiles: readdlm\n\nusing ClimaLand\nimport ClimaLand.Simulations: LandSimulation, solve!\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\nimport ClimaLand\nFT = Float64;\n\nDefine simulation times\n\nt0 = Float64(0)\ntf = Float64(60 * 60)\ndt = Float64(30);\n\nDefine the domain\n\nzmax = FT(0)\nzmin = FT(-1.1)\nnelems = 75\nΔ = FT((zmax - zmin) / nelems / 2)\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\n\nDownload the parameter data. This has been obtained from Table 1b of Infiltration and drainage processes in multi-layered coarse soils Huang et al. [13]\n\ndata_file = ClimaLand.Artifacts.huang_et_al2011_soil_van_genuchten_data();\nparameter_data = readdlm(data_file, ',');\n\nOur model treats z as increasing in the upwards direction. Values below the surface are negative. Because of this, we convert the (positive-valued) depth of the data into a monotonically increasing z coordinate value. using a negative sign and the reverse function.\n\ndepth = reverse(-parameter_data[1, :] .* 0.01) # convert to m\nksat = reverse(parameter_data[6, :] .* 1 / 100.0 / 60.0) # convert cm/min to m/s\nvgα = reverse(parameter_data[4, :] .* 100 * 2) # they report αᵈ; αʷ = 2αᵈ. This experiment is for infiltration (wetting).\nvgn = reverse(parameter_data[5, :])\nresidual_frac = reverse(parameter_data[2, :])\nporosity = reverse(parameter_data[3, :]);\n\nCreate fields corresponding to the parameter\n\nν = SpaceVaryingInput(depth, porosity, soil_domain.space.subsurface)\nK_sat = SpaceVaryingInput(depth, ksat, soil_domain.space.subsurface)\nθ_r = SpaceVaryingInput(depth, residual_frac, soil_domain.space.subsurface);\n\nThe specific storativity is not something we have data on, so we approximate it as being constant in depth, and create the parameter field directly:\n\nS_s = ClimaCore.Fields.zeros(soil_domain.space.subsurface) .+ 1e-3;\n\nThe retention model is a vanGenuchten model with α and n as a function of depth, read from the data:\n\nhcm = SpaceVaryingInput(\n    depth,\n    (; α = vgα, n = vgn),\n    soil_domain.space.subsurface,\n    vanGenuchten{FT},\n);\n\nThe parameter struct:\n\nparams = ClimaLand.Soil.RichardsParameters(;\n    ν = ν,\n    hydrology_cm = hcm,\n    K_sat = K_sat,\n    S_s = S_s,\n    θ_r = θ_r,\n);\n\nFrom here on out, everything should look familiar if you've already gone through the other soil tutorials. Set Boundary conditions: At the top, we use the observed value of Ksat at the top of the domain. Setting the flux to be -Ksat is approximating the top as saturated.\n\nfunction top_flux_function(p, t)\n    return -0.0001033\nend\ntop_bc = ClimaLand.Soil.WaterFluxBC(top_flux_function)\nbottom_bc = ClimaLand.Soil.FreeDrainage()\nboundary_fluxes = (; top = top_bc, bottom = bottom_bc)\nsoil = Soil.RichardsModel{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = (),\n);\n\ncreate function to initialize the state vectors\n\nfunction set_ic!(Y, p, t0, model)\n    Y.soil.ϑ_l .= 0.0353 # read from Figure 4 of Huang et al.\nend\n\nset_ic! (generic function with 1 method)\n\nTimestepping:\n\nstepper = CTS.ARS111()\n@assert FT in (Float32, Float64)\nerr = (FT == Float64) ? 1e-8 : 1e-4\nconvergence_cond = CTS.MaximumError(err)\nconv_checker = CTS.ConvergenceChecker(norm_condition = convergence_cond)\node_algo = CTS.IMEXAlgorithm(\n    stepper,\n    CTS.NewtonsMethod(\n        max_iters = 10,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n        convergence_checker = conv_checker,\n    ),\n)\nsaveat = [0.0, 8.0, 16.0, 24.0, 32.0, 40.0, 60.0] .* 60 # chosen to compare with data in plots in paper\nsimulation = LandSimulation(\n    t0,\n    tf,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    user_callbacks = (),\n    diagnostics = (),\n);\nsol = solve!(simulation);\n\nz = parent(ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z)\nϑ_l = [parent(sol.u[k].soil.ϑ_l) for k in 1:length(sol.t)]\nplot(ϑ_l[1], z, label = \"initial\", color = \"grey\", aspect_ratio = 0.8)\nplot!(ϑ_l[2], z, label = \"8min\", color = \"orange\")\nplot!(ϑ_l[3], z, label = \"16min\", color = \"red\")\nplot!(ϑ_l[4], z, label = \"24min\", color = \"teal\")\nplot!(ϑ_l[5], z, label = \"32min\", color = \"blue\")\nplot!(ϑ_l[6], z, label = \"40min\", color = \"purple\")\nplot!(ϑ_l[7], z, label = \"60min\", color = \"green\")\nscatter!(porosity, depth, label = \"Porosity\")\nplot!(legend = :bottomright)\n\nplot!(xlim = [0, 0.7])\n\nplot!(\n    ylim = [-1.1, 0],\n    yticks = [-1.1, -1, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1],\n)\n\nplot!(ylabel = \"Depth (m)\")\n\nplot!(xlabel = \"Volumeteric Water Content\")\n\nsavefig(\"./sv62_alpha_2_inf_updated_data_climaland.png\")\n\n\"/home/runner/work/ClimaLand.jl/ClimaLand.jl/docs/src/generated/standalone/Soil/sv62_alpha_2_inf_updated_data_climaland.png\"\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/canopy/Canopy/#Canopy","page":"Canopy Models","title":"Canopy","text":"","category":"section"},{"location":"APIs/canopy/Canopy/#Canopy-Model-and-Parameters","page":"Canopy Models","title":"Canopy Model and Parameters","text":"","category":"section"},{"location":"APIs/canopy/Canopy/#Canopy-Model-Boundary-Fluxes","page":"Canopy Models","title":"Canopy Model Boundary Fluxes","text":"","category":"section"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.CanopyModel","page":"Canopy Models","title":"ClimaLand.Canopy.CanopyModel","text":" CanopyModel{FT, AR, RM, PM, SM, SMSM, PHM, EM, SIFM, B, PS, D} <: ClimaLand.AbstractImExModel{FT}\n\nThe model struct for the canopy, which contains\n\nthe canopy model domain (a point for site-level simulations, or\n\nan extended surface (plane/spherical surface) for regional or global simulations.\n\nsubcomponent model type for radiative transfer. This is of type\n\nAbstractRadiationModel.\n\nsubcomponent model type for photosynthesis. This is of type\n\nAbstractPhotosynthesisModel and supports FarquharModel, and PModel.\n\nsubcomponent model type for stomatal conductance. This is of type\n\nAbstractStomatalConductanceModel and supports MedlynConductanceModel and  PModelConductance. Note if PModel is used for photosynthesis, then you  must also use PModelConductance for stomatal conductance, since these two models  are derived from the same set of conditions.\n\nsubcomponent model type for soil moisture stress. This is of type\n\nAbstractSoilMoistureStressModel. Currently we support TuzetMoistureStressModel (default)  PiecewiseMoistureStressModel, and NoMoistureStressModel (stress factor = 1).\n\nsubcomponent model type for plant hydraulics. This is of type\n\nAbstractPlantHydraulicsModel and currently only a version which prognostically solves Richards equation in the plant is available.\n\nsubcomponent model type for canopy energy. This is of type\n\nAbstractCanopyEnergyModel and currently we support a version where   the canopy temperature is prescribed, and one where it is solved for   prognostically.\n\nsubcomponent model type for canopy SIF. prognostically.\ncanopy model parameters, which include parameters that are shared\n\nbetween canopy model components or those needed to compute boundary fluxes.\n\nThe boundary conditions, which contain:\nThe atmospheric conditions, which are either prescribed (of type PrescribedAtmosphere) or computed via a coupled simulation (of type CoupledAtmosphere).\nThe radiative flux conditions, which are either prescribed (of type PrescribedRadiativeFluxes) or computed via a coupled simulation (of type CoupledRadiativeFluxes).\nThe ground conditions, which are either prescribed or prognostic\n\nNote that the canopy height is specified as part of the PlantHydraulicsModel, along with the area indices of the leaves, roots, and stems. Eventually, when plant biomass becomes a prognostic variable (by integrating with a carbon model), some parameters specified here will be treated differently.\n\nautotrophic_respiration: Autotrophic respiration model, a canopy component model\nradiative_transfer: Radiative transfer model, a canopy component model\nphotosynthesis: Photosynthesis model, a canopy component model\nconductance: Stomatal conductance model, a canopy component model\nsoil_moisture_stress: Soil moisture stress parameterization, a canopy component model\nhydraulics: Plant hydraulics model, a canopy component model\nenergy: Energy balance model, a canopy component model\nsif: SIF model, a canopy component model\nbiomass: Biomass parameterization, a canopy component model\nboundary_conditions: Boundary Conditions\nearth_param_set: Shared parameters between component models\ndomain: Canopy model domain\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.CanopyModel-Union{Tuple{}, Tuple{FT}} where FT","page":"Canopy Models","title":"ClimaLand.Canopy.CanopyModel","text":"CanopyModel{FT}(;\n    autotrophic_respiration::AbstractAutotrophicRespirationModel{FT},\n    radiative_transfer::AbstractRadiationModel{FT},\n    photosynthesis::AbstractPhotosynthesisModel{FT},\n    conductance::AbstractStomatalConductanceModel{FT},\n    soil_moisture_stress::AbstractSoilMoistureStressModel{FT},\n    hydraulics::AbstractPlantHydraulicsModel{FT},\n    energy::AbstractCanopyEnergyModel{FT},\n    sif::AbstractSIFModel{FT},\n    biomass::AbstractBiomassModel{FT},\n    boundary_conditions::B,\n    earth_param_set::PSE,\n    domain::Union{\n        ClimaLand.Domains.Point,\n        ClimaLand.Domains.Plane,\n        ClimaLand.Domains.SphericalSurface,\n    },\n    energy = PrescribedCanopyTempModel{FT}(),\n) where {FT, PSE}\n\nAn outer constructor for the CanopyModel. The primary constraints this applies are (1) ensuring that the domain is 1d or 2d (a ``surface\" domain of a column, box, or sphere) and (2) ensuring consistency between the PlantHydraulics model and the general canopy model, since these are built separately.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.CanopyModel-Union{Tuple{FT}, Tuple{Union{ClimaLand.Domains.Plane, ClimaLand.Domains.Point, ClimaLand.Domains.SphericalSurface}, NamedTuple, ClimaUtilities.TimeVaryingInputs.AbstractTimeVaryingInput, ClimaParams.ParamDict}} where FT","page":"Canopy Models","title":"ClimaLand.Canopy.CanopyModel","text":"function CanopyModel{FT}(\n    domain::Union{\n        ClimaLand.Domains.Point,\n        ClimaLand.Domains.Plane,\n        ClimaLand.Domains.SphericalSurface,\n    },\n    forcing::NamedTuple,\n    LAI::AbstractTimeVaryingInput,\n    toml_dict::CP.ParamDict;\n    prognostic_land_components = (:canopy,),\n    autotrophic_respiration = AutotrophicRespirationModel{FT}(toml_dict),\n    radiative_transfer = TwoStreamModel{FT}(domain, toml_dict),\n    photosynthesis = FarquharModel{FT}(domain, toml_dict),\n    conductance = MedlynConductanceModel{FT}(domain, toml_dict),\n    soil_moisture_stress = TuzetMoistureStressModel{FT}(toml_dict),\n    hydraulics = PlantHydraulicsModel{FT}(domain, toml_dict),\n    energy = BigLeafEnergyModel{FT}(toml_dict),\n    biomass= PrescribedBiomassModel{FT}(domain, LAI, toml_dict),\n    sif = Lee2015SIFModel{FT}(toml_dict),\n    turbulent_flux_parameterization = MoninObukhovCanopyFluxes(toml_dict, biomass.height),\n) where {FT, PSE}\n\nCreates a CanopyModel with the provided domain, forcing, and toml_dict.\n\nDefaults are provided for each canopy component model, which can be overridden by passing in a different instance of that type of model. Default parameters are also provided for each canopy component, and can be changed with keyword arguments. Please see the documentation of each component model for details on the default parameters.\n\nThe required argument forcing should be a NamedTuple with the following field:\n\natmos: a PrescribedAtmosphere or CoupledAtmosphere object\nradiation: a PrescribedRadiativeFluxes or CoupledRadiativeFluxes object\nground: a PrescribedGroundConditions or PrognosticGroundConditions object\n\nThe required argument LAI should be a ClimaUtilities.TimeVaryingInputs.TimeVaryingInput for leaf area index.\n\nWhen running the canopy model in standalone mode, set prognostic_land_components = (:canopy,), while for running integrated land models, this should be a list of the individual models. This value of this argument must be the same across all components in the land model.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.AbstractCanopyComponent","page":"Canopy Models","title":"ClimaLand.Canopy.AbstractCanopyComponent","text":"AbstractCanopyComponent{FT <: AbstractFloat}\n\nAn abstract type for canopy component parameterizations.\n\nCanopy component parameterizations do not run in standalone mode, but only as part of a CanopyModel. As such, they do not require all of the functionality of AbstractModels,  and they are not AbstractModels themselves. The CanopyModel is an AbstractModel.\n\nHowever, some of the same functionality is nice to have for canopy components, especially when defining the variables, which is why we introduce the AbstractCanopyComponent type and extend many of the methods for ClimaLand.AbstractModels for the canopy component parameterizations.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.AbstractCanopyBC","page":"Canopy Models","title":"ClimaLand.Canopy.AbstractCanopyBC","text":"AbstractCanopyBC <: ClimaLand.AbstractBC\n\nAn abstract type for boundary conditions for the canopy model.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.AtmosDrivenCanopyBC","page":"Canopy Models","title":"ClimaLand.Canopy.AtmosDrivenCanopyBC","text":"AtmosDrivenCanopyBC{\n    A <: AbstractAtmosphericDrivers,\n    B <: AbstractRadiativeDrivers,\n    G <: AbstractGroundConditions,\n    R <: AbstractCanopyFluxParameterization,\n    C::Tuple\n} <: AbstractCanopyBC\n\nA struct used to specify the canopy fluxes, referred to as \"boundary conditions\", at the surface and bottom of the canopy, for water and energy.\n\nThese fluxes include turbulent surface fluxes computed with Monin-Obukhov theory, radiative fluxes, and root extraction.\n\natmos: The atmospheric conditions driving the model\nradiation: The radiative fluxes driving the model\nground: Ground conditions\nturbulent_flux_parameterization: Turbulent flux (latent, sensible, vapor, and momentum) parameterization\nprognostic_land_components: Prognostic land components present\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.MoninObukhovCanopyFluxes","page":"Canopy Models","title":"ClimaLand.Canopy.MoninObukhovCanopyFluxes","text":"MoninObukhovCanopyFluxes{FT, F <: Union{FT, ClimaCore.Fields.Field}} <: AbstractCanopyFluxParameterization{FT}\n\nA parameterization specifying how to compute latent and sensible heat fluxes between the atmosphere and the canopy based on Monin-Obukhov Surface Theory.\n\nYou must specify\n\na minimum roughness length (global constant)\nthe roughness length for momentum (can be a constant or a field)\nthe roughness length for scalars (can be a constant or a field)\nthe displacement height (can be a constant or a field)\nthe leaf-level drag coefficient (unitless)\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/SolarInducedFluorescence/#Solar-Induced-Fluorescence","page":"Solar Induced Fluorescence","title":"Solar Induced Fluorescence","text":"","category":"section"},{"location":"APIs/canopy/SolarInducedFluorescence/#Models-and-Parameters","page":"Solar Induced Fluorescence","title":"Models and Parameters","text":"","category":"section"},{"location":"APIs/canopy/SolarInducedFluorescence/#Methods","page":"Solar Induced Fluorescence","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/SolarInducedFluorescence/#ClimaLand.Canopy.Lee2015SIFModel","page":"Solar Induced Fluorescence","title":"ClimaLand.Canopy.Lee2015SIFModel","text":"Lee2015SIFModel{FT, SP <: SIFParameters{FT}} <: AbstractSIFModel{FT}\n\nLee2015SIFModel struct containing the parameters needed to compute the SIF parameterization described in: Lee et al, 2015. Global Change Biology 21, 3469-3477, doi:10.1111/gcb.12948.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/SolarInducedFluorescence/#ClimaLand.Canopy.SIFParameters","page":"Solar Induced Fluorescence","title":"ClimaLand.Canopy.SIFParameters","text":"SIFParameters{FT<:AbstractFloat}\n\nThe required parameters for the SIF parameterisation  Lee et al, 2015. Global Change Biology 21, 3469-3477, doi:10.1111/gcb.12948.\n\nkf: The rate coefficient for florescence, unitless\nkd_p1: Parameter used to compute the rate coefficient for heat loss in dark-adapted conditions, Tol et al. 2014, unitless\nkd_p2: Parameter used to compute the rate coefficient for heat loss in dark-adapted conditions, Tol et al. 2014, unitless\nmin_kd: Parameter used to compute the rate coefficient for heat loss in dark-adapted conditions, Tol et al. 2014, unitless\nkn_p1: Parameter used to compute the rate coefficient for heat loss in light-adapted conditions, Lee et al 2013 (unitless)\nkn_p2: Parameter used to compute the rate coefficient for heat loss in light-adapted conditions, Lee et al 2013 (unitless)\nkp: Rate coefficient for photochemical quenching\nkappa_p1: Slope of line relating leaf-level fluorescence to spectrometer-observed fluorescence as a function of Vcmax 25 (leaf level). Lee et al 2015.\nkappa_p2: Intercept of line relating leaf-level fluorescence to spectrometer-observed fluorescence as a function of Vcmax 25 (leaf level).  Lee et al 2015.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/SolarInducedFluorescence/#ClimaLand.Canopy.Lee2015SIFModel-Union{Tuple{ClimaParams.ParamDict}, Tuple{FT}} where FT","page":"Solar Induced Fluorescence","title":"ClimaLand.Canopy.Lee2015SIFModel","text":"Lee2015SIFModel{FT}(toml_dict::CP.ParamDict) where {FT}\n\nConstructs the Lee2015SIFModel from the toml_dict using the parameters in the toml_dict.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/SolarInducedFluorescence/#ClimaLand.Canopy.update_SIF!","page":"Solar Induced Fluorescence","title":"ClimaLand.Canopy.update_SIF!","text":"update_SIF!(p, Y, sif_model::Lee2015SIFModel, canopy)\n\nUpdates observed SIF at 755 nm in W/m^2. Note that Tc is in Kelvin, and photo synthetic rates are in mol/m^2/s, and APAR is in PPFD. Lee et al, 2015. Global Change Biology 21, 3469-3477, doi:10.1111/gcb.12948\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/SolarInducedFluorescence/#ClimaLand.Canopy.compute_SIF_at_a_point","page":"Solar Induced Fluorescence","title":"ClimaLand.Canopy.compute_SIF_at_a_point","text":"compute_SIF_at_a_point(\n    APAR_canopy_moles::FT,\n    Tc::FT,\n    Vcmax25_leaf::FT,\n    J_over_Jmax::FT,\n    T_freeze::FT,\n    sif_parameters::SIFParameters{FT},\n) where {FT}\n\nComputes the Solar Induced Fluorescence (SIF) at 755 nm in W/m^2 using the Lee et al. 2015 model. This takes as parameters APAR (absorbed photosynthetically active radiation, mol/m^2/s), Tc (canopy temperature, K), Vcmax25 (maximum carboxylation rate at 25 °C, mol/m^2/s), Jmax (electron transport rate, mol/m^2/s), J (electron transport rate, mol/m^2/s), T_freeze  (freezing temperature, K), sif_parameters (SIF parameters). \n\n\n\n\n\n","category":"function"},{"location":"standalone/pages/vegetation/autotrophic_respiration/jules_model/#Autotrophic-Respiration","page":"JULES model","title":"Autotrophic Respiration","text":"This page documents the autotrophic respiration model by Clark et al. [30], used in the JULES model. The ClimaLand code can be found here.\n\n","category":"section"},{"location":"standalone/pages/vegetation/autotrophic_respiration/jules_model/#Model-formulation","page":"JULES model","title":"Model formulation","text":"Autotrophic respiration of the canopy is partitioned into maintenance and growth components. At the canopy level, the respiration flux (mol CO_2 m^-2 s^-1) is\n\nR_a = Bigl(R_pm + R_gBigr) frac1 - expleft(-K  LAI  Omegaright)K  Omega\n\nwhere R_pm is the maintenance respiration (mol CO_2 m^-2 s^-1), R_g is the growth respiration (mol CO_2 m^-2 s^-1), K is the canopy extinction coefficient (–), LAI is the leaf area index (m^2 leaf m^-2 ground), and Omega is a clumping factor (–).\n\n","category":"section"},{"location":"standalone/pages/vegetation/autotrophic_respiration/jules_model/#Nitrogen-allocation","page":"JULES model","title":"Nitrogen allocation","text":"Nitrogen is distributed among leaves, roots, and stems according to\n\nS_c = eta_sl h LAI  H(SAI) qquad\nR_c = sigma_l  RAI\n\nn_m = fracVc_max25n_e qquad\nN_l = n_m  sigma_l  LAI qquad\nN_r = mu_r  n_m  R_c qquad\nN_s = mu_s  n_m  S_c\n\nwhere:\n\nH is the Heaviside function (–),\n\nVc_max25 is the leaf-level maximum carboxylation rate at 25 °C (mol CO_2 m^-2 s^-1),\n\nn_e is the conversion factor from Vc_max25 to nitrogen (mol CO_2 m^-2 s^-1 kg C^-1),\n\neta_sl is the live stem wood coefficient (kg C m^-3),\n\nh is the canopy height (m),\n\nsigma_l is the specific leaf density (kg C m^-2 leaf),\n\nmu_r is the root-to-leaf nitrogen ratio (–),\n\nmu_s is the stem-to-leaf nitrogen ratio (–),\n\nN_l N_r N_s are the nitrogen contents in leaves, roots, and stems (kg N m^-2 ground),\n\nS_c is the stem carbon pool (kg C m^-2 ground),\n\nR_c is the root carbon pool (kg C m^-2 ground),\n\nn_m is the nitrogen per unit carboxylation capacity (kg N mol^-1 CO_2 m^2 s).\n\n","category":"section"},{"location":"standalone/pages/vegetation/autotrophic_respiration/jules_model/#Maintenance-respiration","page":"JULES model","title":"Maintenance respiration","text":"R_pm = R_d Bigl(beta + fracN_r + N_smax(N_l  epsilon)Bigr)\n\nwhere R_d is a base respiration rate (mol CO_2 m^-2 s^-1), beta is a parameter scaling leaf respiration (–), and epsilon is machine epsilon (–) for numerical stability.\n\n","category":"section"},{"location":"standalone/pages/vegetation/autotrophic_respiration/jules_model/#Growth-respiration","page":"JULES model","title":"Growth respiration","text":"R_g = R_el  Bigl(A_n - R_pmBigr)\n\nwhere R_el is the relative contribution of growth respiration (–), and A_n is the net assimilation rate (mol CO_2 m^-2 s^-1).\n\n","category":"section"},{"location":"standalone/pages/vegetation/autotrophic_respiration/jules_model/#Notes","page":"JULES model","title":"Notes","text":"This formulation follows the approach used in large-scale ecosystem models such as JULES (Clark et al., 2011).\nGrowth respiration is proportional to net assimilation after subtracting maintenance costs.\nMaintenance respiration scales with tissue nitrogen pools.","category":"section"},{"location":"generated/standalone/Soil/boundary_conditions/#Boundary-conditions-for-the-soil-model","page":"Boundary conditions","title":"Boundary conditions for the soil model","text":"In general, you must supply two boundary conditions for each PDE being solved. These are passed to the model as a NamedTuple of the form (; top = top_bc, bottom = bottom_bc), where both top_bc and bottom_bc are of type ClimaLand.AbstractBC.\n\nFlux boundary conditions are always passed as the (scalar) z-component of the flux f, i.e. F⃗ = f ẑ.","category":"section"},{"location":"generated/standalone/Soil/boundary_conditions/#Boundary-conditions-for-Richards-equation","page":"Boundary conditions","title":"Boundary conditions for Richards equation","text":"FreeDrainage <: AbstractWaterBC: this only can be used at the bottom of the domain.\nWaterFluxBC <: AbstractWaterBC: this accepts a prescribed analytic function of the cache p and simulation time t which returns the flux value. e.g: WaterFluxBC((p,t) -> 0.0).\nMoistureStateBC <: AbstractWaterBC: this accepts a prescribed analytic function of the cache p and simulation time t which returns the value of ϑ_l at the boundary . e.g: MoistureStateBC((p,t) -> 0.2).\nRichardsAtmosDrivenFluxBC <: AbstractWaterBC: this requires a single argument of abstract type AbstractTimeVaryingInput. Under the hood, this specifies the precipitation as a function of space and time (using data read in from a file, or an analytic function) and applies this a flux BC, optionally accounting for surface/subsurface runoff.","category":"section"},{"location":"generated/standalone/Soil/boundary_conditions/#Boundary-conditions-for-the-soil-heat-equation","page":"Boundary conditions","title":"Boundary conditions for the soil heat equation","text":"HeatFluxBC <: AbstractHeatBC: this accepts a prescribed analytic function of the cache p and simulation time t which returns the flux value. e.g: HeatFluxBC((p,t) -> 0.0).\nTemperatureStateBC <: AbstractHeatBC: this accepts a prescribed analytic function of the cache p and simulation time t which returns the value of T at the boundary . e.g: TemperatureStateBC((p,t) -> 273.15).","category":"section"},{"location":"generated/standalone/Soil/boundary_conditions/#Boundary-conditions-for-the-soil-heat-water-equations-(EnergyHydrology-model)","page":"Boundary conditions","title":"Boundary conditions for the soil heat + water equations (EnergyHydrology model)","text":"The full soil model requires boundary conditions for both Richards equation and the soil heat equation.\n\nWaterHeatBC <: AbstractEnergyHydrologyBC: In many cases, the two boundary conditions can be treated independently. The WaterHeatBC requires a boundary condition of abstract type AbstractWaterBC and one of type AbstractHeatBC, for example, top = WaterHeatBC(; water = MoistureBC(ϑ_l(p,t)), heat = TemperatureBC(T(p,t))).\nAtmosDrivenFluxBC <: AbstractEnergyHydrologyBC: This is an example of a set of boundary conditions for the full soil model which cannot be decomposed into two independent boundary conditions for water and heat. In this case, we compute the turbulent surface fluxes with the atmosphere, obtaining a sensible heat, latent heat, and water vapor flux. We also take into account the net radiation at the surface and any precipitation or runoff. This is the BC type used in most land simulations.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/integrated/soil_canopy_fluxnet_tutorial/#Fluxnet-simulations-with-an-integrated-soil-and-canopy-model","page":"Canopy and soil","title":"Fluxnet simulations with an integrated soil and canopy model","text":"In the standalone canopy tutorial, we demonstrated how to run the canopy model in standalone mode using a prescribed soil moisture and ground temperature. ClimaLand can also integrate the canopy model with a prognostic soil model and timestep the two components together to simulate an interacting canopy-soil system. This tutorial demonstrates how to set that up. We use initial conditions, atmospheric and radiative flux conditions, and leaf area index observed at the US-MOz flux tower, a flux tower located within an oak-hickory forest in Ozark, Missouri, USA. The forcing data was obtained from AmeriFlux FLUXNET Wood and Gu [22]\n\nThe focus of this tutorial is to learn the steps towards setting up and running an integrated simulation, and less on the parameterization choices. As such, the default parameters are implicitly set. To experiment with modularity in the parameters and parameterizations, please see the canopy parameterizations tutorial or the soil parameterizations tutorial.","category":"section"},{"location":"generated/integrated/soil_canopy_fluxnet_tutorial/#Preliminary-Setup","page":"Canopy and soil","title":"Preliminary Setup","text":"using Dates\nimport ClimaParams as CP\nusing ClimaDiagnostics\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Simulations\nimport ClimaLand.Parameters as LP\nusing DelimitedFiles\nimport ClimaLand.FluxnetSimulations as FluxnetSimulations\nusing CairoMakie, ClimaAnalysis, GeoMakie, Printf, StatsBase\nimport ClimaLand.LandSimVis as LandSimVis;\n\nDefine the floating point precision desired (64 or 32 bit), and get the parameter set holding constants used across CliMA Models.\n\nconst FT = Float32;\ntoml_dict = LP.create_toml_dict(FT);\n\nWe will use prescribed atmospheric and radiative forcing from the US-MOz tower.\n\nsite_ID = \"US-MOz\";\nsite_ID_val = FluxnetSimulations.replace_hyphen(site_ID);\n\nGet the latitude and longitude in degrees, as well as the time offset in hours of local time from UTC\n\n(; time_offset, lat, long) =\n    FluxnetSimulations.get_location(FT, Val(site_ID_val));\n\nGet the height of the sensors in m\n\n(; atmos_h) = FluxnetSimulations.get_fluxtower_height(FT, Val(site_ID_val));\n\nSetup the domain for the model. This corresponds to a column of 2m in depth, with 10 equally spaced layers. The lat and long are provided so that we can look up default parameters for this location using the default ClimaLand parameter maps.\n\nzmin = FT(-2) # in m\nzmax = FT(0) # in m\ndomain = Column(; zlim = (zmin, zmax), nelements = 10, longlat = (long, lat));\n\nSet a start and stop date of the simulation in UTC, as well as a timestep in seconds\n\nstart_date = DateTime(\"2010-05-01\", \"yyyy-mm-dd\")\nstop_date = DateTime(\"2010-09-01\", \"yyyy-mm-dd\")\nΔt = 450.0;\n\nForcing data for the site - this uses our interface for working with Fluxnet data\n\nforcing = FluxnetSimulations.prescribed_forcing_fluxnet(\n    site_ID,\n    lat,\n    long,\n    time_offset,\n    atmos_h,\n    start_date,\n    toml_dict,\n    FT,\n);\n\nLAI for the site - this uses our interface for working with MODIS data.\n\nLAI = ClimaLand.Canopy.prescribed_lai_modis(\n    domain.space.surface,\n    start_date,\n    stop_date,\n);","category":"section"},{"location":"generated/integrated/soil_canopy_fluxnet_tutorial/#Setup-the-integrated-model","page":"Canopy and soil","title":"Setup the integrated model","text":"We want to simulate the canopy-soil system together, so we pick the  model type SoilCanopyModel Here we use the highest level model constructor, which uses default parameters, and parameterizations, for the soil and canopy models.\n\nland_model = SoilCanopyModel{FT}(forcing, LAI, toml_dict, domain);\nset_ic! = FluxnetSimulations.make_set_fluxnet_initial_conditions(\n    site_ID,\n    start_date,\n    time_offset,\n    land_model,\n);\noutput_vars = [\"gpp\", \"swu\", \"lwu\", \"shf\", \"lhf\"]\ndiagnostics = ClimaLand.default_diagnostics(\n    land_model,\n    start_date;\n    output_writer = ClimaDiagnostics.Writers.DictWriter(),\n    output_vars,\n    reduction_period = :hourly,\n);\n\nChoose how often we want to update the forcing.\n\ndata_dt = Second(FluxnetSimulations.get_data_dt(site_ID));\n\nNow we can construct the simulation object and solve it.\n\nsimulation = Simulations.LandSimulation(\n    start_date,\n    stop_date,\n    Δt, # seconds\n    land_model;\n    set_ic!,\n    updateat = Second(data_dt),\n    user_callbacks = (),\n    diagnostics,\n);\nsolve!(simulation);\n\nWe can optionally save the simulation parameters to a file for later reference. Here we specify the filepath where we want to save the parameters, and then ClimaParams handles the saving. Note that any parameters overwritten via keyword arguments when constructing models will not be reflected in this file (in this example there are none).\n\nparameter_log_file = \"soil_canopy_fluxnet_parameters.toml\"\nCP.log_parameter_information(toml_dict, parameter_log_file)\n\n┌ Warning: Keys are present in parameter file but not used in the simulation. \n│  Typically this is due to a mismatch in parameter name in toml and in source. Offending keys: Any[\"beta_min\", \"bucket_z_0m\", \"pmodel_Ha_Vcmax\", \"pmodel_ϕ0_c3\", \"z0\", \"pmodel_ϕ0_c4\", \"pmodel_ϕa1_c4\", \"pmodel_bRd\", \"bucket_z_0b\", \"critical_snow_fraction\", \"alpha_0\", \"moisture_stress_c\", \"x0\", \"pmodel_oi\", \"delta_S\", \"bucket_beta_decay_exponent\", \"bucket_capacity_fraction\", \"pmodel_ΔHko\", \"k\", \"alpha_snow\", \"pmodel_α\", \"pmodel_ΔHkc\", \"pmodel_aRd\", \"pmodel_ϕa0_c3\", \"pmodel_Kc25\", \"pmodel_ϕa2_c4\", \"pmodel_Hd_Vcmax\", \"pmodel_Γstar25\", \"pmodel_ϕa1_c3\", \"pmodel_Ha_Jmax\", \"delta_alpha\", \"pmodel_Hd_Jmax\", \"pmodel_aS_Vcmax\", \"pmodel_bS_Vcmax\", \"bucket_soil_conductivity\", \"pmodel_aS_Jmax\", \"critical_snow_water_equivalent\", \"pmodel_fC3\", \"pmodel_cstar\", \"pmodel_ΔHΓstar\", \"beta_0\", \"pmodel_bS_Jmax\", \"pmodel_ϕa2_c3\", \"land_bucket_capacity\", \"bucket_soil_heat_capacity\", \"pmodel_Ko25\", \"beta\", \"pmodel_β\", \"pmodel_ϕa0_c4\", \"gamma\"]\n└ @ ClimaParams ~/.julia/packages/ClimaParams/FGt0m/src/ClimaParams.jl:370\n","category":"section"},{"location":"generated/integrated/soil_canopy_fluxnet_tutorial/#Plotting-results,-ignoring-the-first-20-days-as-spinup","page":"Canopy and soil","title":"Plotting results, ignoring the first 20 days as spinup","text":"LandSimVis.make_diurnal_timeseries(\n    simulation;\n    short_names = [\"gpp\", \"shf\", \"lhf\", \"swu\", \"lwu\"],\n    spinup_date = start_date + Day(20),\n    plot_stem_name = \"US_MOz_diurnal_timeseries\",\n);\n\n(Image: ) (Image: ) (Image: ) (Image: ) (Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"standalone/pages/vegetation/canopy_energy/canopy_energy/#Canopy-Energy-Balance-(Bigleaf)","page":"Physics","title":"Canopy Energy Balance (Bigleaf)","text":"This page documents the canopy energy module used in ClimaLand’s vegetation standalone runs. The ClimaLand code can be found here.\n\n","category":"section"},{"location":"standalone/pages/vegetation/canopy_energy/canopy_energy/#Prognostic-canopy-temperature","page":"Physics","title":"Prognostic canopy temperature","text":"The canopy temperature is modeled prognostically. Its time tendency is given by\n\nfracdT_cdt =\nfrac\n    LW_n + SW_n - (mathrmSHF + mathrmLHF) + F_mathrmroots\n\n    a_c cdot max(A_mathrmleaf + A_mathrmstem epsilon)\n\n\nwhere\n\nT_c is the canopy temperature (K),\n\nLW_n is the net long-wave radiation (W m^-2), positive if increasing canopy energy,\n\nSW_n is the net short-wave radiation (W m^-2), positive if increasing canopy energy\n\nmathrmSHF is the sensible heat flux (W m^-2), positive if decreasing canopy energy,\n\nmathrmLHF is the latent heat flux (W m^-2), positive if decreasing canopy energy,\n\nF_mathrmroots is the energy flux associated with root–soil water transport (W m^-2), positive if increasing canopy energy,\n\na_c is the canopy heat capacity per unit area (J m^-2 K^-1),\n\nA_mathrmleaf and A_mathrmstem are the leaf and stem area indices (–),\n\nand epsilon is the machine epsilon for numerical stability.\n\n","category":"section"},{"location":"standalone/pages/vegetation/canopy_energy/canopy_energy/#Root-energy-flux","page":"Physics","title":"Root energy flux","text":"In standalone mode with prescribed ground conditions, this flux is set to zero.\nIn coupled runs with a prognostic soil model, the flux is included to conserve energy, since the soil model accounts for the energy in soil water.\n\n","category":"section"},{"location":"APIs/canopy/Biomass/#Biomass","page":"Leaf, stem, root dynamics","title":"Biomass","text":"","category":"section"},{"location":"APIs/canopy/Biomass/#Parameterizations","page":"Leaf, stem, root dynamics","title":"Parameterizations","text":"","category":"section"},{"location":"APIs/canopy/Biomass/#ClimaLand.Canopy.PrescribedBiomassModel","page":"Leaf, stem, root dynamics","title":"ClimaLand.Canopy.PrescribedBiomassModel","text":"struct PrescribedBiomassModel{FT, PSAI <: PrescribedAreaIndices, RDTH <: Union{FT, ClimaCore.Fields.Field}} <: AbstractBiomassModel{FT}\n\nA prescribed biomass model where LAI, SAI, RAI, rooting depth, and height are prescribed.\n\nIn  global run with patches of bare soil, you can \"turn off\" the canopy model (to get zero root extraction, zero absorption and emission, zero transpiration and sensible heat flux from the canopy), by setting:\n\nn_leaf = 1\nn_stem = 0\nLAI = SAI = RAI = 0.\n\nIf run with PlantHydraulics, this must be consistent with the plant hydraulics model:a  plant model can have leaves but no stem, but not vice versa. If n_stem = 0, SAI must be zero.\n\nplant_area_index: The plant area index model for LAI, SAI, RAI\nrooting_depth: Rooting depth parameter (m) - a characteristic depth below which 1/e of the root mass lies\nheight: Canopy height, currently treated as a scalar\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Biomass/#ClimaLand.Canopy.PrescribedBiomassModel-Union{Tuple{FT}, Tuple{Any, ClimaUtilities.TimeVaryingInputs.AbstractTimeVaryingInput, ClimaParams.ParamDict}} where FT<:AbstractFloat","page":"Leaf, stem, root dynamics","title":"ClimaLand.Canopy.PrescribedBiomassModel","text":"PrescribedBiomassModel{FT}(\n    domain,\n    LAI::AbstractTimeVaryingInput,\n    toml_dict::CP.ParamDict;\n    SAI::FT = toml_dict[\"SAI\"],\n    RAI::FT = toml_dict[\"RAI\"],\n    rooting_depth = clm_rooting_depth(domain.space.surface),\n    height = toml_dict[\"canopy_height\"]\n) where {FT <: AbstractFloat}\n\nCreates a PrescribedBiomassModel on the provided domain, using parameters from toml_dict.\n\nThe required argument LAI should be a ClimaUtilities TimeVaryingInput for leaf area index.\n\nThe following default parameters are used:\n\nSAI = 0 (m2/m2) - stem area index\nRAI = 1 (m2/m2) - root area index\nheight = 1m\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/Biomass/#ClimaLand.Canopy.PrescribedBiomassModel-Union{Tuple{}, Tuple{FT}} where FT","page":"Leaf, stem, root dynamics","title":"ClimaLand.Canopy.PrescribedBiomassModel","text":"PrescribedBiomassModel{FT}(;LAI::AbstractTimeVaryingInput,\n                            SAI::FT,\n                            RAI::FT,\n                            rooting_depth,\n                            height::FT) where {FT}\n\nAn outer constructor to help set up the PrescribedBiomassModel from  LAI, SAI, and RAI directly, instead of requiring the user to make the area index object first; rooting_depth and height are also required.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/Biomass/#ClimaLand.Canopy.PrescribedAreaIndices","page":"Leaf, stem, root dynamics","title":"ClimaLand.Canopy.PrescribedAreaIndices","text":"PrescribedAreaIndices{FT <:AbstractFloat, F <: AbstractTimeVaryingInput}\n\nA struct containing the area indices of the plants at a specific site; LAI varies in time, while SAI and RAI are fixed in space and time.\n\nLAI: A function of simulation time t giving the leaf area index (LAI; m2/m2)\nSAI: The constant stem area index (SAI; m2/m2)\nRAI: The constant root area index (RAI; m2/m2)\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Biomass/#ClimaLand.Canopy.PrescribedAreaIndices-Union{Tuple{FT}, Tuple{ClimaUtilities.TimeVaryingInputs.AbstractTimeVaryingInput, FT, FT}} where FT<:AbstractFloat","page":"Leaf, stem, root dynamics","title":"ClimaLand.Canopy.PrescribedAreaIndices","text":"PrescribedAreaIndices{FT}(\n    LAI::AbstractTimeVaryingInput,\n    SAI::FT,\n    RAI::FT,\n) where {FT <: AbstractFloat}\n\nAn outer constructor for setting the PrescribedAreaIndices given LAI, SAI, and RAI.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/Biomass/#ClimaLand.Canopy.prescribed_lai_era5","page":"Leaf, stem, root dynamics","title":"ClimaLand.Canopy.prescribed_lai_era5","text":" prescribed_lai_era5(era5_lai_ncdata_path,\n                     era5_lai_cover_ncdata_path,\n                     surface_space,\n                     start_date,\n                     earth_param_set;\n                     time_interpolation_method = LinearInterpolation(PeriodicCalendar()),\n                     regridder_type = :InterpolationsRegridder,\n                     interpolation_method = Interpolations.Constant(),)\n\nA helper function which constructs the TimeVaryingInput object for Leaf Area Index, from a file path pointing to the ERA5 LAI data in a netcdf file, a file path pointing to the ERA5 LAI cover data in a netcdf file, the surfacespace, the start date, and the earthparam_set.\n\nThis currently one works when a single file is passed for both the era5 lai and era5 lai cover data.\n\nThe ClimaLand default is to use nearest neighbor interpolation, but linear interpolation is supported by passing interpolation_method = Interpolations.Linear().\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Biomass/#ClimaLand.Canopy.prescribed_lai_modis","page":"Leaf, stem, root dynamics","title":"ClimaLand.Canopy.prescribed_lai_modis","text":" prescribed_lai_modis(surface_space,\n                      start_date\n                      stop_date,\n                      earth_param_set;\n                      time_interpolation_method = LinearInterpolation(),\n                      regridder_type = :InterpolationsRegridder,\n                      interpolation_method = Interpolations.Constant(),\n                      modis_lai_ncdata_path = nothing,\n                      context = ClimaComms.context(surface_space))\n\nA helper function which constructs the TimeVaryingInput object for Leaf Area Index using MODIS LAI data; requires the surfacespace, the start and stop dates, and the earthparam_set.\n\nThe ClimaLand default is to use nearest neighbor interpolation, but linear interpolation is supported by passing interpolation_method = Interpolations.Linear().\n\nIf modis_lai_ncdata_path is provided, it will be used directly. Otherwise, the path will be inferred from the start and stop dates.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/StomatalConductance/#Stomatal-Conductance","page":"Stomatal Conductance","title":"Stomatal Conductance","text":"","category":"section"},{"location":"APIs/canopy/StomatalConductance/#Models-and-Parameters","page":"Stomatal Conductance","title":"Models and Parameters","text":"","category":"section"},{"location":"APIs/canopy/StomatalConductance/#Methods","page":"Stomatal Conductance","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.MedlynConductanceModel","page":"Stomatal Conductance","title":"ClimaLand.Canopy.MedlynConductanceModel","text":"MedlynConductanceModel{FT}(\n    domain,\n    toml_dict::CP.ParamDict;\n    g0::FT = toml_dict[\"min_stomatal_conductance\"],\n    g1 = clm_medlyn_g1(domain.space.surface),\n) where {FT <: AbstractFloat}\n\nCreates a MedlynConductanceModel using default parameters of type FT.\n\nThe conductance_parameters argument is a NamedTuple that contains\n\ng1: a Float or ClimaCore Field representing the slope parameter (PA^{1/2})\n\nBy default, this parameter is set by the clm_medlyn_g1 function, which reads in CLM data onto the surface space as a ClimaUtilities SpaceVaryingInput.\n\nThe following default parameter is used:\n\ng0 = FT(1e-4) (mol m^-2 s^-1) - minimum stomatal conductance\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.MedlynConductanceModel-Union{Tuple{FT}, Tuple{Any, ClimaParams.ParamDict}} where FT<:AbstractFloat","page":"Stomatal Conductance","title":"ClimaLand.Canopy.MedlynConductanceModel","text":"MedlynConductanceModel{FT}(\n    domain,\n    toml_dict::CP.ParamDict;\n    g0::FT = toml_dict[\"min_stomatal_conductance\"],\n    g1 = clm_medlyn_g1(domain.space.surface),\n) where {FT <: AbstractFloat}\n\nCreates a MedlynConductanceModel using default parameters of type FT.\n\nThe conductance_parameters argument is a NamedTuple that contains\n\ng1: a Float or ClimaCore Field representing the slope parameter (PA^{1/2})\n\nBy default, this parameter is set by the clm_medlyn_g1 function, which reads in CLM data onto the surface space as a ClimaUtilities SpaceVaryingInput.\n\nThe following default parameter is used:\n\ng0 = FT(1e-4) (mol m^-2 s^-1) - minimum stomatal conductance\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.MedlynConductanceParameters","page":"Stomatal Conductance","title":"ClimaLand.Canopy.MedlynConductanceParameters","text":"MedlynConductanceParameters{FT <: AbstractFloat}\n\nThe required parameters for the Medlyn stomatal conductance model.\n\nDrel: Relative diffusivity of water vapor (unitless)\ng0: Minimum stomatal conductance mol/m^2/s\ng1: Slope parameter, inversely proportional to the square root of marginal water use efficiency (Pa^{1/2})\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.MedlynConductanceParameters-Tuple{ClimaParams.ParamDict}","page":"Stomatal Conductance","title":"ClimaLand.Canopy.MedlynConductanceParameters","text":"function MedlynConductanceParameters(\n    toml_dict::CP.ParamDict;\n    g1,\n    g0 = toml_dict[\"min_stomatal_conductance\"],\n)\n\nTOML dict based constructor supplying default values for the MedlynConductanceParameters struct.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.PModelConductance","page":"Stomatal Conductance","title":"ClimaLand.Canopy.PModelConductance","text":"PModelConductance{FT}(toml_dict;\n                      Drel = toml_dict[\"Drel\"],\n                    ) where {FT <: AbstractFloat}\n\nCreates a PModelConductance using default parameters of type FT.\n\nThe following default parameter is used:\n\nDrel = FT(1.6) (unitless) - relative diffusivity of H2O to CO2 (Bonan Table A.3)\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.PModelConductance-Union{Tuple{ClimaParams.ParamDict}, Tuple{FT}} where FT<:AbstractFloat","page":"Stomatal Conductance","title":"ClimaLand.Canopy.PModelConductance","text":"PModelConductance{FT}(toml_dict;\n                      Drel = toml_dict[\"Drel\"],\n                    ) where {FT <: AbstractFloat}\n\nCreates a PModelConductance using default parameters of type FT.\n\nThe following default parameter is used:\n\nDrel = FT(1.6) (unitless) - relative diffusivity of H2O to CO2 (Bonan Table A.3)\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.PModelConductanceParameters","page":"Stomatal Conductance","title":"ClimaLand.Canopy.PModelConductanceParameters","text":"PModelConductanceParameters{FT <: AbstractFloat}\n\nThe required parameters for the P-Model stomatal conductance model.\n\nDrel: Relative diffusivity of water vapor (unitless)\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.medlyn_term","page":"Stomatal Conductance","title":"ClimaLand.Canopy.medlyn_term","text":"medlyn_term(g1::FT, T_air::FT, P_air::FT, q_air::FT, thermo_params) where {FT}\n\nComputes the Medlyn term, equal to 1+g1/sqrt(VPD), by first computing the VPD, where VPD is the vapor pressure deficit in the atmosphere (Pa), and g_1 is a constant with units of sqrt(Pa).\n\nthermo_params is the Thermodynamics.jl parameter set.\n\nNote that in supersaturated conditions the vapor pressure deficit will be negative, which leads to an imaginary Medlyn term m. Clipping to zero solves this, but this leads to division by zero, so we regularize the division by adding a small quantity.\n\nAn alternative to consider in the future is to compute the inverse of this quantity and stomatal resistance instead of conductance.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.medlyn_conductance","page":"Stomatal Conductance","title":"ClimaLand.Canopy.medlyn_conductance","text":"medlyn_conductance(g0::FT,\n                   Drel::FT,\n                   medlyn_term::FT,\n                   An::FT,\n                   ca::FT) where {FT}\n\nComputes the stomatal conductance according to Medlyn, as a function of the minimum stomatal conductance (g0), the relative diffusivity of water vapor with respect to CO2 (Drel), the Medlyn term (unitless), the biochemical demand for CO2 (An), and the atmospheric concentration of CO2 (ca).\n\nThis returns the conductance in units of mol/m^2/s. It must be converted to m/s using the molar density of water prior to use in SurfaceFluxes.jl.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.penman_monteith","page":"Stomatal Conductance","title":"ClimaLand.Canopy.penman_monteith","text":"penman_monteith(\n    Δ::FT, # Rate of change of saturation vapor pressure with air temperature. (Pa K−1)\n    Rn::FT, # Net irradiance (W m−2)\n    G::FT, # Ground heat flux (W m−2)\n    ρa::FT, # Dry air density (kg m−3)\n    cp::FT, # Specific heat capacity of air (J kg−1 K−1)\n    VPD::FT, # vapor pressure deficit (Pa)\n    ga::FT, # atmospheric conductance (m s−1)\n    γ::FT, # Psychrometric constant (γ ≈ 66 Pa K−1)\n    gs::FT, # surface or stomatal conductance (m s−1)\n    Lv::FT, # Volumetric latent heat of vaporization (J m-3)\n    ) where {FT}\n\nComputes the evapotranspiration in m/s using the Penman-Monteith equation.\n\n\n\n\n\n","category":"function"},{"location":"fundamental_concepts/#ClimaLand-fundamental-concepts","page":"Fundamental Concepts","title":"ClimaLand fundamental concepts","text":"","category":"section"},{"location":"fundamental_concepts/#Standalone-and-integrated-models","page":"Fundamental Concepts","title":"Standalone and integrated models","text":"A core concept of ClimaLand's design is the presence of standalone and integrated models. In ClimaLand's framework, the land system is divided into individual components: soil, vegetation (or canopy), and snow. Each of these components can be run individually (standalone) or combined together (integrated).\n\nAs an example, the soil model EnergyHydrology and the canopy model CanopyModel can each be set up and run on their own in standalone mode. Or, a user can set up the integrated SoilCanopyModel, which internally constructs each of these models and runs them in tandem, computing relevant interaction terms at each timestep. For a complete list of standalone and integrated models implemented in ClimaLand, please see the page Available Models and Parameterizations.","category":"section"},{"location":"fundamental_concepts/#Model-variables","page":"Fundamental Concepts","title":"Model variables","text":"All ClimaLand models (standalone and integrated alike) contain two types of variables:","category":"section"},{"location":"fundamental_concepts/#Prognostic-variables","page":"Fundamental Concepts","title":"Prognostic variables","text":"These variables are solved for at each timestep based on differential equations and using timestepping methods implemented in ClimaTimeSteppers.jl. The specific timestepping methods used depend on the model being used, and can be chosen from the many that ClimaTimeSteppers.jl has implemented.\n\nPrognostic variables are stored in the model state, which is represented as the variable Y.\n\nFor more information about timestepping, please see the timestepping tutorial.","category":"section"},{"location":"fundamental_concepts/#Diagnostic-variables","page":"Fundamental Concepts","title":"Diagnostic variables","text":"These variables are computed at each timestep as functions of the prognostic variables (as well as other parameters, forcing data, etc).\n\nDiagnostic variables are stored in the model cache, which is represented as the variable p.","category":"section"},{"location":"fundamental_concepts/#Model-internals","page":"Fundamental Concepts","title":"Model internals","text":"All standalone models in the ClimaLand ecosystem contain the following objects:\n\ndomain: The physical space on which the simulation is being evaluated; ClimaLand domains use ClimaCore.jl spaces internally.\nparameters: A set of constants that may or may not vary in space, and are required to solve the model equations.\nboundary conditions: A ClimaLand object containing information about how to handle computation at the edges of the domain.\n\nBoundary conditions arise as a result of solving PDEs for 3D models, and we maintain this terminology for single layer models. In general, boundary conditions specify how the component interacts with surrounding pieces of the model, whether they are other component models or the atmosphere.\n\nStandalone models may contain additional information, depending on the particular type of model. For example, soil models contain a flag lateral_flow to control lateral flow in the soil, but this flag is not included in canopy models (where it wouldn't make sense).\n\nIntegrated models don't have this same structure, but instead contain each of the component models they consist of. These component models, though run in integrated mode, still each contain the structure described above. The result is a nested structure for integrated ClimaLand models.","category":"section"},{"location":"standalone/pages/snow/snow_model/#Snow-modeling","page":"Snow model","title":"Snow modeling","text":"The ClimaLand snow model is composed of a simple processed based model for conservation of water mass and energy and parameterizations for albedo, depth, and surface temperature.\n\nThe key conservative equations are\n\nrho_lfracpartial Spartial t =  P_rm snow + sigma(P_rm liq - E - rho_l R_rm snow) \nfracpartial Upartial t  =  e_i rm snow P_rm snow + bigg( -rho_l e_l R_mathrmsnow + e_l rm rain P_rm liq +G -H - LE + R_nbigg)sigma \nrho_l fracpartial S_lpartial t =  bigg(P_rm liq - E_l + rho_lM - rho_lR_rm snowbigg) sigma\n\nwhere:\n\nS\nis the snow water equivalent per ground area, t is the time, P_rm snow and sigma(P_rm liq are the precpitation fluxes, E is the vapor flux, and rho_l R_rm snow is a mass flux of water due to meltwater leaving the snowpack,\nU\nis the energy of the snowpack per unit ground area, and G is the snow/soil ground heat flux, H is the sensible het flux, LE is the latent heat flux, and R_n is the radiative heat flux, with terms like e_x reflecting the energy associated with precipitation or runoff, with x indicating snowfall, rain, or runoff of liquid water.\nS_l\nis the liquid water equivalent per ground area, and rho_lM a flux associated with phase changes within the snowpack,\nsigma\nis the snow cover fraction.\n\nIn order to solve these equations, we must define parameterizations for computing the fluxes (H LE R_n M R). Further detail on these will be added as the model details are finalized. ","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/#Domain-Tutorial","page":"Intro to ClimaLand Domains","title":"Domain Tutorial","text":"","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/#Goals-of-the-tutorial","page":"Intro to ClimaLand Domains","title":"Goals of the tutorial","text":"The goal of this is to outline what is currently implemented in ClimaLand and to serve as a software design document for future development involving the underlying domains.","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/#Background","page":"Intro to ClimaLand Domains","title":"Background","text":"In both the atmosphere and the ocean, all variables are defined at all locations in the region of interest, or domain.  For example, the air density, temperature, pressure, and wind speed are defined everywhere in the domain. After choosing a resolution and discretizing space, the numerical problem is to advance a system of differential equations, where at each coordinate point a value of ρ, T, P, and u⃗ are solved for at each step. The choice of domain is a question \"only\" of geometry: you may be interested in a large eddy simulation (using a box domain), or in a global model (where you would need a spherical shell domain representing the atmosphere or ocean from some depth to z_sfc = 0).\n\nFor land surface models, each variable is not defined everywhere in space. For example, the soil water content θ is only defined below ground. Snow water equivalent (S) is only defined on the surface itself. Canopy variables are only defined above ground. Once we have discretized the land surface region into a set of points, the numerical problem is to advance a system of ODEs, where at each coordinate point a different subset of (θ, S, ...) are solved for.\n\nIn other words, different variables in land surface models exist in different, overlapping, domains. We need to decide on the geometry of interest (e.g. single column vs a global simulation), but we also need to specify where each variable of the model is defined.\n\nClimaLand Domains were designed with this in mind. The domains are defined so that\n\nthe user can easily switch geometries, e.g. single column to global model,\nindividual component models can be run by themselves, using a single domain,\nthe same domains can be used to set up multi-component models (LSMs),\ndifferent variables can exist on different parts of the domain.","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/#What-is-a-ClimaLand-Domain?","page":"Intro to ClimaLand Domains","title":"What is a ClimaLand Domain?","text":"A domain represents a region of space. In ClimaLand, domains are simply structs containing parameters that define these regions - for example an x-range and y-range that define a plane. In addition, ClimaLand domains store the ClimaCore function spaces for the physical domain as a NamedTuple. When solving partial differential equations, the spatial discretization is tied to a set of basis functions you wish to use to represent the prognostic variable as a function of space. The nodal points - the locations in space where the variable is solved for - are arranged in space in a manner which depends on these basis functions. Note that these spaces are only mathematically needed when your variables satisfy PDEs[1], but that they still exist when your variables do not, because we are using the same underlying infrastructure in both cases.","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/#Domain-types","page":"Intro to ClimaLand Domains","title":"Domain types","text":"All ClimaLand domains are subtypes of abstract type ClimaLand.Domains.AbstractDomain. A variety of concrete domain types are supported:\n\n0D: Domains.Point\n1D: Domains.Column\n2D: Domains.Plane, Domains.SphericalSurface\n3D: Domains.HybridBox, Domains.SphericalShell.\n\nAs discussed above, our modeling requires that variables of a model can be defined on different subsets of the domain. Because of that, we define the concept of a surface domain, and a subsurface domain[2]. Not all domains have a surface and subsurface; some only have surface domains, as shown in the Table below.\n\nDomain Surface Domain Subsurface Domain\nColumn Point Column\nHybridBox Plane HybridBox\nSphericalShell SphericalSurface SphericalShell\n\nThere is a single key method which take a ClimaLand domain as an argument.\n\ncoordinates(domain): under the hood, this function  uses\n\nthe NamedTuple of function spaces (domain.space) to create the coordinate field for the surface and subsurface domains (as applicable), stored in a NamedTuple. Depending on the domain, the returned coordinate field will have elements of different names and types. For example, the SphericalShell domain has subsurface coordinates of latitude, longitude, and depth, while the surface coordinates are latitude and longitude. A Plane domain has coordinates of x and y (surface only), and a Point domain only has a coordinate z_sfc (surface only). Column domains have a surface coordinate of z_sfc, and subsurface coordinates of z.\n\nIt is important to note that the horizontal domain used for the surface and subsurface domains are identical in all simulations using a particular domain setup. This ensures that we can use the same indexing of surface and subsurface domains and variables. Otherwise we would need to develop additional infrastructure in order to, for example, select the correct subsurface column corresponding to a particular surface location.","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/#Helper-functions-for-global-simulations","page":"Intro to ClimaLand Domains","title":"Helper functions for global simulations","text":"In order to make it easier to set up a global domain, we provide two helper functions:\n\nSpherical Geometry: Domains.global_domain\nCartesian Geometry: Domains.global_box_domain\n\nThe former is useful if your model requires knowledge of spherical geometry. For example, any horizontal flux computation need to be aware of this in order to be correct. However, we do not yet support lateral flow in the soil. In this case, columns are independent of each other, spherical geometric effects are not needed, and we can use a regular Cartesian grid. The latter function provides that. Another material difference between the two is that the latter places coordinate points equispaced in lat/lon, while the former does not, since it is based on an equiangular cubed sphere.","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/#How-variable-initialization-depends-on-domains","page":"Intro to ClimaLand Domains","title":"How variable initialization depends on domains","text":"Single component models (soil, snow, vegetation, canopy...) must have an associated domain in order to solve the their equations.  Which domain is appropriate depends on the model equations and on the configuration of interest (single column or global, etc.). For example, the soil model is a vertically resolved model, so only domains with a vertical extent (Column, HybridBox, or SphericalShell) make sense to use. A single layer snow model does not require vertical resolution - and so the domains that make sense to use are a Point, Plane, or SphericalSurface.\n\nWhen a developer first defines a model, they need to specify the symbols used for the prognostic variables, via prognostic_vars, and the types of those variables,  via prognostic_types.\n\nThey additionally need to define which subset of the domain the variables are defined on, using prognostic_domain_names.\n\nThe initialize function (which calls both initialize_prognostic  and initialize_auxiliary) creates the prognostic state vector Y (a ClimaCore.Fields.FieldVector). Each field (ClimaCore.Fields.Field) stored within the field vector corresponds to a prognostic variable (identified with the symbol specified). If the prognostic type for that variable is a float, the field will be a field of float values (a scalar field)[3].\n\nHow do domains tie into this? The field of a prognostic variable corresponds in a 1-1 fashion with the coordinate field of the subset of the domain associated with that variable via prognostic_domain_name.  For example, the bucket model has a vertically resolved temperature T, but the bucket water content W is not vertically resolved. If your domain is a Column, the subsurface coordinates may be [-4.5,-3.5,-2.5,-1.5, -0.5], and the surface coordinate would be [-0.0]. Your prognostic variable field for T will be [T[-4.5], T[-3.5]; T[-2.5], T[-1.5], T[-0.5]], and for W  it will be [W[0.0],]. Your variable always has the same spatial resolution as the associated subset of the domain.\n\nThis functionality is not required for every standalone component model. For example, a single layer snow model will only have variables on the surface of the domain (which in this case, would be the entire Point, Plane, or SphericalShell domain). The user still must define the prognosticdomainnames method. This functionality is required for most multi-component models.","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/#Future-work","page":"Intro to ClimaLand Domains","title":"Future work","text":"Almost all interactions between variables in land surface models are within column - that is, there is only vertical transport and exchanges. The exception to this is the horizontal flow of water on the surface and within the soil. This is not currently supported. We envision each step of the land surface model simulation to be solved  in two steps: (1) the vertical tendency evaluations are carried out (and can be parallelized), and (2) the horizontal tendency functions are then evaluated (possibly less frequently?) and require communication between columns.\n\n[1]: finite differencing is used in the vertical, and spectral elements are used in the horizontal.\n\n[2]: a suprasurface region may also be necessary - for example if the canopy airspace model involves PDEs.\n\n[3]: We also support having a tuple or array-like type of variable.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"calibration/#Calibration-framework-of-the-CliMA-land-model","page":"Calibrating model parameters","title":"Calibration framework of the CliMA land model","text":"","category":"section"},{"location":"calibration/#Introduction","page":"Calibrating model parameters","title":"Introduction","text":"In general, models attempt to reproduce real world observations. Calibration is the process of finding the parameter set that will best reproduce real world observation.\n\nThe key ingredients in calibration are:\n\nthe model we want to run;\nthe parameters we want to tune along with their prior distributions;\nthe observational data we want to reproduce and how that data is represented in the model;\nthe noise associated to such observational data.\n\nThe process of calibrating consists of optimizing how different parameters match the given observations within the given noise. In ClimaLand, we use EnsembleKalmanProcesses.jl (EKP) to perform automatic calibration. Before discussing the details of EKP, we introduce the following terminology to mirror the key ingredients introduced above:\n\na forward_model that runs the model for a given parameter set,\nan observation vector that contains the data or statistics of data we want the model to reproduce,\nan observation_map which maps the equivalent of the observation vector, but from the model output,\npriors which contains the parameters we want to calibrate (find the value that makes the model match the observation best), priors gives which parameters, but also their distribution\na covariance matrix that defines the observational error and correlations\n\nEnsembleKalmanProcesses.jl (EKP) is at the center of CliMA's calibration efforts. EKP implements a suite of Ensemble Kalman methods to find a (locally) optimal parameter set U for a model G to fit noisy Γ observational data Y. These methods are optimized for problems where the model G is computationally expensive and no analtyic derivatives are available, as in the case of weather forcasting, where Ensemble Kalman techniques have a long history of success.\n\nLarge calibration campaigns often require supercomputers and while direct use of EKP.jl is possible, CliMA's preferred approach is using ClimaCalibrate.jl, a package optimized for running on compute clusters. ClimaCalibrate handles efficient job orchestration and abstracts the details of the underlying system, providing a simpler user experience. Consult the ClimaCalibrate documentation for further information.","category":"section"},{"location":"calibration/#Calibrate-a-land-model","page":"Calibrating model parameters","title":"Calibrate a land model","text":"In this tutorial, we will perform a calibration using ClimaCalibrate. ClimaCalibrate provides an interface to EnsembleKalmanProcesses.jl that is more optimized for use on supercomputers. The tutorial to calibrate a single site latent heat flux shows how to perform a calibration using EKP directly.\n\nThe calibrate function is at the heart of performing a calibration with ClimaCalibrate:\n\nimport ClimaCalibrate\n\nClimaCalibrate.calibrate(\n    ClimaCalibrate.WorkerBackend,\n    utki,\n    n_iterations,\n    prior,\n    output_dir,\n)\n\nwhere the utki object defines your EKP configurations, for example, the default is:\n\nEKP.EnsembleKalmanProcess(\n    obs_series,\n    EKP.TransformUnscented(prior, impose_prior = true),\n    verbose = true,\n    rng = rng,\n    scheduler = EKP.DataMisfitController(terminate_at = 100),\n)\n\nwhere obs_series is the \"truth\" you want to calibrate your model on. It can take many forms. For example, you may want to calibrate monthly global average of latent heat flux, monthly average at 100 random locations on land, or the annual amplitude and phase. You will create obs_series from some data (for example ERA5), as a vector.\n\nNote that obs_series object contains the covariance matrix of the noise, which informs the uncertainties in space and time of your targeted \"truth\". It can be set, for example, to the inter-annual variance of a variable, or a percentage (e.g., 5%) of the average of the variable, or to a flat noise (e.g., 5 W m-2 for latent heat). This will inform the EKP algorithm that if the model is within the target plus or minus the noise at specific space and time, the goal is reached.\n\nTransformUnscented.Unscented is a method in EKP, that requires 2p + 1 ensemble members for each iteration, where p is the number of parameters. For more information, read the EKP documentation for that method.\nverbose = true is a setting that writes information about your calibration run to a log file.\nrng is a set random seed.\nScheduler is a EKP setting for timestepping, please read EKP schedulers documentation.\nClimaCalibrate.WorkerBackend defines how to interact with the underlying compute system. For other possible backends (for example, JuliaBackend, ClimaGPUBackend, or DerechoBackend), see the backend documentation in ClimaCalibrate.\n\nEach backend is optimized for specific use cases and computing resources. The backend system is implemented through Julia's multiple dispatch, so that code written for one environment can seamlessly be ported to a new/different environments.\n\nprior is the distribution of the parameters you want to calibrate. For example, if you want to calibrate two parameters called sc and pc, you would define your priors like this, for example:\n\nprior_sc = EKP.constrained_gaussian(\"sc\", 5e-6, 5e-4, 0, Inf);\nprior_pc = EKP.constrained_gaussian(\"pc\", -2e6, 1e6, -Inf, Inf);\nprior = EKP.combine_distributions([prior_sc, prior_pc]);\n\nFor more documentation about prior distribution, see this EKP documentation page.\n\nn_iterations is the number of times your priors distribution will be updated, at each iteration your model is run for  the number of ensemble_size. So in total, your model will be run ensemble_size * n_iterations.\noutput_dir is the path to your calibration output directory. Inside this folder, the parameter set of each ensemble member for each iteration is stored, as well as the output of your model simulations. For example, if you ran a calibration with 1 iteration and 2 members, output_dir would be structured like this:\n\n.\n├── iteration_000\n│   ├── eki_file.jld2\n│   ├── G_ensemble.jld2\n│   ├── member_001\n│   │   ├── global_diagnostics\n│   │   │   ├── output_0000\n│   │   │   │   ├── lhf_1M_average.nc\n│   │   │   │   ├── lwu_1M_average.nc\n│   │   │   │   ├── shf_1M_average.nc\n│   │   │   │   └── swu_1M_average.nc\n│   │   │   └── output_active -> output_0000\n│   │   └── parameters.toml\n│   ├── member_002\n│   │   ├── global_diagnostics\n│   │   │   ├── output_0000\n│   │   │   │   ├── lhf_1M_average.nc\n│   │   │   │   ├── lwu_1M_average.nc\n│   │   │   │   ├── shf_1M_average.nc\n│   │   │   │   └── swu_1M_average.nc\n│   │   │   └── output_active -> output_0000\n│   │   └── parameters.toml\n├── iteration_001\n│   ├── eki_file.jld2\n│   ├── G_ensemble.jld2\n│   ├── member_001\n│   │   ├── global_diagnostics\n│   │   │   ├── output_0000\n│   │   │   │   ├── lhf_1M_average.nc\n│   │   │   │   ├── lwu_1M_average.nc\n│   │   │   │   ├── shf_1M_average.nc\n│   │   │   │   └── swu_1M_average.nc\n│   │   │   └── output_active -> output_0000\n│   │   └── parameters.toml\n│   ├── member_002\n│   │   ├── global_diagnostics\n│   │   │   ├── output_0000\n│   │   │   │   ├── lhf_1M_average.nc\n│   │   │   │   ├── lwu_1M_average.nc\n│   │   │   │   ├── shf_1M_average.nc\n│   │   │   │   └── swu_1M_average.nc\n│   │   │   └── output_active -> output_0000\n│   │   └── parameters.toml\n\nEach iteration contains directories for each member, inside which you can find the parameters value inside parameters.toml, and model outputs inside global_diagnostics.\n\nTwo additional functions need to be defined in order to run ClimaCalibrate.calibrate. ClimaCalibrate.forward_model(iteration, member) and ClimaCalibrate.observation_map(iteration). The ClimaCalibrate.forward_model(iteration, member) needs to generate your model output for a specific iteration and member. The ClimaCalibrate.observation_map(iteration) needs to return your loss, a vector of the same format as observations but created with your model output (for example, monthly average of latent heat flux), for all members. To make this easier, it can be useful to implement a process_member_data(root_path) function that generates one member output from your model output path.\n\nOnce you have defined ClimaCalibrate.forward_model, ClimaCalibrate.observation_map, output_dir, noise, observations, n_iterations, ensemble_size, and your backend, you can call ClimaCalibrate.calibrate!","category":"section"},{"location":"calibration/#Job-script","page":"Calibrating model parameters","title":"Job script","text":"A calibration job will likely take hours to complete, so you will probably have to submit a job with a job scheduler. Below is an example job .pbs script (for PBS, e.g., Derecho):\n\n#!/bin/bash\n#PBS -N derecho_calibration\n#PBS -o output.txt\n#PBS -e error.txt\n#PBS -l walltime=10:00:00\n#PBS -l select=1:ncpus=64:ngpus=4\n\n## Account number for CliMA\n#PBS -A UCIT0011\n#PBS -q main\n\nmodule load climacommon\n# Run your command\nexport CLIMACOMMS_DEVICE=\"CUDA\"\nexport CLIMACOMMS_CONTEXT=\"SINGLETON\"\njulia --project=.buildkite -e 'using Pkg; Pkg.instantiate(;verbose=true)'\n\njulia --project=.buildkite/ experiments/calibration/run_calibration.jl\n\nand below is a example job .sh script (for Slurm, e.g., central or clima):\n\n#!/bin/bash\n#SBATCH --job-name=slurm_calibration\n#SBATCH --output=output.txt\n#SBATCH --error=error.txt\n#SBATCH --time=12:00:00\n#SBATCH --ntasks=5\n#SBATCH --cpus-per-task=4\n#SBATCH --gpus-per-task=1\n\n# Set environment variables for CliMA\nexport CLIMACOMMS_DEVICE=\"CUDA\"\nexport CLIMACOMMS_CONTEXT=\"SINGLETON\"\n\n# Build and run the Julia code\nmodule load climacommon\njulia --project=.buildkite -e 'using Pkg; Pkg.instantiate(;verbose=true)'\njulia --project=.buildkite/ experiments/calibration/run_calibration.jl\n\nwhere run_calibration.jl is a script that set up the calibration and call ClimaCalibrate.calibrate. You would start the job with a command such as qsub name_of_job_script for PBS or sbatch name_of_job_script for Slurm, and a few hours later, you would get a calibrated parameter set. You can check the status of your job with qstat -u username of PBS or squeue -u username on Slurm.\n\nNote that with the default EKP configuration, UTKI, the number of ensemble is set by the number of parameters, as explained in the documentation above. The number of workers (if you use the worker backend) is automatically set to that numbers, so that all members are run in parallel for each iteration.","category":"section"},{"location":"calibration/#Configure-your-land-calibration","page":"Calibrating model parameters","title":"Configure your land calibration","text":"For configuring the land calibration, you can configure the optimization method used by EnsembleKalmanProcesses.jl, the observations and how they are preprocessed, and the simulation itself. For most settings, you can modify the CalibrateConfig struct. See the example below.\n\nCalibrateConfig(;\n    short_names = [\"swu\"],\n    minibatch_size = 2,\n    n_iterations = 10,\n    sample_date_ranges = [(\"2007-12-1\", \"2008-9-1\"),\n                          (\"2008-12-1\", \"2009-9-1\"),\n                          (\"2009-12-1\", \"2010-9-1\"),\n                          (\"2010-12-1\", \"2011-9-1\")],\n    extend = Dates.Month(3),\n    spinup = Dates.Month(3),\n    nelements = (101, 15),\n    output_dir = \"experiments/calibration/land_model\",\n    rng_seed = 42,\n    model_type = ClimaLand.LandModel,\n)\n\nWith the configuration above, a calibration is being done using the swu observation. The calibration will run for 10 iterations, and each iteration will use a minibatch size of 2. The start and end dates of the simulation is automatically determined by sample_date_ranges, spinup, and extend. The amount to spin up the simulation for is three months and the amount to run the simulation for past the dates in sample_date_ranges is also three months. Since the minibatch size is 2, the first iteration of the calibration will run from 1 September 2007 to 1 December 2009 and the second iteration of the calibration is 1 September 2009 to 1 December 2011. Afterward, the iterations will repeat, so the third iteration will be the same as the first iteration, the fourth iteration will be the same as the second iteration, and so on.\n\nThe period chosen for extend is ensure that all the data is gathered. If you are calibrating against seasonal averages, then extend should be 3 months and if you are calibrating against monthly averages, then extend should be 1 month. For more information, see the sections Data pipelines and Simulation settings.\n\nThe number of horizontal and vertical elements to use for the simulation is determined by nelements. The calibration is saved at output_dir and the random number generator is seeded by rng_seed.","category":"section"},{"location":"calibration/#EKP-settings","page":"Calibrating model parameters","title":"EKP settings","text":"In CalibrateConfig, you can modify the number of iterations via n_iterations and the size of the minibatch by minibatch_size. For reproducibility, you can pass in an integer for rng_seed which is used internally by EnsembleKalmanProcesses.jl to seed the random number generator.\n\nFor the land calibration, the default optimization method is EnsembleKalmanProcesses.TransformUnscented and the default scheduler is EKP.DataMisfitController. To change this optimization method or change the scheduler, you need to go to the experiments/calibration/run_calibration.jl file and modify it there. For more information about the different optimization methods, see EnsembleKalmanProcesses.jl for more information.","category":"section"},{"location":"calibration/#Observation-settings","page":"Calibrating model parameters","title":"Observation settings","text":"In CalibrateConfig, you can modify which observations that are used via short_names. As of now, the currently supported observations for calibration are seasonal averages of lhf, shf, lwu, and swu. See the Data pipelines on how to add more variables.\n\nObservations are generated with generate_observations.jl. To generate observations, you can run\n\njulia --project=.buildkite experiments/calibration/generate_observations.jl`\n\nnote: When do I need to generate observations?\nWhenever nelements, sample_date_ranges, short_names, or the preprocessing of any of the variables change, then you must regenerate the observations!\n\nEach observation contains time series data of the variables from ERA5 and a covariance matrix. You can adjust sample_date_ranges if you want to calibrate over a particular year or over multiple years for example.\n\nnote: What can be passed for `sample_date_ranges`?\nThe sample date ranges should be times from the time series data of the observations. For example, when using seasonal averages, the times passed must be the first day of December, March, June, or September. The seasons are December to February (DJF), March to May (MAM), June to August (JJA), and September to November (SON). The convention for time is use the first time of the time reduction.\n\nTo change the covariance matrix, you need to go to generate_observations.jl and modify the covariance matrix that is passed in. See ClimaCalibrate.jl documentation for a list of different covariance matrices that can be used.","category":"section"},{"location":"calibration/#Data-pipelines","page":"Calibrating model parameters","title":"Data pipelines","text":"note: Data preprocessing\nThe data preprocessing uses ClimaAnalysis.jl. See the ClimaAnalysis.jl documentation for functions you can use for preprocessing.\n\nTo add additional variables or change how a variable is preprocessed, you must add the variable to the data sources and specify how the variable should be preprocessed. The name of the variable should match the name in the diagnostics. As of now, each variable from the ERA5 data is loaded by the function get_era5_obs_var_dict in ext/land_sim_vis/leaderboard/data_sources.jl. See the documentation of get_obs_var_dict for how to add a new variable. In addition, you should also add the same variable to get_sim_var_dict in the same file as before.\n\nFurther preprocessing is done in the function preprocess_single_era5_var in generate_observations.jl. After adding the variable, you should specify any additional preprocessing. For example, if you want seasonal averages, you should use ClimaAnalysis.average_season_across_time. Furthermore, you should check the units of the variable, ensure that the grid and mask are the same between the simulation and observational data, and ensure the conventions for times are the same. Finally, the same preprocessing should be applied between both observational and simulation data. Preprocessing the observational data is done in preprocess_single_era5_var in experiments/calibration/generate_observations.jl and preprocessing the simulation data is done in process_member_data in experiments/calibration/observation_map.jl.\n\nnote: Time conventions\nDifferent data sources have different conventions for time. For example, data sources use January 1, January 15, and Feburary 1 for the monthly average of January. For the diagnostics saved from a CliMA simulation, the current convention is to save the monthly average on Feburary 1. You must ensure that the time conventions are the same. For calibration, we choose the start of the time reduction, so for this example, the time associated with the monthly average of January is January 1. For seasonal averages, the dates would be December 1, March 1, June 1, and September 1.","category":"section"},{"location":"calibration/#Simulation-settings","page":"Calibrating model parameters","title":"Simulation settings","text":"In CalibrateConfig, you can modify the resolution of the model via nelements. To change the directory of where the calibration starts, you can change output_dir, whose default is experiments/calibration/land_model. You can change the model used via configuration, whose default is ClimaLand.LandModel. The only supported configurations are ClimaLand.LandModel and ClimaLand.Bucket.BucketModel.\n\nFor adjusting the start and end dates of the simulation, you can change spinup and extend.\n\nnote: How are the start and end dates of the simulation chosen?\nThe start and end dates of a simulation is automatically inferred from the sample_date_ranges. For example, suppose that sample_date_ranges = [(\"2007-12-1\", \"2008-9-1\"), (\"2008-12-1\", \"2008-9-1)] and the minibatch size is 2. The start and end dates are 2007-12-1 to 2008-9-1. This should cover the time ranges of the observational data. However, observe that the simulation output may not be realistic at the beginning of the simulation while the land model is equilibrating and the end date is not correct, because of the time convention we chosen earlier. To solve the first problem, you can specify how the long the model should spin up for with spinup in the CalibrateConfig. For the second problem, you can make the simulation extend past 2008-9-1 with extend. For calibrating with monthly averages, extend should be Dates.Month(1) and for calibrating with seasonal averages, extend should be Dates.Month(3).","category":"section"},{"location":"calibration/#Which-parameters-can-I-calibrate?","page":"Calibrating model parameters","title":"Which parameters can I calibrate?","text":"ClimaLand.jl provides a full list of spatially-constant parameters that may be calibrated in toml/default_parameters.toml. For each parameter, this file includes the parameter name, type, default value, units, and model or parameterization it is used for. Please see that file to see which parameters could be calibrated for your model of interest.","category":"section"},{"location":"generated/integrated/fluxnet_vis/#Visualizing-the-output-of-a-Fluxnet-simulation","page":"Visualization","title":"Visualizing the output of a Fluxnet simulation","text":"We current support some default plotting functions for Fluxnet simulations. Please let us know if you would like to add other functionality; we are also implementing a method to write the simulation data to file so that you can use your plotting methods of choice.\n\nFirst, take a look at the fluxnet simulation tutorials for SoilCanopyModel or LandModel. To use the default plotting tools (LandSimVis), you need to start by importing the packages required:\n\nusing ClimaLand\nusing CairoMakie, ClimaAnalysis, GeoMakie, Printf, StatsBase\nimport ClimaLand.LandSimVis as LandSimVis;\n\nWe assume you have setup your simulation and the solve step has finished. Two key functions are supported, make_diurnal_timeseries and make_timeseries. Both require the simulation:\n\nLandSimVis.make_diurnal_timeseries(simulation);\nLandSimVis.make_timeseries(simulation);\n\nThese make plots of each variable saved as a diagnostic during the simulation. Only the top layer of vertically resolved variables is plotted. To plot a subset of the variables, pass in a list of ClimaLand Diagnostic short_names. You can also optionally pass in a spinup date: only data after this date will be included in plotting. You can also pass in a directory and plot stem name to overwrite the defaults:\n\nLandSimVis.make_timeseries(\n   simulation;\n   savedir = path_to_dir,\n   plot_stem_name = \"timeseries\",\n   short_names = [\"swc\", \"si\", \"swe\"],\n   spinup_date = start_date + Day(20))\n\nThis would create the following plots \"swctimeseries.png\", \"sitimeseries.png\", and \"swe_timeseries.png\".\n\nTo plot comparison data, you first need to get the comparison data\n\ncomparison_data = FluxnetSimulations.get_comparison_data(site_ID, time_offset)\nLandSimVis.make_timeseries(\n   simulation;\n   short_names = [\"swc\", \"si\", \"swe\"],\n   comparison_data)\n\nThe diurnal timeseries plotted is an average diurnal timeseries. We interpolate the data or simulation output to an hourly interval, and then compute the average of each hour of the day over the entire data.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"restarts/#Restarting-Simulations","page":"Restarting a simulation","title":"Restarting Simulations","text":"ClimaLand provides functionality to save and load simulation checkpoints, allowing you to restart simulations from a previous state. This is particularly useful for long-running simulations or if you want to experiment with different configurations starting from a specific point in the simulation.","category":"section"},{"location":"restarts/#Saving-Checkpoints","page":"Restarting a simulation","title":"Saving Checkpoints","text":"To save a simulation checkpoint, you can use the ClimaLand.save_checkpoint function. This function takes the current state Y, the simulation time t, and the output directory as arguments. Optionally you can provide the ClimaLand model object model. This will store the hash of the model in the checkpoint file. You can use this information to ensure that you are restarting the simulation with the same model that was used to generate the checkpoint.\n\nClimaLand.save_checkpoint(Y, t, output_dir; model)\n\nMost typically, this function is not called directly. Instead, it is called as a callback.\n\nIn ClimaLand, you can automate the process of saving checkpoints using the CheckpointCallback. This callback allows you to specify the frequency at which checkpoints are saved and handles the saving process during the simulation.\n\nTo use the CheckpointCallback, you need to create an instance of it and pass it to the solve function along with your other callbacks.\n\nExample:\n\n\n# ... your ClimaLand simulation setup ...\n\n# Create a CheckpointCallback to save checkpoints every 6 hours\ncheckpoint_cb = CheckpointCallback(Dates.Hour(6), output_dir, start_date; model, dt)\n\n# Add the callback to the callback set\ncb = SciMLBase.CallbackSet(checkpoint_cb, other_callbacks...)\n\n# Run the simulation with the callbacks\nsol = SciMLBase.solve(prob, ode_algo; dt = Δt, callback = cb)\n\n# ... your ClimaLand simulation analysis ...\n\nIn this example, the CheckpointCallback will save a checkpoint every 6 hours during the simulation. You can customize the checkpoint_frequency to control how often checkpoints are saved. You can also pass the ClimaLand model object model to store its hash in the checkpoint file. This information can be used later to ensure that you are restarting the simulation with the same model that was used to generate the checkpoint.\n\nIf dt is passed, CheckpointCallback will also check that it is consistent with the checkpoint frequency.","category":"section"},{"location":"restarts/#Restarting-from-a-Checkpoint","page":"Restarting a simulation","title":"Restarting from a Checkpoint","text":"To restart a simulation from a checkpoint, you can use the ClimaLand.find_restart function to locate the most recent checkpoint file in the output directory. Then, you can use the ClimaLand.read_checkpoint function to load the state vector and simulation time from the checkpoint file.\n\nrestart_file = ClimaLand.find_restart(output_dir)\nY, t = ClimaLand.read_checkpoint(restart_file; model)","category":"section"},{"location":"restarts/#Output-Structure","page":"Restarting a simulation","title":"Output Structure","text":"ClimaLand utilizes the OutputPathGenerator from ClimaUtilities to manage the output directory structure. By default, it uses the ActiveLinkStyle, which creates a sequence of numbered subfolders within the base output directory.\n\nFor example, if your base output directory is output, the following structure will be created:\n\noutput/\n├── output_0000/\n│   └── ... checkpoint files ...\n├── output_0001/\n│   └── ... checkpoint files ...\n├── output_0002/\n│   └── ... checkpoint files ...\n└── output_active -> output_0002/\n\nThe output_active symbolic link always points to the most recent output subfolder, making it easy to access the latest simulation results.","category":"section"},{"location":"restarts/#Checkpoint-File-Structure","page":"Restarting a simulation","title":"Checkpoint File Structure","text":"When using the CheckpointCallback, the checkpoints are saved as HDF5 files within the numbered output subfolders. The files are named using the following convention:\n\nday<day_number>.<seconds_since_midnight>.hdf5\n\nFor example, a checkpoint saved at day 10, 3600 seconds after midnight would be named day10.3600.hdf5.","category":"section"},{"location":"restarts/#Checkpoints,-drivers,-and-accumulated-diagnostics","page":"Restarting a simulation","title":"Checkpoints, drivers, and accumulated diagnostics","text":"At the moment, ClimaLand does not support working with accumulated diagnostics across restarts. The present limitations are best illustrated with an example.\n\nSuppose you are saving 30-day averages and stop the simulation at day 45. If you do so, you'll find output for day 30 and the checkpoint at day 45. Then, if you restart the simulation, you'll see that the next diagnostic output will be at day 75, and not day 60. In other words, the counter starts from 0 with every restart.\n\nnote: Note\nIf you care about accurate accumulated diagnostics, make sure to line up your checkpoint and diagnostic frequencies.\n\nSimilarly, ClimaLand does not guarantee drivers values will be set consistently across restarts. That is, the values of the forcing variables from the last step of the original run will not coincide with the values of the forcing variables upon the initial step of the restart run, unless the frequencies of checkpointing and updating the drivers are compatible.\n\nnote: Note\nThe reason why ClimaLand does not support these features (at the moment), is that updating drivers and diagnostics are implemented as callbacks. Callbacks have some internal memory that is not saved in the restart files.","category":"section"},{"location":"diagnostics/developers_diagnostics/#ClimaLand-Diagnostics:-why-and-how","page":"For developers","title":"ClimaLand Diagnostics: why and how","text":"ClimaLand simulations generates variables in the integrator state (Y) and cache (p) at each time step. A user will need to use these variables in some form, i.e., access them from a file that contains variables at a given temporal and spatial resolution. The user will also want to retrieve metadata about those variables, such as name and units. This is where ClimaLand diagnostics comes in, it writes simulations variables (in a file, such as NetCDF or HDF5, or in Julia Dict), at a specified spatio-temporal reduction (e.g., hourly averages, monthly max, instantaneous, integrated through soil depth...), along with metadata (e.g., soil temperature short name is t_soil, expressed in \"K\" units). We want to provide users with default options, but also the possibility to define their own variables and reductions.\n\nInternally, this is done by using the ClimaDiagnostics.jl package, that provides the functionality to produce a ClimaLand.Diagnostics module in the src/Diagnostics.jl folder. In this folder,\n\nDiagnostics.jl defines the module,\ndiagnostic.jl defines ALL_DIAGNOSTICS, a Dict containing all diagnostics variables defined in define_diagnostics.jl, it also defines the function\n\nadd_diagnostic_variable! which defines a method to add diagnostic variables to ALL_DIAGNOSTICS, finally it contains a function get_diagnostic_variable which returns a  DiagnosticVariable from its short_name, if it exists.\n\ndefine_diagnostics.jl, mentioned above, contains a function define_diagnostics!(land_model) which contains all default diagnostic variables by calling.\n\nadd_diagnostic_variable!, and dispatch off the type of land_model to define how to compute a diagnostic (for example, surface temperature is computed in p.bucket.T_sfc in the bucket model).\n\nland_compute_methods.jl defines how to compute diagnostics for various ClimaLand models.\n\nThe following section give more details on these functions, along with examples.","category":"section"},{"location":"diagnostics/developers_diagnostics/#Default-diagnostics","page":"For developers","title":"Default diagnostics","text":"For each model, we define a function default_diagnostics which retrieves the set of diagnostic variables to compute for this model, and over which time period to average the values.","category":"section"},{"location":"diagnostics/developers_diagnostics/#\"Long\"-diagnostics-(output_vars-:long)","page":"For developers","title":"\"Long\" diagnostics (output_vars = :long)","text":"Each model has a method of the function get_possible_diagnostics which contains a list of all available diagnostics for the model. This is exactly the set of diagnostics output when output_vars = :long. For standalone models, the list is mostly hardcoded, though it may also depend on which parameterizations are available in the model. For integrated models, the list contains all possible diagnostics for each component model, as well as any additional diagnostics specific to the integrated model.","category":"section"},{"location":"diagnostics/developers_diagnostics/#\"Short\"-diagnostics-(output_vars-:short)","page":"For developers","title":"\"Short\" diagnostics (output_vars = :short)","text":"Similarly, each model has a method of get_short_diagnostics, which is a selected subset of the overall available diagnostics for the model that gets used when output_vars = :short. As is the case with get_possible_diagnostics, the set of variables for integrated models is based on its component models, and any additional integrated model-specific variables.","category":"section"},{"location":"diagnostics/developers_diagnostics/#Standard-diagnostic-frequencies","page":"For developers","title":"Standard diagnostic frequencies","text":"We have defined functions which compute statistical metrics of the instantaneous diagnostic variables at different standard frequencies. For example,\n\nhourly_averages(FT, short_names...; output_writer) = common_diagnostics(\n    :hourly,\n    :average,\n    output_writer,\n    nothing, # start_date\n    short_names...;\n)\n\nwill return a list of ScheduledDiagnostics that compute the hourly average for the given variables listed in short_names. We also, so far, provide functions for mins, maxs and averages aggregated monthly, over ten days, daily, hourly, and half-hourly. As a developer, you may want to add more standard diagnostics here.","category":"section"},{"location":"diagnostics/developers_diagnostics/#Compute-methods","page":"For developers","title":"Compute methods","text":"Each model defines all its compute methods in a file (bucket_compute_methods.jl for the bucket model, for example). The structure of a diagnostic variable compute method is, for example:\n\n@with_error function compute_albedo!(out, Y, p, t, land_model::BucketModel)\n    if isnothing(out)\n        return copy(p.bucket.α_sfc)\n    else\n        out .= p.bucket.α_sfc\n    end\nend\n\nIt defines how to access your diagnostic (here, p.bucket.α_sfc) with the land_model BucketModel. Note that you can also use the @diagnostic_compute macro to do the same thing:\n\n@diagnostic_compute \"albedo\" BucketModel p.bucket.α\\_sfc\n\nThe @with_error macro define helper functions returning error messages if a user tries to compute a diagnostic variable that doesn't exist in their model type.","category":"section"},{"location":"diagnostics/developers_diagnostics/#Define-diagnostics","page":"For developers","title":"Define diagnostics","text":"Once the compute functions have been defined, they are added to define_diagnostics!(land_model), which adds diagnostics variables to ALL_DIAGNOSTICS dict, defined in diagnostic.jl. In these functions, you also define a short_name, long_name, standard_name, units and comment. For example:\n\nadd_diagnostic_variable!(\n        short_name = \"alpha\",\n        long_name = \"Albedo\",\n        standard_name = \"albedo\",\n        units = \"\",\n        compute! = (out, Y, p, t) -> compute_albedo!(out, Y, p, t, land_model),\n    )","category":"section"},{"location":"generated/global/bucket/#Global-bucket-run","page":"Bucket","title":"Global bucket run","text":"The code sets up and runs the bucket model  on a spherical domain, using ERA5 data.\n\nFirst we import a lot of packages:\n\nimport ClimaComms\nusing ClimaCore\nusing ClimaUtilities\nimport Interpolations\nimport ClimaUtilities.TimeVaryingInputs:\n    TimeVaryingInput, LinearInterpolation, PeriodicCalendar\nClimaComms.@import_required_backends\nimport ClimaTimeSteppers as CTS\nimport ClimaParams as CP\nusing ClimaLand.Bucket:\n    BucketModel, BucketModelParameters, PrescribedBaregroundAlbedo\nimport ClimaLand\nimport ClimaLand.Parameters as LP\nimport ClimaLand.Simulations: LandSimulation, solve!\nusing Dates\nusing CairoMakie, ClimaAnalysis, GeoMakie, Printf, StatsBase\nimport ClimaLand.LandSimVis as LandSimVis;\n\nSet the simulation float type, determine the context (MPI or on a single node), and device type. Create a default output directory for diagnostics.\n\nconst FT = Float64;\ncontext = ClimaComms.context()\nClimaComms.init(context)\ndevice = ClimaComms.device()\ndevice_suffix = device isa ClimaComms.CPUSingleThreaded ? \"cpu\" : \"gpu\"\nroot_path = \"bucket_longrun_$(device_suffix)\"\ndiagnostics_outdir = joinpath(root_path, \"global_diagnostics\")\noutdir =\n    ClimaUtilities.OutputPathGenerator.generate_output_path(diagnostics_outdir);\n\nSet timestep, startdate, stopdate:\n\nΔt = 900.0\nstart_date = DateTime(2008)\nstop_date = DateTime(2009);\n\nCreate the domain - this is intentionally low resolution, about 4.5 degrees x 4.5 degrees, to run quickly when making the documentation on CPU.\n\nnelements = (20, 7)\ndepth = FT(3.5)\ndz_tuple = FT.((1.0, 0.05))\ndomain =\n    ClimaLand.Domains.global_domain(FT; context, nelements, depth, dz_tuple);\n\nParameters:\n\ntoml_dict = LP.create_toml_dict(FT)\nα_snow = FT(0.8)\nalbedo = PrescribedBaregroundAlbedo{FT}(α_snow, domain.space.surface)\nbucket_parameters = BucketModelParameters(\n    toml_dict;\n    albedo,\n    σS_c = FT(0.2),\n    W_f = FT(0.2),\n    z_0m = FT(1e-3),\n    z_0b = FT(1e-3),\n    κ_soil = FT(1.5),\n    ρc_soil = FT(2e6),\n    τc = FT(float(Δt)),\n);\n\nLow-resolution forcing data from ERA5 is used here, but high-resolution should be used for production runs.\n\natmos, radiation = ClimaLand.prescribed_forcing_era5(\n    start_date,\n    stop_date,\n    domain.space.surface,\n    toml_dict,\n    FT;\n    use_lowres_forcing = true,\n    max_wind_speed = 25.0,\n    time_interpolation_method = LinearInterpolation(PeriodicCalendar()),\n    regridder_type = :InterpolationsRegridder,\n    context,\n);\n\nMake the model:\n\nbucket = BucketModel(\n    parameters = bucket_parameters,\n    domain = domain,\n    atmosphere = atmos,\n    radiation = radiation,\n);\n\nCreate a function which sets the initial conditions. This should have the argument structure (Y,p,t, model) in order to be used by the LandSimulation struct, below:\n\nfunction set_ic!(Y, p, t, bucket)\n    coords = ClimaCore.Fields.coordinate_field(Y.bucket.T)\n    T_sfc_0 = 271.0\n    @. Y.bucket.T = T_sfc_0 + 40 * cosd(coords.lat)^4\n    Y.bucket.W .= 0.15\n    Y.bucket.Ws .= 0.0\n    Y.bucket.σS .= 0.0\nend\n\nset_ic! (generic function with 1 method)\n\nDefine timestepper and ODE algorithm\n\ntimestepper = CTS.RK4()\ntimestepper = CTS.ExplicitAlgorithm(timestepper);\n\nCreate the simulation and solve it:\n\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    Δt,\n    bucket;\n    set_ic!,\n    timestepper,\n    outdir,\n    user_callbacks = (),\n);\n\nsolve!(simulation);\n\nMake some plots:\n\nshort_names = [\"lhf\", \"shf\", \"wsoil\"]\n\nLandSimVis.make_annual_timeseries(\n    simulation;\n    savedir = \".\",\n    short_names,\n    plot_stem_name = \"bucket_annual_timeseries\",\n)\n\n(Image: ) (Image: ) (Image: )\n\nLandSimVis.make_heatmaps(\n    simulation;\n    savedir = \".\",\n    short_names,\n    date = stop_date,\n    plot_stem_name = \"bucket_heatmap\",\n)\n\n(Image: ) (Image: ) (Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/soil/SoilBiogeochemistry/#Soil-Biogeochemistry","page":"Soil Biogeochemistry","title":"Soil Biogeochemistry","text":"","category":"section"},{"location":"APIs/soil/SoilBiogeochemistry/#This-component-model-is-available-for-use,-but-is-still-under-development-and-is-not-yet-fully-debugged.-Note-that-errors-in-this-component-do-not-propagate-back-to-other-component-models.","page":"Soil Biogeochemistry","title":"This component model is available for use, but is still under development and is not yet fully debugged. Note that errors in this component do not propagate back to other component models.","text":"","category":"section"},{"location":"APIs/soil/SoilBiogeochemistry/#Model-Structure","page":"Soil Biogeochemistry","title":"Model Structure","text":"","category":"section"},{"location":"APIs/soil/SoilBiogeochemistry/#Parameter-Structure","page":"Soil Biogeochemistry","title":"Parameter Structure","text":"","category":"section"},{"location":"APIs/soil/SoilBiogeochemistry/#Model-specific-Types","page":"Soil Biogeochemistry","title":"Model-specific Types","text":"","category":"section"},{"location":"APIs/soil/SoilBiogeochemistry/#Functions-of-State","page":"Soil Biogeochemistry","title":"Functions of State","text":"","category":"section"},{"location":"APIs/soil/SoilBiogeochemistry/#Extendible-Functions","page":"Soil Biogeochemistry","title":"Extendible Functions","text":"","category":"section"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilCO2Model","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilCO2Model","text":"SoilCO2Model\n\nA model for simulating the production and transport of CO₂ in the soil with dynamic source and diffusion terms.\n\nClimaLand v1: SoilCO2 is still under testing; in particular, in global runs, an instability appears in some columns, and the prognostic equation does not enforce the positivity of CO2.\n\nparameters: the parameter set\ndomain: the soil domain, using ClimaCore.Domains\nboundary_conditions: the boundary conditions, of type NamedTuple\nsources: A tuple of sources, each of type AbstractSource\ndrivers: Drivers\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilCO2ModelParameters","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilCO2ModelParameters","text":"SoilCO2ModelParameters{FT <: AbstractFloat, PSE}\n\nA struct for storing parameters of the SoilCO2Model.\n\nAll of these parameters are currently treated as global constants.\n\nD_ref: Diffusion coefficient for CO₂ in air at standard temperature and pressure (m² s⁻¹)\nD_liq: Diffusivity of soil C substrate in liquid (unitless)\nα_sx: Pre-exponential factor (kg C m-3 s-1)\nEa_sx: Activation energy (J mol-1)\nkM_sx: Michaelis constant (kg C m-3)\nkM_o2: Michaelis constant for O2 (m3 m-3)\nO2_f_atm: Volumetric fraction of O₂ in atmospheric air (reference value for boundary condition), dimensionless\nD_oa: Diffusion coefficient of oxygen in air, dimensionless\np_sx: Fraction of soil carbon that is considered soluble, dimensionless\nM_C: Molar mass of carbon (kg/mol)\nM_O2: Molar mass of oxygen (kg/mol)\nearth_param_set: Physical constants used Clima-wide\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilCO2ModelParameters-Tuple{ClimaParams.ParamDict}","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilCO2ModelParameters","text":"SoilCO2ModelParameters(toml_dict::CP.ParamDict)\n\nSoilCO2ModelParameters provides a constructor using the TOML dict. Keywords arguments can be used to directly override any parameters.\n\n\n\n\n\n","category":"method"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.MicrobeProduction","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.MicrobeProduction","text":"MicrobeProduction{FT} <: AbstractCarbonSource{FT}\n\nStruct for the microbe production of CO2, appearing as a source term in the differential equation.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilCO2FluxBC","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilCO2FluxBC","text":"SoilCO2FluxBC <: ClimaLand.AbstractBC\n\nA container holding the CO2 flux boundary condition, which is a function f(p,t), where p is the auxiliary state vector.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilCO2StateBC","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilCO2StateBC","text":"SoilCO2StateBC <: ClimaLand.AbstractBC\n\nA container holding the CO2 state boundary condition (kg CO2 m−3), which is a function f(p,t), where p is the auxiliary state vector.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.AtmosCO2StateBC","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.AtmosCO2StateBC","text":"AtmosCO2StateBC <: ClimaLand.AbstractBC\n\nSet the CO2 concentration to the atmospheric one.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.AtmosO2StateBC","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.AtmosO2StateBC","text":"AtmosO2StateBC{FT} <: ClimaLand.AbstractBC\n\nSet the O2 mass concentration to the atmospheric one. Stores physical constants needed for the boundary flux calculation.\n\nR: Universal gas constant (J/(mol·K))\nM_O2: Molar mass of oxygen (kg/mol)\nO2_f_atm: Atmospheric O2 volumetric fraction (dimensionless)\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.AbstractSoilDriver","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.AbstractSoilDriver","text":"AbstractSoilDriver\n\nAn abstract type for drivers of soil CO2 production and diffusion. These are soil temperature, soil moisture, root carbon, soil organic matter and microbe carbon, and atmospheric pressure. Soil temperature and moisture, as well as soc, vary in space (horizontally and vertically) and time. Atmospheric pressure vary in time (defined at the surface only, not with depth).\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilDrivers","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilDrivers","text":"SoilDrivers\n\nA container which passes in the soil drivers to the biogeochemistry model. These drivers are either of type Prescribed (for standalone mode) or Prognostic (for running with a prognostic model for soil temp and moisture).\n\nmet: Soil temperature and moisture drivers - Prescribed or Prognostic\natmos: Prescribed or coupled atmospheric variables\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.PrescribedMet","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.PrescribedMet","text":"PrescribedMet <: AbstractSoilDriver\n\nA container which holds the prescribed functions for soil temperature and moisture.\n\nThis is meant for use when running the biogeochemistry model in standalone mode, without a prognostic soil model.\n\ntemperature: The temperature of the soil, of the form f(z::FT,t) where FT <: AbstractFloat\nvolumetric_liquid_fraction: Soil moisture, of the form f(z::FT,t) FT <: AbstractFloat\nν: Soil porosity (m³ m⁻³)\nθ_a100: Air-filled porosity at soil water potential of -100 cm H₂O (~ 10 Pa)\nb: Absolute value of the slope of the line relating log(ψ) versus log(S) (unitless)\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.volumetric_air_content","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.volumetric_air_content","text":"volumetric_air_content(θ_w::FT,\n                       ν::FT,\n                       ) where {FT}\n\nComputes the volumetric air content (θ_a) in the soil, which is related to the total soil porosity (ν) and volumetric soil water content (θ_w = θ_l+θ_i).\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.co2_diffusivity","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.co2_diffusivity","text":"co2_diffusivity(\n                T_soil::FT,\n                θ_w::FT,\n                P_sfc::FT,\n                θ_a100::FT,\n                b::FT,\n                ν::FT,\n                params::SoilCO2ModelParameters{FT},\n                ) where {FT}\n\nComputes the diffusivity of CO₂ within the soil (D).\n\nFirst, D0 is computed using the temperature within the soil (T_soil in K) and pressure at the surface of the soil (P_sfc in Pa), using reference values of T_ref and P_ref (273 K and 101325 Pa). Here, θ_a is the volumetric air content and θ_a100 is the volumetric air content at a soil water potential of 100cm, and b is the pore size distribution of the soil.\n\nThis parameterization is from Ryan et al., GMD 11, 1909-1928, 2018, https://doi.org/10.5194/gmd-11-1909-2018.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.microbe_source","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.microbe_source","text":"microbe_source(T_soil::FT,\n               θ_l::FT,\n               Csom::FT,\n               O2_avail::FT,\n               params::SoilCO2ModelParameters{FT}\n               ) where {FT}\n\nComputes the CO₂ production in the soil by microbes, in depth and time (kg C / m^3/s), using the Dual Arrhenius Michaelis Menten model (Davidson et al., 2012). O2_avail is a dimensionless O₂ availability metric that accounts for tortuosity effects.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.o2_availability","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.o2_availability","text":"o2_availability(O2_f::FT,\n                θ_a::FT,\n                D_oa::FT,\n                ) where {FT}\n\nComputes the dimensionless O₂ availability for microbial kinetics using the Millington-Quirk tortuosity model.\n\nThe O2 availability accounts for diffusion limitations in porous media:     O2avail = Doa * O2f * θa^(4/3)\n\nwhere:\n\nO2_f: volumetric fraction of O2 in air (dimensionless, ~0.21)\nθ_a: volumetric air content (m³ air / m³ soil)\nD_oa: oxygen diffusion coefficient in air (dimensionless)\nθ_a^(4/3): Millington-Quirk tortuosity factor\n\nThis is used in Michaelis-Menten kinetics for microbial respiration.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.o2_concentration","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.o2_concentration","text":"o2_concentration(O2_f::FT,\n                 T_soil::FT,\n                 P_sfc::FT,\n                 params::SoilCO2ModelParameters{FT},\n                 ) where {FT}\n\nComputes the O₂ mass concentration in air (kg O2/m³ air) from the volumetric fraction O2_f, using the ideal gas law.\n\nThe O2 mass concentration in the air phase is:     ρO2air = O2f * P * MO2 / (R * T)\n\nwhere:\n\nO2_f : volumetric fraction of O2 in air (dimensionless, ~0.21)\nP: pressure (Pa)\nM_O2: molar mass of O2 (kg/mol) - from parameters\nR: universal gas constant (J/(mol·K)) - from ClimaParams\nT: temperature (K)\n\nNote: This returns concentration per m³ of air, not per m³ of soil. For diffusion in soil, the effective concentration per m³ of soil would be θa * ρO2_air, but that multiplication is handled separately in the diffusion equation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.o2_fraction_from_concentration","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.o2_fraction_from_concentration","text":"o2_fraction_from_concentration(ρ_O2_air::FT,\n                                T_soil::FT,\n                                P_sfc::FT,\n                                params::SoilCO2ModelParameters{FT},\n                                ) where {FT}\n\nComputes the O₂ volumetric fraction (dimensionless) from the O₂ mass concentration in air, using the ideal gas law. This is the inverse of o2_concentration.\n\nThe O2 volumetric fraction is:     O2f =ρO2air * R * T / (P * MO2)\n\nwhere:\n\nρO2air: O2 mass concentration in air (kg O2/m³ air)\nP: pressure (Pa)\nM_O2: molar mass of O2 (kg/mol) - from parameters\nR: universal gas constant (J/(mol·K)) - from ClimaParams\nT: temperature (K)\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.soil_moisture","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.soil_moisture","text":"soil_moisture(driver::PrognosticSoil, p, Y, t, z)\n\nReturns the volumetric liquid fraction, computed by the soil model from the prognostic liquid and ice fractions.\n\n\n\n\n\nsoil_moisture(driver::PrescribedMet, p, Y, t, z)\n\nReturns the soil moisture at location (z) and time (t) for the prescribed soil case.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.soil_temperature","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.soil_temperature","text":"soil_temperature(driver::PrognosticSoil, p, Y, t, z)\n\nReturns the prognostic soil temperature.\n\n\n\n\n\nsoil_temperature(driver::PrescribedMet, p, Y, t, z)\n\nReturns the soil temperature at location (z) and time (t) for the prescribed soil case.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nio = IOBuffer()\nv = filter(x-> x.second.name == \"ClimaLand\", Pkg.dependencies()) |> x -> first(x)[2].version\nprint(io, \"\"\"\n    # ClimaLand.jl Documentation (v$(v))\n\n    \"\"\")\nimport Markdown\nMarkdown.parse(String(take!(io)))","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"ClimaLand is the Land model of the Climate Modeling Alliance (CliMA) Earth System Model, which also contains other components (atmosphere, ocean, sea-ice). Details about the CliMA project can be found on the project website.\n\nClimaLand can be run coupled (\"online\") with these other components via ClimaCoupler, or it can be run as a standalone model, via prescribed meteorological data (\"offline\").\n\nThe ClimaLand library, described in this documentation, is written in the Julia programming language. It aims to be fast and have a clear syntax. ClimaLand can run on CPU or GPU, it has a modular design, and is flexible in many ways. This documentation will expand on each of these elements.","category":"section"},{"location":"#Documentation-for-Users-and-Developers","page":"Home","title":"Documentation for Users and Developers","text":"ClimaLand has documentation for both users and developers. The documentation for users is aimed at scientists who wants to run simulations using ClimaLand, whereas the documentation for developers is aimed at contributors of the ClimaLand code library. As such, users can skip reading the docs for developers, and vice-versa.","category":"section"},{"location":"#This-documentation-includes-information-about:","page":"Home","title":"This documentation includes information about:","text":"How to run your first ClimaLand simulation\nA series of tutorials explaining ClimaLand models and physics\nThe structure of ClimaLand models and code\nHow to analyze model output, calibrate models using CliMA's pipeline, and restart simulations\nand more!","category":"section"},{"location":"#Important-Links","page":"Home","title":"Important Links","text":"CliMA GitHub Organisation\nJulia Homepage\nJulia Manual","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/piecewise_model/#Piecewise-Soil-Moisture-Stress","page":"Piecewise model","title":"Piecewise Soil Moisture Stress","text":"This page documents the piecewise (linear/threshold with curvature) soil moisture stress function used in ClimaLand's vegetation module. The stress factor beta in 01 scales leaf photosynthesis (and thus stomatal conductance) as soil moisture declines, following a simple, interpretable formulation. See Egea et al. [27], the ClimaLand code is here.\n\n","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/piecewise_model/#Summary","page":"Piecewise model","title":"Summary","text":"Purpose: convert soil wetness to a stress multiplier that reduces assimilation and stomatal conductance.\nInputs: volumetric soil water content theta (or relative water content), model thresholds.\nOutputs: scalar stress factor beta applied within the photosynthesis/stomatal sub-models.\n\n","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/piecewise_model/#Model-formulation","page":"Piecewise model","title":"Model formulation","text":"Let theta be the volumetric water content at some depth. Define two thresholds:\n\nFirst, theta_low — wilting (or residual) water content: below this, stress is total (beta = 0).\n\nSecond, theta_high — Field capacity (or porosity) water content: above this, no stress (beta = 1).\n\nWith theta_low  theta_high, the stress factor is\n\nbeta(theta) =\nbegincases\n0  theta leq theta_low \nleft( dfractheta - theta_lowtheta_high - theta_low right)^c  theta_low  theta  theta_high \n1  theta geq theta_high \nendcases\n\n","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/piecewise_model/#Variables-and-units","page":"Piecewise model","title":"Variables & units","text":"Quantity Symbol Units Notes\nVolumetric water content theta m³ m⁻³ root-zone or layer-weighted\nLow water content threshold theta_low m³ m⁻³ wilting point or residual\nHigh water content threshold theta_high m³ m⁻³ field capacity or porosity\nStress multiplier beta – 0 (full stress) … 1 (no stress)\nCurvature parameter c – controls concavity of the stress response\n\n","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/piecewise_model/#Parameters","page":"Piecewise model","title":"Parameters","text":"Parameter Description Example range\ntheta_low lower threshold (wilting or residual) 0.05–0.15\ntheta_high upper threshold (field capacity or porosity) 0.55–0.75\nc curvature parameter shaping the transition 1–5\n\n","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/piecewise_model/#Numerical-details-and-coupling","page":"Piecewise model","title":"Numerical details & coupling","text":"Soil moisture, theta, is either prescribed as a single value in the root zone (for standalone canopy models, with a prescribed soil component), or else we compute beta as a factor of depth using theta as a function of depth, as specified by the prognostic soil model. In the latter case, we then average beta(z) over the column using the root distribution function (also a function ofz), as a weighting factor.\n\nScalar stress, beta, multiplies leaf assimilation, A_n, which in turn reduces g_s that scales with A_n.\n\n","category":"section"},{"location":"references/#References","page":"References","title":"References","text":"S. Manabe. Climate and the Ocean Circulation: I. The Atmospheric Circulation and the Hydrology of the Earth's Surface. Monthly Weather Review 97, 739–774 (1969).\n\n\n\nP. C. Milly and A. B. Shmakin. Global Modeling of Land Water and Energy Balances. Part I: The Land Dynamics (LaD) Model. Journal of Hydrometeorology 3, 283–299 (2002).\n\n\n\nM. M. Laguë, G. B. Bonan and A. L. Swann. Separating the Impact of Individual Land Surface Properties on the Terrestrial Surface Energy Budget in Both the Coupled and Uncoupled Land–Atmosphere System. Journal of Climate 32, 5725–5744 (2019).\n\n\n\nC. S. Woodward and C. N. Dawson. Analysis of Operator-Splitting Approaches to Advection-Diffusion-Reaction Equations. SIAM Journal on Numerical Analysis 37, 701–724 (2000).\n\n\n\nG. B. Bonan. Climate Change and Terrestrial Ecosystem Modeling (Cambridge University Press, Cambridge, UK, 2019).\n\n\n\nM. Mizoguchi. Water, Heat and Salt Transport in Freezing Soil. Ph.D. Thesis, University of Tokyo (1990). Ph.D. thesis, in Japanese.\n\n\n\nK. Hansson, P.-E. Jansson, J. Šimůnek and L.-C. Lundin. Simulating Water and Heat Transport in Frozen Soil with Coupled Heat and Mass Transfer Model. Vadose Zone Journal 3, 693–704 (2004).\n\n\n\nM. Dall’Amico, S. Endrizzi, S. Gruber and R. Rigon. A robust and energy-conserving model of freezing variably-saturated soil. The Cryosphere 5, 469–484 (2011).\n\n\n\nB. L. Kurylyk and K. Watanabe. The Mathematical Representation of Freezing and Thawing Processes in Variably-Saturated, Non-Deformable Soils. Advances in Water Resources 60, 160–177 (2013).\n\n\n\nK. Watanabe, B. L. Kurylyk and S. K. Carey. Performance Evaluation of a Physics-Based Permafrost Model across a Range of Climate Conditions. Annals of Glaciology 52, 61–69 (2011).\n\n\n\nS. L. Painter and S. Karra. Constitutive Model for Unfrozen Water Content in Subfreezing Unsaturated Soils. Vadose Zone Journal 13, 1–8 (2014).\n\n\n\nH. Carslaw and J. Jaeger. Conduction of Heat in Solids. 2 Edition (Clarendon Press, Oxford, 1959).\n\n\n\nS. Huang, G. Pavlic, K. C. Van Rees, K. J. Van Rees and J. Feng. Numerical Simulation of Coupled Water and Heat Transport in Freezing Soils: Model Development and Validation. Canadian Journal of Soil Science 91, 169–183 (2011).\n\n\n\nP. Lehmann, S. Assouline and D. Or. Characteristic Lengths Affecting Evaporation from Heterogeneous Porous Media. Physical Review E 77, 056309 (2008).\n\n\n\nH. R. Gardner. Post-Irrigation Movement of Soil Water: 2. Simultaneous Redistribution and Evaporation Following Irrigation. Water Resources Research 6, 9999 (1970).\n\n\n\nP. Lehmann and D. Or. Analytical model for bare soil evaporation dynamics following wetting with concurrent internal drainage. Journal of Hydrology 631, 130800 (2024).\n\n\n\nP. J. Lawrence and T. N. Chase. Representing a MODIS-Consistent Land Surface in the Community Land Model (CLM 3.0). Journal of Geophysical Research: Biogeosciences 112, G01023 (2007).\n\n\n\nH. Hersbach, B. Bell, P. Berrisford, S. Hirahara, A. Horányi, J. Muñoz-Sabater, J. Nicolas, C. Peubey, R. Radu, D. Schepers, A. Simmons, C. Soci, S. Abdalla, X. Abellan, G. Balsamo, P. Bechtold, G. Biavati, J.-R. Bidlot, M. Bonavita, G. De Chiara, P. Dahlgren, D. Dee, M. Diamantakis, R. Dragani, J. Flemming, R. Forbes, M. Fuentes, A. J. Geer, L. Haimberger, S. Healy, R. J. Hogan, E. Hólm, M. Janisková, S. Keeley, P. Laloyaux, P. Lopez, C. Lupu, G. Radnoti, P. de Rosnay, I. Rozum, F. Vamborg, S. Villaume and J.-N. Thépaut. The ERA5 Global Reanalysis. Quarterly Journal of the Royal Meteorological Society 146, 1999–2049 (2020).\n\n\n\nY. Wang, P. Köhler, L. He, R. Doughty, R. K. Braghiere, J. D. Wood and C. Frankenberg. Testing stomatal models at the stand level in deciduous angiosperm and evergreen gymnosperm forests using CliMA Land (v0.1). Geoscientific Model Development 14, 6741–6763 (2021).\n\n\n\nA. Charbonneau, K. Deck and T. Schneider. A Physics‐Constrained Neural Differential Equation Framework for Data‐Driven Snowpack Simulation, arXiv preprint arXiv:2412.06819 (2024). Submitted to Artificial Intelligence for Earth Sciences.\n\n\n\nU.S. Department of Agriculture, Natural Resources Conservation Service. National Engineering Handbook, Part 622: Snow Survey and Water Supply Forecasting (SNOTEL Engineering Handbook) (U.S. Department of Agriculture, Natural Resources Conservation Service, Washington, D.C., 2014). Title 210, NEH, Part 622.\n\n\n\nJ. D. Wood and L. Gu. AmeriFlux FLUXNET-1F US-MOz Missouri Ozark Site, Ver. 5-7 (2025). Dataset.\n\n\n\nP. D. Blanken, R. K. Monson, S. P. Burns, D. R. Bowling and A. A. Turnipseed. AmeriFlux FLUXNET-1F US-NR1 Niwot Ridge Forest (LTER NWT1), Ver. 3-5 (2022). Dataset.\n\n\n\nS. Ma, L. Xu, J. Verfaillie and D. Baldocchi. AmeriFlux FLUXNET-1F US-Var Vaira Ranch-Ione, Ver. 3-5 (2023). Dataset.\n\n\n\nJ. W. Munger. AmeriFlux FLUXNET-1F US-Ha1 Harvard Forest EMS Tower (HFR1), Ver. 3-5 (2022). Dataset.\n\n\n\nJ.-E. Lee, C. Frankenberg, C. van der Tol, J. Berry, L. Guanter, C. K. Boyce, J. B. Fisher, E. Morrow, J. Worden, S. Asefi, G. Badgley and S. Saatchi. Forest productivity and water stress in Amazonia: observations from GOSAT chlorophyll fluorescence. Global Change Biology 21, 3469–3477 (2015).\n\n\n\nG. Egea, A. Verhoef and P. Vidale. On the treatment of plant water stress in coupled photosynthesis–stomatal conductance models: implications for large-scale modeling. Agricultural and Forest Meteorology 151, 1370–1384 (2011).\n\n\n\nA. Tuzet, A. Perrier and R. Leuning. A coupled model of stomatal conductance, photosynthesis and transpiration. Plant, Cell & Environment 26, 1097–1116 (2003).\n\n\n\nR. A. Duursma and B. E. Medlyn. MAESPA: A model to study interactions between water limitation, environmental drivers and vegetation function at tree and stand levels, with an example application to CO2 × drought interactions. Geoscientific Model Development 5, 919–940 (2012).\n\n\n\nD. B. Clark, L. M. Mercado, S. Sitch, C. D. Jones, N. Gedney, M. J. Best, M. Pryor, G. G. Rooney, R. L. Essery, E. Blyth, O. Boucher, R. J. Harding, C. Huntingford and P. M. Cox. The Joint UK Land Environment Simulator (JULES), model description–Part 2: carbon fluxes and vegetation dynamics. Geoscientific Model Development 4, 701–722 (2011).\n\n\n\nE. A. Davidson, S. Samanta, S. S. Caramori and K. Savage. The Dual Arrhenius and Michaelis-Menten kinetics model for decomposition of soil organic matter at hourly to seasonal time scales. Global Change Biology 18, 371–384 (2012).\n\n\n\nE. M. Ryan, K. Ogle, D. M. Peltier, A. P. Walker, M. G. De Kauwe, B. E. Medlyn, D. G. Williams, W. Parton, S. Asao, B. Guenet, R. Lauerwald, N. Carvalhais, P. Ciais, O. Chertov, C. Barton, A. Degasperi, H. Genet, M. Huang, D. S. Jenkinson, C. D. Koven, Y. Kuzyakov, Y. Luo, S. Manzoni, A. D. McGuire, J. Parr, E. Pendall, R. N. Sampson, P. Smith, A. F. Talhelm, C. Tucker and W. R. Wieder. Gross primary production responses to warming, elevated CO₂, and irrigation: quantifying the drivers of ecosystem physiology in a semiarid grassland. Geoscientific Model Development 11, 1909–1928 (2018).\n\n\n\n","category":"section"},{"location":"architectures/#Running-on-GPU-or-with-MPI","page":"Running on GPU or with MPI","title":"Running on GPU or with MPI","text":"ClimaLand.jl is designed to run on either CPU or GPU, and to be compatible with MPI. This section will explain how to select the architecture you want to run your simulation on.\n\nThe CliMA ecosystem uses ClimaComms.jl to control which architecture to run on, and related internals are handled within that package. This isolation makes specifying the architecture to use relatively simple.\n\nClimaComms.jl introduces two concepts that we utilize to define the architecture to run a simulation on: the device and the context.\n\nThe device specifies whether we want to run on CPU or GPU. The context contains information about the device, and also defines whether we want to run on an individual processor or distributedly with MPI. Since the device is contained within the context's data structure, when we construct these objects in ClimaLand we simply refer to them as the context.\n\nBelow, we have descriptions for how to specify the context when trying to run a simulation in different setups. There are two ways to do this: internally within a script/REPL, or in the terminal via environment variables.\n\nFor more detailed information, please see the ClimaComms.jl documentation.","category":"section"},{"location":"architectures/#Choosing-the-architecture-within-a-script/REPL","page":"Running on GPU or with MPI","title":"Choosing the architecture within a script/REPL","text":"To select the architecture to use within a script or the REPL, we will explicitly set the device and context to use. The context is then automatically used for the rest of the session.","category":"section"},{"location":"architectures/#Running-on-CPU-(without-MPI)","page":"Running on GPU or with MPI","title":"Running on CPU (without MPI)","text":"context = ClimaComms.SingletonCommsContext(ClimaComms.CPUSingleThreaded())","category":"section"},{"location":"architectures/#Running-on-GPU-(without-MPI)","page":"Running on GPU or with MPI","title":"Running on GPU (without MPI)","text":"context = ClimaComms.SingletonCommsContext(ClimaComms.CUDADevice())","category":"section"},{"location":"architectures/#Running-with-MPI","page":"Running on GPU or with MPI","title":"Running with MPI","text":"On CPU:\n\ncontext = ClimaComms.MPICommsContext(ClimaComms.CPUSingleThreaded())\n\nOn GPU:\n\ncontext = ClimaComms.MPICommsContext(ClimaComms.CUDADevice())","category":"section"},{"location":"architectures/#Default-context-and-device","page":"Running on GPU or with MPI","title":"Default context and device","text":"We can also set the context using the following default constructor. This is useful for runs where we want to run on CPU and don't have MPI available, perhaps for example in simple local runs.\n\ncontext = ClimaComms.context()\n\nThis constructor will by default run on CPU without MPI, unless the relevant environment variables are set. See the section below for more details about controlling the architecture with environment variables.","category":"section"},{"location":"architectures/#Choosing-the-architecture-via-environment-variables","page":"Running on GPU or with MPI","title":"Choosing the architecture via environment variables","text":"ClimaComms checks two environment variables to determine which device and context to use: CLIMACOMMS_DEVICE and CLIMACOMMS_CONTEXT. Setting these environment variables provides an alternative to defining the device and context explicitly, as was done above.","category":"section"},{"location":"architectures/#Running-on-CPU-(without-MPI)-2","page":"Running on GPU or with MPI","title":"Running on CPU (without MPI)","text":"ENV[\"CLIMACOMMS_DEVICE\"] = \"CPU\"\nENV[\"CLIMACOMMS_CONTEXT\"] = \"SINGLETON\"","category":"section"},{"location":"architectures/#Running-on-GPU-(without-MPI)-2","page":"Running on GPU or with MPI","title":"Running on GPU (without MPI)","text":"ENV[\"CLIMACOMMS_DEVICE\"] = \"CUDA\"\nENV[\"CLIMACOMMS_CONTEXT\"] = \"SINGLETON\"","category":"section"},{"location":"architectures/#Running-with-MPI-2","page":"Running on GPU or with MPI","title":"Running with MPI","text":"On CPU:\n\nENV[\"CLIMACOMMS_DEVICE\"] = \"CPU\"\nENV[\"CLIMACOMMS_CONTEXT\"] = \"MPI\"\n\nOn GPU:\n\nENV[\"CLIMACOMMS_DEVICE\"] = \"CUDA\"\nENV[\"CLIMACOMMS_CONTEXT\"] = \"MPI\"","category":"section"},{"location":"contributing/#Contributing","page":"Contributor guide","title":"Contributing","text":"Thank you for contributing to ClimaLand! We encourage Pull Requests (PRs). Please do not hesitate to ask questions, or to open issues if something seems amiss or you'd like a new feature.","category":"section"},{"location":"contributing/#Some-useful-tips","page":"Contributor guide","title":"Some useful tips","text":"When developing code it's best to work on a branch off of the most recent main.\n\nThis can be done by running the following commands, where \"initials\" corresponds to the first and last initial of the person starting the branch.\n\ngit checkout main\ngit pull\ngit checkout -b initials/branch_name\n\nMake sure you add tests for your code in test/, appropriate documentation in docs/, and descriptive inline comments throughout the code. All exported functions and structs must have docstrings.\nWhen your PR is ready for review, clean up your commit history by squashing to 1 commit per PR and make sure your code is current with ClimaLand.jl main by rebasing.","category":"section"},{"location":"contributing/#Continuous-integration","page":"Contributor guide","title":"Continuous integration","text":"After rebasing your branch, you can ask for review. Fill out the template and provide a clear summary of what your PR does. When a PR is created or updated, a set of automated tests are run on the PR in our continuous integration (CI) system.\n\nClimaLand.jl's continuous integration contains multiple automated tests, which are described below. All of these must pass for a PR to be eligible to merge into the main branch.","category":"section"},{"location":"contributing/#Unit-testing","page":"Contributor guide","title":"Unit testing","text":"Unit tests are defined in the test/ folder, and are all listed in the file test/runtests.jl, which allows them to easily be called together. In our CI, these tests are run via Github Actions on a variety of operating systems and Julia versions. We also use downgrade tests to check the lower limits of our Julia package compat bounds, and downstream tests to verify compatibility with ClimaCoupler.jl.","category":"section"},{"location":"contributing/#Buildkite-pipeline","page":"Contributor guide","title":"Buildkite pipeline","text":"The buildkite pipeline contains a variety of ClimaLand simulations, which span the complexity of our models and domains. Some of these simulations have explicit checks, for example comparing to empirical solutions or output from external codebases, while others test that the simulation can run without error.\n\nThis pipeline also runs our unit test suite on GPU and with MPI, to ensure all of our source code is compatible with those setups.","category":"section"},{"location":"contributing/#Formatting-check","page":"Contributor guide","title":"Formatting check","text":"The JuliaFormatter test checks if the PR is correctly formatted according to the project's style guidelines. The previous .dev/climaformat.jl script has been discontinued in favor of using the JuliaFormatter package directly.\n\nTo format your code, first add JuliaFormatter to your base environment:\n\njulia -e 'using Pkg; Pkg.add(PackageSpec(\"JuliaFormatter\", v\"1.0.62\"))'\n\nThen, in a Julia REPL, run:\n\nusing JuliaFormatter; format(\".\")","category":"section"},{"location":"contributing/#Documentation","page":"Contributor guide","title":"Documentation","text":"The Documentation test rebuilds the documentation for the PR and checks if the docs are consistent and generate valid output.\n\nTo add internal references, for example to another documentation page or API, see the relevant Documenter.jl @ref documentation page, example syntax: [see contributor guide](@ref \"Contributing\") for a page or [Abstract type for soil model](@ref ClimaLand.Soil.AbstractSoilModel) for an API.\n\nTo add external references, for example to another package documentation page or API, see the documentation of DocumenterInterLinks. Example syntax: [how to us @ref](@extref Documenter Named-@refs).\n\nTo add a reference from the literature, see the documentation of DocumenterCitations.jl, in short, add your reference to docs/src/refs.bib and then refer to it with this syntax [authors1999](@citet).","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/tuzet_model/#Tuzet-Soil-Moisture-(Water-Potential)-Stress","page":"Tuzet model","title":"Tuzet Soil Moisture (Water Potential) Stress","text":"This page documents the Tuzet stress function used to scale leaf net assimilation and stomatal conductance as a function of plant water potential. It provides a smooth, sigmoidal decline in conductance with decreasing (more negative) leaf/xylem water potential. See Tuzet et al. [28] and Duursma and Medlyn [29]. The ClimaLand code can be found here.\n\n","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/tuzet_model/#Summary","page":"Tuzet model","title":"Summary","text":"Purpose: compute a water‑status stress multiplier beta in 01 from leaf (or xylem) water potential.\nInputs: leaf/xylem water potential psi (Pa), parameters controlling the midpoint and slope.\nOutputs: scalar stress factor beta applied within stomatal/photosynthesis sub‑models.\n\n","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/tuzet_model/#Model-formulation","page":"Tuzet model","title":"Model formulation","text":"We compute the stress factor using the following formulation:\n\nbeta = minBigg(1 frac1 + e^s_c  p_c1 + e^s_c  (p_c - p_leaf)Bigg)\n\nwith\n\nThe leaf water pressure p_leaf (Pa),\n\nThe reference water pressure p_c (Pa),\n\nThe sensitivity to low water pressure s_c (Pa^-1).\n\n","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/tuzet_model/#Variables-and-units","page":"Tuzet model","title":"Variables & units","text":"Quantity Symbol Units Notes\nLeaf water pressure p_leaf Pa typically ≤ 0 (tension)\nReference potential p_c Pa location of curve midpoint\nSensitivity s_c Pa⁻¹ slope/steepness of response\nStress multiplier beta – 0 (full stress) … 1 (no stress)\n\n","category":"section"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Eventually this will be a bare soil site experiment, showing how to set up the soil model in a column with prescribed forcing and comparing to data.\n\nusing CairoMakie\nimport SciMLBase\nimport ClimaTimeSteppers as CTS\nusing Thermodynamics\n\nusing ClimaCore\nimport ClimaParams as CP\nusing SurfaceFluxes\nusing StaticArrays\nusing Dates\nusing DelimitedFiles: readdlm\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\nimport ClimaLand.Simulations: LandSimulation, solve!\nimport ClimaLand\nimport ClimaLand.Parameters as LP\nimport SurfaceFluxes.Parameters as SFP\n\nFT = Float64;\ntoml_dict = LP.create_toml_dict(FT)\nearth_param_set = LP.LandParameters(toml_dict)\nthermo_params = LP.thermodynamic_parameters(earth_param_set);\n\nstart_date = DateTime(2005)\nstop_date = start_date + Day(4)\ndt = Float64(10)\nSW_d = (t) -> 0\nLW_d = (t) -> 270.0^4 * 5.67e-8\nradiation = PrescribedRadiativeFluxes(\n    FT,\n    TimeVaryingInput(SW_d),\n    TimeVaryingInput(LW_d),\n    start_date,\n);\n\nSet up atmospheric conditions that result in the potential evaporation rate obsereved in the experiment. Some of these conditions are reported in the paper.\n\nT_air = FT(270.0)\nrh = FT(0.38)\nesat = Thermodynamics.saturation_vapor_pressure(\n    thermo_params,\n    T_air,\n    Thermodynamics.Liquid(),\n)\ne = rh * esat\nq = FT(0.622 * e / (101325 - 0.378 * e))\nprecip = (t) -> 0.0\nT_atmos = (t) -> T_air\nu_atmos = (t) -> 1.0\nq_atmos = (t) -> q\nh_atmos = FT(0.1)\nP_atmos = (t) -> 101325\ngustiness = FT(1e-2)\natmos = PrescribedAtmosphere(\n    TimeVaryingInput(precip),\n    TimeVaryingInput(precip),\n    TimeVaryingInput(T_atmos),\n    TimeVaryingInput(u_atmos),\n    TimeVaryingInput(q_atmos),\n    TimeVaryingInput(P_atmos),\n    start_date,\n    h_atmos,\n    toml_dict;\n    gustiness = gustiness,\n);\n\nDefine the boundary conditions\n\ntop_bc = ClimaLand.Soil.AtmosDrivenFluxBC(atmos, radiation)\nzero_water_flux = WaterFluxBC((p, t) -> 0)\nzero_heat_flux = HeatFluxBC((p, t) -> 0)\nboundary_fluxes = (;\n    top = top_bc,\n    bottom = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n);\n\n[ Info: Warning: No runoff model was provided; zero runoff generated.\n\n\nDefine the parameters n and alpha estimated by matching vG curve.\n\nK_sat = FT(225.1 / 3600 / 24 / 1000)\nvg_n = FT(10.0)\nvg_α = FT(6.0)\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n)\nν = FT(0.43)\nθ_r = FT(0.045)\nS_s = FT(1e-3)\nν_ss_om = FT(0.0)\nν_ss_quartz = FT(1.0)\nν_ss_gravel = FT(0.0)\nemissivity = FT(1.0)\nz_0m = FT(1e-3)\nz_0b = FT(1e-4)\nd_ds = FT(0.01)\nparams = ClimaLand.Soil.EnergyHydrologyParameters(\n    toml_dict;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm = hcm,\n    K_sat,\n    S_s,\n    θ_r,\n    emissivity,\n    z_0m,\n    z_0b,\n    d_ds,\n);\n\nDomain - single column\n\nzmax = FT(0)\nzmin = FT(-0.35)\nnelems = 12\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\nz = ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z;\n\nSoil model, and create the prognostic vector Y and cache p:\n\nsources = (PhaseChange{FT}(),);\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n)\n\nClimaLand.Soil.EnergyHydrology{Float64, ClimaLand.Soil.EnergyHydrologyParameters{Float64, Float64, ClimaLand.Soil.ConstantTwoBandSoilAlbedo{Float64}, ClimaLand.Soil.vanGenuchten{Float64}, ClimaLand.Parameters.LandParameters{Float64, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}, SurfaceFluxes.Parameters.SurfaceFluxesParameters{Float64, SurfaceFluxes.UniversalFunctions.GryanikParams{Float64}, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}}, Insolation.Parameters.InsolationParameters{Float64}}}, ClimaLand.Domains.Column{Float64, @NamedTuple{surface::ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}, subsurface::ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Meshes.Uniform, ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float64}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float64}, Int64}, Nothing}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 12, Matrix{Float64}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 13, Matrix{Float64}}}, ClimaCore.Grids.CellCenter}, subsurface_face::ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Meshes.Uniform, ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float64}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float64}, Int64}, Nothing}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 12, Matrix{Float64}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 13, Matrix{Float64}}}, ClimaCore.Grids.CellFace}}, @NamedTuple{z::ClimaCore.Fields.Field{ClimaCore.DataLayouts.VF{Float64, 12, SubArray{Float64, 2, Matrix{Float64}, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}, true}}, ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Meshes.Uniform, ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float64}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float64}, Int64}, Nothing}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 12, Matrix{Float64}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 13, Matrix{Float64}}}, ClimaCore.Grids.CellCenter}}, Δz_top::ClimaCore.Fields.Field{ClimaCore.DataLayouts.DataF{Float64, Vector{Float64}}, ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}}, Δz_bottom::ClimaCore.Fields.Field{ClimaCore.DataLayouts.DataF{Float64, Vector{Float64}}, ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}}, z_sfc::ClimaCore.Fields.Field{ClimaCore.DataLayouts.DataF{Float64, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, UnitRange{Int64}}, true}}, ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}}, depth::Float64, Δz::ClimaCore.Fields.Field{ClimaCore.DataLayouts.VF{Float64, 12, SubArray{Float64, 2, Matrix{Float64}, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}, true}}, ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Meshes.Uniform, ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float64}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float64}, Int64}, Nothing}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 12, Matrix{Float64}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 13, Matrix{Float64}}}, ClimaCore.Grids.CellCenter}}, Δz_min::Float64}}, @NamedTuple{top::ClimaLand.Soil.AtmosDrivenFluxBC{PrescribedAtmosphere{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#7#8\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#9#10\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#11#12\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#13#14\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{ClimaLand.var\"#69#72\"}, Dates.DateTime, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}}, PrescribedRadiativeFluxes{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#1#2\"}, Nothing, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#3#4\"}, Dates.DateTime, Nothing, Nothing}, ClimaLand.Soil.Runoff.NoRunoff, Tuple{Symbol}}, bottom::ClimaLand.Soil.WaterHeatBC{ClimaLand.Soil.WaterFluxBC{Main.var\"##276\".var\"#15#16\"}, ClimaLand.Soil.HeatFluxBC{Main.var\"##276\".var\"#17#18\"}}}, Tuple{ClimaLand.Soil.PhaseChange{Float64}, ClimaLand.Soil.SoilSublimation{Float64}}}(ClimaLand.Soil.EnergyHydrologyParameters{Float64, Float64, ClimaLand.Soil.ConstantTwoBandSoilAlbedo{Float64}, ClimaLand.Soil.vanGenuchten{Float64}, ClimaLand.Parameters.LandParameters{Float64, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}, SurfaceFluxes.Parameters.SurfaceFluxesParameters{Float64, SurfaceFluxes.UniversalFunctions.GryanikParams{Float64}, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}}, Insolation.Parameters.InsolationParameters{Float64}}}(0.5475761065600488, 4.600976025456601, 2.5691382822627262, 1.1457000000000002e6, 0.43, 0.0, 1.0, 0.0, 0.24, 18.3, ClimaLand.Soil.vanGenuchten{Float64}(6.0, 10.0, 0.9, 0.14723847347250069), 2.605324074074074e-6, 0.001, 0.045, 7.0, 0.0264, 288.0, ClimaLand.Soil.ConstantTwoBandSoilAlbedo{Float64}(0.2, 0.4), 1.0, 0.001, 0.0001, 0.01, ClimaLand.Parameters.LandParameters{Float64, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}, SurfaceFluxes.Parameters.SurfaceFluxesParameters{Float64, SurfaceFluxes.UniversalFunctions.GryanikParams{Float64}, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}}, Insolation.Parameters.InsolationParameters{Float64}}(0.024, 1000.0, 916.7, 4181.0, 2070.0, 273.16, 2.5008e6, 2.8344e6, 5.67e-8, 273.15, 9.81, 101325.0, 2.26e-5, 8.3144598, 0.01801528, 6.626e-34, 2.99792458e8, 6.02214076e23, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}(273.16, 101325.0, 100000.0, 287.0, 461.5, 1004.5, 1859.0, 4181.0, 2070.0, 2.5008e6, 2.8344e6, 611.657, 273.16, 273.15, 1.0, 1000.0, 150.0, 298.15, 6864.8, 10513.6, 8.3144598, 0.02897, 0.01801528, 290.0, 220.0, 9.81, 233.0, 1.0), SurfaceFluxes.Parameters.SurfaceFluxesParameters{Float64, SurfaceFluxes.UniversalFunctions.GryanikParams{Float64}, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}}(0.4, SurfaceFluxes.UniversalFunctions.GryanikParams{Float64}(0.98, 5.0, 5.0, 0.3, 0.4, 15.0, 9.0, 7.25, 3.62), Thermodynamics.Parameters.ThermodynamicsParameters{Float64}(273.16, 101325.0, 100000.0, 287.0, 461.5, 1004.5, 1859.0, 4181.0, 2070.0, 2.5008e6, 2.8344e6, 611.657, 273.16, 273.15, 1.0, 1000.0, 150.0, 298.15, 6864.8, 10513.6, 8.3144598, 0.02897, 0.01801528, 290.0, 220.0, 9.81, 233.0, 1.0)), Insolation.Parameters.InsolationParameters{Float64}(3.1558464e7, 86400.0, 1.4959787e11, 1362.0, Dates.DateTime(\"2000-01-01T11:58:55.816\"), 6.24006014121, 0.016708634, 0.408979125113246, 4.938188299449))), ClimaLand.Domains.Column{Float64, @NamedTuple{surface::ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}, subsurface::ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Meshes.Uniform, ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float64}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float64}, Int64}, Nothing}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 12, Matrix{Float64}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 13, Matrix{Float64}}}, ClimaCore.Grids.CellCenter}, subsurface_face::ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Meshes.Uniform, ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float64}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float64}, Int64}, Nothing}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 12, Matrix{Float64}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 13, Matrix{Float64}}}, ClimaCore.Grids.CellFace}}, @NamedTuple{z::ClimaCore.Fields.Field{ClimaCore.DataLayouts.VF{Float64, 12, SubArray{Float64, 2, Matrix{Float64}, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}, true}}, ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Meshes.Uniform, ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float64}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float64}, Int64}, Nothing}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 12, Matrix{Float64}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 13, Matrix{Float64}}}, ClimaCore.Grids.CellCenter}}, Δz_top::ClimaCore.Fields.Field{ClimaCore.DataLayouts.DataF{Float64, Vector{Float64}}, ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}}, Δz_bottom::ClimaCore.Fields.Field{ClimaCore.DataLayouts.DataF{Float64, Vector{Float64}}, ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}}, z_sfc::ClimaCore.Fields.Field{ClimaCore.DataLayouts.DataF{Float64, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, UnitRange{Int64}}, true}}, ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}}, depth::Float64, Δz::ClimaCore.Fields.Field{ClimaCore.DataLayouts.VF{Float64, 12, SubArray{Float64, 2, Matrix{Float64}, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}, true}}, ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Meshes.Uniform, ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float64}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float64}, Int64}, Nothing}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 12, Matrix{Float64}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, 13, Matrix{Float64}}}, ClimaCore.Grids.CellCenter}}, Δz_min::Float64}}((-0.35, 0.0), (12,), nothing, (:bottom, :top), (surface = ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}(ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}(ClimaComms.CPUSingleThreaded()), ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float64}, Float64, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.LocalAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.LocalAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.ContravariantAxis{(3,)}, ClimaCore.Geometry.ContravariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}, ClimaCore.Geometry.AxisTensor{Float64, 2, Tuple{ClimaCore.Geometry.CovariantAxis{(3,)}, ClimaCore.Geometry.CovariantAxis{(3,)}}, StaticArraysCore.SMatrix{1, 1, Float64, 1}}}, SubArray{Float64, 1, Matrix{Float64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}\n  [0.0, 0.0291667, 0.0145833, 34.2857, 0.0291667, 34.2857, 1175.51, 0.000850694]), subsurface = CenterFiniteDifferenceSpace:\n  context: SingletonCommsContext using CPUSingleThreaded\n  mesh: 12-element IntervalMesh of IntervalDomain: z ∈ [-0.35,0.0] (:bottom, :top), subsurface_face = FaceFiniteDifferenceSpace:\n  context: SingletonCommsContext using CPUSingleThreaded\n  mesh: 12-element IntervalMesh of IntervalDomain: z ∈ [-0.35,0.0] (:bottom, :top)), (z = Float64-valued Field:\n  [-0.335417, -0.30625, -0.277083, -0.247917, -0.21875, -0.189583, -0.160417, -0.13125, -0.102083, -0.0729167, -0.04375, -0.0145833], Δz_top = Float64-valued Field:\n  [0.0145833], Δz_bottom = Float64-valued Field:\n  [0.0145833], z_sfc = Float64-valued Field:\n  [0.0], depth = 0.35, Δz = Float64-valued Field:\n  [0.0291667, 0.0291667, 0.0291667, 0.0291667, 0.0291667, 0.0291667, 0.0291667, 0.0291667, 0.0291667, 0.0291667, 0.0291667, 0.0291667], Δz_min = 0.02916666666666662)), (top = ClimaLand.Soil.AtmosDrivenFluxBC{PrescribedAtmosphere{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#7#8\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#9#10\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#11#12\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#13#14\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{ClimaLand.var\"#69#72\"}, Dates.DateTime, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}}, PrescribedRadiativeFluxes{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#1#2\"}, Nothing, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#3#4\"}, Dates.DateTime, Nothing, Nothing}, ClimaLand.Soil.Runoff.NoRunoff, Tuple{Symbol}}(PrescribedAtmosphere{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#7#8\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#9#10\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#11#12\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#13#14\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{ClimaLand.var\"#69#72\"}, Dates.DateTime, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}}(ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#5#6\"}(Main.var\"##276\".var\"#5#6\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#5#6\"}(Main.var\"##276\".var\"#5#6\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#7#8\"}(Main.var\"##276\".var\"#7#8\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#9#10\"}(Main.var\"##276\".var\"#9#10\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#11#12\"}(Main.var\"##276\".var\"#11#12\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#13#14\"}(Main.var\"##276\".var\"#13#14\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{ClimaLand.var\"#69#72\"}(ClimaLand.var\"#69#72\"()), Dates.DateTime(\"2005-01-01T00:00:00\"), 0.1, 0.01, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}(273.16, 101325.0, 100000.0, 287.0, 461.5, 1004.5, 1859.0, 4181.0, 2070.0, 2.5008e6, 2.8344e6, 611.657, 273.16, 273.15, 1.0, 1000.0, 150.0, 298.15, 6864.8, 10513.6, 8.3144598, 0.02897, 0.01801528, 290.0, 220.0, 9.81, 233.0, 1.0)), PrescribedRadiativeFluxes{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#1#2\"}, Nothing, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#3#4\"}, Dates.DateTime, Nothing, Nothing}(ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#1#2\"}(Main.var\"##276\".var\"#1#2\"()), nothing, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##276\".var\"#3#4\"}(Main.var\"##276\".var\"#3#4\"()), Dates.DateTime(\"2005-01-01T00:00:00\"), nothing, nothing), ClimaLand.Soil.Runoff.NoRunoff(nothing), (:soil,)), bottom = ClimaLand.Soil.WaterHeatBC{ClimaLand.Soil.WaterFluxBC{Main.var\"##276\".var\"#15#16\"}, ClimaLand.Soil.HeatFluxBC{Main.var\"##276\".var\"#17#18\"}}(ClimaLand.Soil.WaterFluxBC{Main.var\"##276\".var\"#15#16\"}(Main.var\"##276\".var\"#15#16\"()), ClimaLand.Soil.HeatFluxBC{Main.var\"##276\".var\"#17#18\"}(Main.var\"##276\".var\"#17#18\"()))), (ClimaLand.Soil.PhaseChange{Float64}(true), ClimaLand.Soil.SoilSublimation{Float64}(false)), false)\n\nfunctions to Set initial conditions\n\nfunction hydrostatic_equilibrium(z, z_interface, params)\n    (; ν, S_s, hydrology_cm) = params\n    (; α, n, m) = hydrology_cm\n    if z < z_interface\n        return -S_s * (z - z_interface) + ν\n    else\n        return ν * (1 + (α * (z - z_interface))^n)^(-m)\n    end\nend\nfunction set_ic!(Y, p, t0, model)\n    params = model.parameters\n    z = model.domain.fields.z\n    Y.soil.ϑ_l .= hydrostatic_equilibrium.(z, FT(-0.1), params)\n    Y.soil.θ_i .= 0\n    T = FT(275.0)\n    ρc_s = @. Soil.volumetric_heat_capacity(\n        Y.soil.ϑ_l,\n        FT(0),\n        params.ρc_ds,\n        params.earth_param_set,\n    )\n    Y.soil.ρe_int =\n        Soil.volumetric_internal_energy.(FT(0), ρc_s, T, params.earth_param_set)\nend\n\nset_ic! (generic function with 1 method)\n\nTimestepping:\n\ntimestepper = CTS.ARS111()\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 3,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n)\n\nsaveat = Hour(1)\nsaving_cb = ClimaLand.NonInterpSavingCallback(start_date, stop_date, saveat)\nsv = saving_cb.affect!.saved_values\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    updateat = Hour(1),\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    user_callbacks = (saving_cb,),\n    diagnostics = (),\n);\n\nSolve\n\nsol = solve!(simulation);\n\nFigures\n\nExtract the evaporation at each saved step\n\nevap = [\n    parent(sv.saveval[k].soil.turbulent_fluxes.vapor_flux_liq)[1] for\n    k in 1:length(sol.t)\n]\nsub = [\n    parent(sv.saveval[k].soil.turbulent_fluxes.vapor_flux_ice)[1] for\n    k in 1:length(sol.t)\n]\n\nfig = Figure(size = (400, 400))\nax = Axis(\n    fig[1, 1],\n    xlabel = \"Day\",\n    ylabel = \"Rate (mm/d)\",\n    title = \"Vapor Fluxes\",\n)\nCairoMakie.lines!(\n    ax,\n    FT.(sol.t) ./ 3600 ./ 24,\n    sub .* (1000 * 3600 * 24),\n    label = \"Sublimation\",\n    color = :blue,\n)\nCairoMakie.lines!(\n    ax,\n    FT.(sol.t) ./ 3600 ./ 24,\n    evap .* (1000 * 3600 * 24),\n    label = \"Evaporation\",\n    color = :black,\n)\nCairoMakie.axislegend(ax)\n\nsave(\"water_fluxes.png\", fig);\n\n(Image: )\n\nfig2 = Figure(size = (800, 1200))\nax1 = Axis(fig2[1, 1], title = \"Temperature\")\nCairoMakie.ylims!(-0.35, 0)\nCairoMakie.xlims!(260, 280)\nlinestyles = [:solid, :dash, :dashdot, :dashdotdot, :dot]\ndays = [0, 1, 2, 3, 4]\nfor i in 1:length(days)\n    CairoMakie.lines!(\n        ax1,\n        parent(sv.saveval[Int(days[i] * 24 + 1)].soil.T)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\nax2 = Axis(fig2[2, 1], title = \"Ice\", ylabel = \"Depth(cm)\")\n\nCairoMakie.ylims!(-0.35, 0)\nCairoMakie.xlims!(0.0, 0.5)\nfor i in 1:length(days)\n    CairoMakie.lines!(\n        ax2,\n        parent(sol.u[Int(days[i] * 24 + 1)].soil.θ_i)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\nax3 = Axis(fig2[3, 1], title = \"Liquid Water\", xlabel = \"\")\nCairoMakie.ylims!(-0.35, 0)\nCairoMakie.xlims!(0.0, 0.5)\nfor i in 1:length(days)\n    CairoMakie.lines!(\n        ax3,\n        parent(sol.u[Int(days[i] * 24 + 1)].soil.ϑ_l)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\n\nCairoMakie.axislegend(ax3, position = :lt)\nCairoMakie.axislegend(ax2, position = :lt)\nCairoMakie.axislegend(ax1, position = :lt)\nsave(\"profiles.png\", fig2);\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/#Beer's-law","page":"Beer model","title":"Beer's law","text":"Plants absorb, transmit, and reflect shortwave radiation; the fraction of downwelling radiation partitioned into each of these categories under Beer's law is given by per wavelength band as\n\nrmabs_lambda = (1 - alpha_rmleaf lambda)(1 - e^(-K(theta_s) LAI  Omega))\nrmtrans_lambda = e^(-K(theta_s) LAI  Omega)\nrmrefl_lambda = 1 - rmabs_lambda - trans_lambda * (1-alpha_rmground)\n\nwhere λ reflects the wavelength of light, SW_d is the downwelling radiative flux, α_{leaf,λ} is the albedo of the leaves in that wavelength band, K is the extinction coefficient, θ_s is the zenith angle, LAI is the leaf area index, Ω is the clumping index, and α_{ground,λ} is the ground albedo.\n\nThe extinction coefficient is defined as\n\nK = l_dmax(cos(theta_s) epsilon)\n\nwhere l_d is the leaf distribution factor, and where the denominator is structured so that at night, when 3π/2 > θ_s > π/2, K is large (lots of extinction) and non-negative. The small value ε prevents dividing by zero.\n\nThe model has the following variables:\n\nOutput Symbol Unit Range\nAbsorbed fraction of radiative flux per band abs_λ W m⁻² 0–1\nReflected fraction of radiative flux per band refl_λ W m⁻² 0–1\nTransmitted fraction of radiative flux per band trans_λ W m⁻² 0–1\n\nInput Symbol Unit Range\nLeaf reflectance (albedo) α_rmleafλ - 0–1\nExtinction coefficient K - K>0\nClumping index Ω - 0–1\nZenith angle θ_s rad 0–π\nLeaf Area Index LAI m² m⁻² 0–10\nLeaf angle distribution l_d - 0–1\nGround albedo α_rmgroundλ - 0–1","category":"section"},{"location":"generated/standalone/Soil/freezing_front/#Modeling-a-freezing-front-in-unsaturated-soil","page":"Modeling a freezing front in unsaturated soil","title":"Modeling a freezing front in unsaturated soil","text":"Before reading this tutorial, we recommend that you look over the coupled energy and water tutorial. That tutorial showed how to solve the heat equation for soil volumetric internal energy ρe_int, simultaneously with Richards equation for volumetric liquid water fraction ϑ_l, assuming zero volumetric ice fraction θ_i for all time, everywhere in the domain. In this example, we add in a source term to the right hand side for both θ_i and ϑ_l which models freezing and thawing and conserves water mass during the process. The equations are\n\nfrac ρe_int t =    κ(θ_l θ_i ν ) T +   ρe_int_liq K (Tθ_l θ_i ν ) nabla h( ϑ_l z ν )\n\nfrac  ϑ_l t =   K (Tθ_l θ_i ν ) h( ϑ_l z ν ) -fracF_Tρ_l\n\nfrac  θ_i t = fracF_Tρ_i\n\nHere\n\nt is the time (s),\n\nz is the location in the vertical (m),\n\nρe_int is the volumetric internal energy of the soil (J/m^3),\n\nT is the temperature of the soil (K),\n\nκ is the thermal conductivity (W/m/K),\n\nρe_int_liq is the volumetric internal energy of liquid water (J/m^3),\n\nK is the hydraulic conductivity (m/s),\n\nh is the hydraulic head (m),\n\nϑ_l is the augmented volumetric liquid water fraction,\n\nθ_i is the volumetric ice fraction,\n\nν  denotes parameters relating to soil type, such as porosity, and\n\nF_T is the freeze-thaw term.\n\nTo begin, we will show how to implement adding in this source term. After the results are obtained, we will explain how our model parameterizes this effect and compare the results with some analytic expections.\n\nWe solve these equations in an effectively 1-d domain with z  -020, and with the following boundary and initial conditions:\n\n- κ T(t z = 0) = 28 Wm^2K (T - 26715K) ẑ\n\n- κ T(t z= -02) =  -3 Wm^2K (T - 27985K) ẑ\n\nT(t = 0 z) = 27985 K\n\n- K h(t z = 0) = 0 ẑ\n\n-K h(t z = -02) = 0 ẑ\n\nϑ_l(t = 0 z) = 033.\n\nThe problem setup and soil properties are chosen to match the lab experiment of Mizoguchi [6], as detailed in Hansson et al. [7] and M. Dall’Amico et al. [8]. Like Hansson et al., we allow for a small amount of energy leakage at the bottom of the domain to account for imperfect insulation.","category":"section"},{"location":"generated/standalone/Soil/freezing_front/#Import-necessary-modules","page":"Modeling a freezing front in unsaturated soil","title":"Import necessary modules","text":"import SciMLBase\nimport ClimaTimeSteppers as CTS\nusing DelimitedFiles\nusing CairoMakie\n\nusing ClimaCore\nimport ClimaParams as CP\nusing ClimaUtilities.Utils: linear_interpolation\nusing Statistics\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nimport ClimaLand.Simulations: LandSimulation, solve!\nusing ClimaLand.Soil\n\nimport ClimaLand\nimport ClimaLand.Parameters as LP\n\nPreliminary set-up\n\nChoose a floating point precision, and get the parameter set, which holds constants used across CliMA models:\n\nFT = Float32\ntoml_dict = LP.create_toml_dict(FT);\n\nSet the values of other parameters required by the model:\n\nν = FT(0.535)\nK_sat = FT(3.2e-6) # m/s\nS_s = FT(1e-3) #inverse meters\nvg_n = FT(1.48)\nvg_α = FT(1.11) # inverse meters\nhydrology_cm = vanGenuchten{FT}(; α = vg_α, n = vg_n);\n\nYou could also try the Brooks and Corey model:\n\n#ψb = FT(-0.6)\n#c = FT(0.43)\n#hcm = BrooksCorey(;ψb = ψb, c = c);\nθ_r = FT(0.05)\nν_ss_om = FT(0.4)\nν_ss_quartz = FT(0.6)\nν_ss_gravel = FT(0.0)\nparams = Soil.EnergyHydrologyParameters(\n    toml_dict;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm,\n    K_sat,\n    S_s,\n    θ_r,\n);\n\nChoose the domain and discretization:\n\nzmax = FT(0)\nzmin = FT(-0.2)\nnelems = 20\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\n\nSet the boundary conditions:\n\nzero_water_flux_bc = WaterFluxBC((p, t) -> 0.0)\nfunction top_heat_flux(p, t)\n    FT = eltype(p.soil.T)\n    p_len = ClimaCore.Spaces.nlevels(axes(p.soil.T))\n    T_c = ClimaCore.Fields.level(p.soil.T, p_len)\n    return @. FT(28 * (T_c - 267.15))\nend\nfunction bottom_heat_flux(p, t)\n    FT = eltype(p.soil.T)\n    T_c = ClimaCore.Fields.level(p.soil.T, 1)\n    return @. FT(-3 * (T_c - 279.85))\nend\ntop_heat_flux_bc = HeatFluxBC(top_heat_flux)\nbottom_heat_flux_bc = HeatFluxBC(bottom_heat_flux)\nboundary_fluxes = (;\n    top = WaterHeatBC(; water = zero_water_flux_bc, heat = top_heat_flux_bc),\n    bottom = WaterHeatBC(;\n        water = zero_water_flux_bc,\n        heat = bottom_heat_flux_bc,\n    ),\n);\n\nCreate the source term instance. Our phase change model requires knowledge of the vertical spacing, so we pass that information in via an attribute of the PhaseChange structure. Sources are added as elements of a list of sources. Here we just add freezing and thawing.\n\nsources = (PhaseChange{FT}(),);\n\nNow we can package this up in the EnergyHydrology model struct:\n\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n);","category":"section"},{"location":"generated/standalone/Soil/freezing_front/#Running-a-simulation","page":"Modeling a freezing front in unsaturated soil","title":"Running a simulation","text":"We can specify the initial condition:\n\nfunction set_ic!(Y, p, t0, model)\n    params = model.parameters\n    FT = eltype(Y.soil.ϑ_l)\n    Y.soil.ϑ_l .= FT(0.33)\n    Y.soil.θ_i .= FT(0.0)\n    T = FT(279.85)\n    ρc_s = Soil.volumetric_heat_capacity(\n        FT(0.33),\n        FT(0.0),\n        params.ρc_ds,\n        params.earth_param_set,\n    )\n    Y.soil.ρe_int .=\n        Soil.volumetric_internal_energy.(\n            FT(0.0),\n            ρc_s,\n            T,\n            params.earth_param_set,\n        )\nend\n\nset_ic! (generic function with 1 method)\n\nWe choose the initial and final simulation times:\n\nt0 = Float64(0)\ntf = Float64(60 * 60 * 50);\ndt = Float64(100);\n\nCreate the simulation and solve\n\nsimulation = LandSimulation(\n    t0,\n    tf,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    solver_kwargs = (; save_everystep = true),\n    user_callbacks = (),\n    diagnostics = (),\n);\nsol = solve!(simulation);","category":"section"},{"location":"generated/standalone/Soil/freezing_front/#Comparison-to-data","page":"Modeling a freezing front in unsaturated soil","title":"Comparison to data","text":"This data was obtained by us from the figures of Hansson et al. [7], but was originally obtained by Mizoguchi [6]. No error bars were reported, and we haven't quantified the error in our estimation of the data from images.\n\ndataset_path = ClimaLand.Artifacts.mizoguchi1990_soil_freezing_data();\nds = readdlm(dataset_path, ',')\nhours = ds[:, 1][2:end]\nvwc = ds[:, 2][2:end] ./ 100.0\ndepth = ds[:, 3][2:end]\nmask_12h = hours .== 12\nmask_24h = hours .== 24\nmask_50h = hours .== 50;\n\nfig = Figure(size = (1500, 500), fontsize = 36)\nax1 = Axis(\n    fig[1, 1],\n    title = \"12 hours\",\n    xlabel = L\"θ_l + θ_i\",\n    ylabel = \"Depth (m)\",\n    xgridvisible = false,\n    ygridvisible = false,\n    xticks = (0.2:0.1:0.4, [\"0.2\", \"0.3\", \"0.4\"]),\n)\nlimits!(ax1, 0.2, 0.5, -0.2, 0.0)\nax2 = Axis(\n    fig[1, 2],\n    title = \"24 hours\",\n    xlabel = L\"θ_l + θ_i\",\n    yticksvisible = false,\n    yticklabelsvisible = false,\n    xgridvisible = false,\n    ygridvisible = false,\n    xticks = (0.2:0.1:0.4, [\"0.2\", \"0.3\", \"0.4\"]),\n)\nlimits!(ax2, 0.2, 0.5, -0.2, 0.0)\nax3 = Axis(\n    fig[1, 3],\n    title = \"50 hours\",\n    xlabel = L\"θ_l + θ_i\",\n    yticksvisible = false,\n    yticklabelsvisible = false,\n    xgridvisible = false,\n    ygridvisible = false,\n    xticks = (0.2:0.1:0.4, [\"0.2\", \"0.3\", \"0.4\"]),\n)\nlimits!(ax3, 0.2, 0.5, -0.2, 0.0)\n\n\nz = parent(soil.domain.fields.z)[:];\nid_12h = findfirst(FT.(sol.t) ./ 3600 .== 12)\nsim_12h = parent(sol.u[id_12h].soil.ϑ_l .+ sol.u[id_12h].soil.θ_i)[:]\nscatter!(ax1, vwc[mask_12h], -depth[mask_12h], label = \"\", color = \"orange\")\nlines!(ax1, sim_12h, z, label = \"\", color = :blue, linewidth = 3)\n\n\nscatter!(ax2, vwc[mask_24h], -depth[mask_24h], label = \"\", color = \"orange\")\nid_24h = findfirst(FT.(sol.t) ./ 3600 .== 24)\nsim_24h = parent(sol.u[id_24h].soil.ϑ_l .+ sol.u[id_24h].soil.θ_i)[:]\nlines!(ax2, sim_24h, z, label = \"\", color = :blue, linewidth = 3)\n\nscatter!(ax3, vwc[mask_50h], -depth[mask_50h], label = \"Data\", color = \"orange\")\nid_50h = findfirst(FT.(sol.t) ./ 3600 .== 50)\nsim_50h = parent(sol.u[id_50h].soil.ϑ_l .+ sol.u[id_50h].soil.θ_i)[:]\nlines!(ax3, sim_50h, z, label = \"Model\", color = :blue, linewidth = 3)\naxislegend(ax3, position = :rb, framevisible = false)\n\nsave(\"mizoguchi_data_comparison.png\", fig);\n\n(Image: )\n\nGoodness of fit metrics: define a function which computes mean absolute error and interpolate the simulation output to the data depths\n\nmae(x, obs) = mean(abs.(x .- obs));\nsim_12h_interp = [\n    linear_interpolation(z, sim_12h, data_depth) for\n    data_depth in -depth[mask_12h]\n]\nmae(sim_12h_interp, vwc[mask_12h])\n\n0.018584817606031565\n\nsim_24h_interp = [\n    linear_interpolation(z, sim_24h, data_depth) for\n    data_depth in -depth[mask_24h]\n]\nmae(sim_24h_interp, vwc[mask_24h])\n\n0.012905895126331165\n\nsim_50h_interp = [\n    linear_interpolation(z, sim_50h, data_depth) for\n    data_depth in -depth[mask_50h]\n]\nmae(sim_50h_interp, vwc[mask_50h])\n\n0.017655735893562115","category":"section"},{"location":"generated/standalone/Soil/freezing_front/#Discussion-and-Model-Explanation","page":"Modeling a freezing front in unsaturated soil","title":"Discussion and Model Explanation","text":"To begin, let's observe that the freeze thaw source term alone conserves water mass, as it satisfies\n\nρ_l partial_tϑ_l + ρ_i partial_tθ_i = -F_T + F_T = 0\n\nNext, we describe how we define F_T. The Clausius-Clapeyron (CC) equation defines a pressure-temperature curve along which two phases can co-exist. It assumes that the phases are at equal temperature and pressures. For water in soil, however, the liquid water experiences pressure ρ_l g ψ, where ψ is the matric potential. A more general form of the CC equation allows for different pressures in the two phases. Usually the ice pressure is taken to be zero, which is reasonable for unsaturated freezing soils. In saturated soils, freezing can lead to heaving of the soil which we do not model. After that assumption is made, we obtain that, below freezing (T  T_f)\n\nfracdp_lρ_l = L_f fracdTT\n\nor\n\np_l = p_l0 + L_f ρ_l fracT-T_fT_f mathcalH(T_f-T)\n\nwhere we have assumed that assumed T is near the freezing point, and then performed a Taylor explansion of the logarithm, and we are ignoring the freezing point depression, which is small (less than one degree) for non-clay soils. What we have sketched is further explained in M. Dall’Amico et al. [8] and Kurylyk and Watanabe [9].\n\nWhat this implies is that above the freezing point, the pressure is equal to p_l0, which is independent of temperature. Once the temperature drops below the freezing point, the pressure drops. Since prior to freezing, the pressure p_l0 is equal to ρ_l g ψ(θ_l), water undergoing freezing alone (without flowing) should satisfy M. Dall’Amico et al. [8]:\n\np_l0 = ρ_l g ψ(θ_l+ρ_iθ_iρ_l)\n\nwhere ψ is the matric potential function of van Genuchten. At each step, we know both the water and ice contents, as well as the temperature, and can then solve for\n\nθ_l^* = (ν-θ_r) ψ^-1(p_l(ρ_l g)) + θ_r\n\nFor freezing, the freeze thaw function F_T is equal to\n\nF_T = frac1τ ρ_l (θ_l-θ_l^*) mathcalH(T_f-T) mathcalH(θ_l-θ_l^*)\n\nwhich brings the θ_l to a value which satisfies p_l = ρ_l g ψ(θ_l). This is why, in our simulation, we see the liquid water fraction approaches a constant around 0.075 in the frozen region, rather than the residual fraction of 0.019, or 0. This behavior is observed, for example, in the experiments of Watanabe et al. [10].\n\nAlthough this approach may indicate that we should replace the pressure head appearing in the diffusive water flux term in Richards equation M. Dall’Amico et al. [8]), we do not do so at present. As such, we may not be modeling the flow of water around the freezing front properly. However, we still observe cryosuction, which is the flow of water towards the freezing front, from the unfrozen side. As the water freezes, the liquid water content drops, setting up a larger gradient in matric potential across the freezing front, which generates upward flow against gravity. This is evident because the total water content at the top is larger at the end of the simulation than it was at t=0 (when it was 0.33).\n\nThis model differs from others (e.g. Painter and Karra [11], Hansson et al. [7], M. Dall’Amico et al. [8])  in that it requires us to set a timescale for the phase change, τ. We currently use the thermal time\n\nτ_LTE= c Δz²κ\n\nwhich seems to work adequately for modeling freezing front propagation and cryosuction, via comparisons with Mizoguchi [6].\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"leaderboard/leaderboard/#Leaderboard","page":"Model Benchmark","title":"Leaderboard","text":"","category":"section"},{"location":"leaderboard/leaderboard/#Long-run","page":"Model Benchmark","title":"Long run","text":"","category":"section"},{"location":"leaderboard/leaderboard/#Add-a-new-variable-to-compare-against-observations","page":"Model Benchmark","title":"Add a new variable to compare against observations","text":"The infrastructure to compute errors against observations is in the leaderboard folder. This folder contains two files: data_sources.jl, responsible for loading and preprocessing variables of interest, and leaderboard.jl, which computes error and draw plots. To add a new variable to the comparison, you modify the data_sources.jl.","category":"section"},{"location":"leaderboard/leaderboard/#Computation","page":"Model Benchmark","title":"Computation","text":"As of now, the leaderboard produces bias plots with the global bias and global root mean squared error (RMSE). These quantities are computed for each month with the first year of the simulation not considered as that is the spinup time. The start date of the simulation is 2008 which means that only the year 2009 is used to compare against observational data.","category":"section"},{"location":"leaderboard/leaderboard/#Add-a-new-variable-to-the-bias-plots","page":"Model Benchmark","title":"Add a new variable to the bias plots","text":"There are four functions that you need to modify to add a new variable which are get_sim_var_dict, get_obs_var_dict, get_mask_dict, and get_compare_vars_biases_plot_extrema. Each function returns a dictionary that must be modified to add a new variable to the leaderboard. The dictionaries are sim_var_dict, obs_var_dict, mask_dict, and compare_vars_biases_plot_extrema.\n\nTo add a variable for the leaderboard, add a key-value pair to the dictionary sim_var_dict whose key is the short name of the variable and the value is a function that returns a OutputVar. Any preprocessing is done in the function which includes unit conversion and shifting the dates.\n\nsim_var_dict[\"et\"] =\n        () -> begin\n            # Load in variable\n            sim_var = get(\n                ClimaAnalysis.SimDir(diagnostics_folder_path),\n                short_name = \"et\",\n            )\n            return sim_var\n        end\n\nThen, add a key-value pair to the dictionary obs_var_dict whose key is the same short name as before and the value is a function that takes in a start date and returns a OutputVar. Any preprocessing is done in the function.\n\nobs_var_dict[\"et\"] =\n    (start_date) -> begin\n    # We use ClimaArtifacts to use a dataset from ILAMB\n        obs_var = ClimaAnalysis.OutputVar(\n            ClimaLand.Artifacts.ilamb_dataset_path(;\n                context = \"evspsbl_MODIS_et_0.5x0.5.nc\",\n            ),\n            \"et\",\n            # start_date is used to align the dates in the observational data\n            # with the simulation data\n            new_start_date = start_date,\n            # Shift dates to the first day of the month before aligning the dates\n            shift_by = Dates.firstdayofmonth,\n        )\n        # More preprocessing to match the units with the simulation data\n        ClimaAnalysis.units(obs_var) == \"kg/m2/s\" &&\n            (obs_var = ClimaAnalysis.set_units(obs_var, \"kg m^-2 s^-1\"))\n        # ClimaAnalysis cannot handle `missing` values, but does support handling NaNs\n        obs_var = ClimaAnalysis.replace(obs_var, missing => NaN)\n        return obs_var\n    end\n\ntip: Preprocessing\nObservational and simulational data should be preprocessed for dates and units. When using ClimaDiagnostics to report monthly averages from a simulation, monthly averages are output on the first day following the month when the average was computed. For instance, the monthly average corresponding to January 2010 is on the date 1 Feb 2010. Preprocessing is done to shift this date to 1 Jan 2010. When preprocessing data, we follow the convention that the first day corresponds to the monthly average for that month. For observational data, you should check the convention being followed and preprocess the dates if necessary.For obs_var_dict, the anonymous function must take in a start date. The start date is used in leaderboard.jl to adjust the seconds in the OutputVar to match between start date in the simulation data.Units should be the same between the simulation and observational data.\n\nNext, add a key-value pair to the dictionary mask_dict whose key is the same short name as before and the value is a function that takes in a OutputVar representing simulation data and a OutputVar representing observational data and returns a masking function or nothing if no masking function is needed. The masking function is used to correctly normalize the global bias and global RMSE. See the example below where a mask is made using the observational data.\n\nmask_dict[\"et\"] =\n    (sim_var, obs_var) -> begin\n        return ClimaAnalysis.make_lonlat_mask(\n            # We do this to get a `OutputVar` with only two dimensions:\n            # longitude and latitude\n            ClimaAnalysis.slice(\n                obs_var,\n                time = ClimaAnalysis.times(obs_var) |> first,\n            );\n            # Any values that are NaN should be 0.0\n            set_to_val = isnan,\n            true_val = 0.0\n        )\n    end\n\nFinally, add a key-value pair to the dictionary compare_vars_biases_plot_extrema whose key is the same short name as before and the value is a tuple of floats which determine the range of the bias plots.\n\ncompare_vars_biases_plot_extrema = Dict(\n    \"et\" => (-0.00001, 0.00001),\n    \"gpp\" => (-8.0, 8.0),\n    \"lwu\" => (-40.0, 40.0),\n)","category":"section"},{"location":"standalone/pages/vegetation/soil_moisture_stress/no_moisture_stress/#no-moisture-stress","page":"No moisture stress","title":"no moisture stress","text":"While the Piecewise  model and Tuzet model have a scaler, beta, that multiply leaf net assimilation and stomatal conductance by 0 to 1 depending on moisture stress, we also allow the option to use no sensitivity to moisture stress (beta is always equal to 1).","category":"section"},{"location":"generated/standalone/Snow/data_tutorial/#Scraping-SNOTEL-Data","page":"Data tutorial","title":"Scraping SNOTEL Data","text":"This tutorial shows you how to make use of the code developed for scraping SNOTEL site data in order to generate datasets for use in training artificial intelligence models for seasonal snow forecasting. The code below contains a basic version of the code used to produce training_data.csv, which is used in the base tutorial for snow forecasting, as well as the Charbonneau et al. [20]. However, exploration of the optional arguments or requesting of alternative SNOTEL data codes offers additional utility in creating alternative data sets for further investigation.\n\nWe begin by importing all required packages:\n\nusing ClimaLand\nusing DataFrames, CSV, HTTP, Dates, Flux, StatsBase, BSON\n\nThe code lives in an extenson that we have to manually load. The extension can be loaded only if \"DataFrames\", \"CSV\", \"HTTP\", \"Flux\", \"StatsBase\", \"BSON\", and \"ClimaLand\" are loaded.\n\nDataTools = Base.get_extension(ClimaLand, :NeuralSnowExt).DataTools;\n\nWe first extract a DataFrame matching station ID to various station metadata, in order to automate some of the scraping process and pass some station metadata that is used for analysis in the paper. This resulting DataFrame can also be used to see other available SNOTEL station IDs for scraping, in order to create custom datasets.\n\nmetadata = DataTools.snotel_metadata();\nmetacols = [\"id\", \"name\", \"state\", \"elev\", \"lat\", \"lon\"]\nDataFrames.rename!(metadata, Symbol.(metacols));\n\nAt the most user-friendly level, the function scrape_site_paper() provides a wrapper to scrape SNOTEL data in the exact same manner as the paper (it may take a minute or two per site). This function handles all special cases and data processing, allowing the user to only pass a SNOTEL ID number and associated state code to retrieve the same data as that used in the paper. However, this will likely not work or yield unexpected results for sites not used in the paper. Here is an example for how to use the metadata to streamline the process:\n\nexample_ID = 1030\nexample_state = metadata[findfirst(==(example_ID), metadata[!, :id]), :state]\nexample_data = DataTools.scrape_site_paper(example_ID, example_state);\n\nAnd that's it! This can be iterated within a loop to gather the data for all sites. However, while straightforward, this wrapper obfuscates many of the underlying steps, or some of the opportunities for using different arguments to generate custom datasets. As such, we can reimplement much of the same code in more detail below to enable more advanced usage.\n\nWe first define constants that will be used in the cleaning of the SNOTEL data, such as conversion constants from imperial to metric units, and the sensor limits defined in the U.S. Department of Agriculture, Natural Resources Conservation Service [21]. Some SNOTEL sensors measure in imperial units, and some measure in metric units, and the data portal will round converted values if a sensor stream is requested in units other than its original measurement. Therefore, we will scrape data in the originally measured units to limit systemic errors.\n\nconst inch2meter = 0.0254\nconst kmphr2mps = 5.0 / 18.0\n\nfilter_val = Dict{Symbol, Tuple{Real, Real}}(\n    :SWE => (0.0, 250.0),\n    :z => (0.0, 420.0),\n    :precip => (0.0, 250.0),\n    :rel_hum_avg => (10.0, 100.0),\n    :sol_rad_avg => (0.0, 1500.0),\n    :wind_speed_avg => (0.0, 216.0),\n    :air_temp_avg => (-40.0, 60.0),\n)\n\nscales = Dict{Symbol, Real}(\n    :SWE => inch2meter,\n    :z => inch2meter,\n    :precip => inch2meter,\n    :rel_hum_avg => 0.01,\n    :wind_speed_avg => kmphr2mps,\n);\n\nWe next proceed to outline which stations will be scraped by defining a dictionary of station IDs, paired with the date range to be scraped if a custom range is desired. \"start\" refers to 1850-01-01 or the first available date, while \"end\" refers to the earlier option bewteen 2024-02-01 or the last available date. Most of these stations are commented out for the sake of speed and readability in generating the tutorial, or due to special handling required, but can be uncommented to yield the full dataset (if special cases are handled) found in training_data.csv used in the base tutorial. Stations were selected based upon their availability of the features utilized in creating the model used in the Charbonneau et al. [20]:\n\n* Indicates alternative handling of the rectify_daily_hourly() function.\n^ Indicates usage of RHUM flag instead of RHUMV flag for relative humidity.\nA Indicates an Alaskan site, which is in the testing data, not the training data, and uses a lower temperature bound of -50 instead of -40 in filter_val.\nT Requires a site that already has had the temperature bias correction at the portal level as of May 2024.\nX Indicates a SNOTEL portal error when trying to scrape into 2024, as of May 2024.\n\ngood_stations = Dict{Int, Tuple{String, String}}(\n    #306 => (\"start\", \"end\"), #*\n    316 => (\"start\", \"end\"),\n    344 => (\"start\", \"end\"),\n    #=367 => (\"start\", \"end\"),\n    395 => (\"start\", \"end\"),\n    457 => (\"start\", \"end\"),\n    482 => (\"start\", \"end\"),\n    491 => (\"start\", \"end\"),\n    515 => (\"start\", \"2023-06-02\"), #X\n    532 => (\"start\", \"end\"),\n    551 => (\"start\", \"end\"),\n    571 => (\"start\", \"end\"),\n    599 => (\"start\", \"end\"),\n    608 => (\"start\", \"end\"),\n    613 => (\"start\", \"end\"),\n    641 => (\"start\", \"end\"), #A^\n    665 => (\"start\", \"end\"),\n    708 => (\"start\", \"end\"),\n    715 => (\"start\", \"end\"),\n    734 => (\"start\", \"end\"),\n    737 => (\"start\", \"end\"),\n    744 => (\"start\", \"end\"),\n    832 => (\"start\", \"end\"),\n    845 => (\"start\", \"end\"),\n    854 => (\"start\", \"end\"),\n    857 => (\"start\", \"end\"),\n    921 => (\"start\", \"end\"),\n    922 => (\"start\", \"end\"),\n    927 => (\"start\", \"end\"),\n    942 => (\"start\", \"end\"),\n    963 => (\"start\", \"end\"), #A^\n    969 => (\"start\", \"end\"),\n    974 => (\"start\", \"end\"),\n    978 => (\"start\", \"end\"), #*\n    1030 => (\"start\", \"end\"),\n    1035 => (\"start\", \"end\"), #A^\n    1053 => (\"start\", \"end\"),\n    1070 => (\"start\", \"end\"), #A^T\n    1083 => (\"start\", \"end\"),\n    1091 => (\"start\", \"end\"), #A^T\n    1092 => (\"start\", \"end\"), #A^T\n    1105 => (\"start\", \"end\"),\n    1122 => (\"start\", \"end\"), #*\n    1123 => (\"start\", \"end\"),\n    1159 => (\"start\", \"end\"),\n    1168 => (\"start\", \"end\"),\n    1170 => (\"start\", \"end\"),\n    1254 => (\"start\", \"end\"),\n    1286 => (\"start\", \"end\"),\n    2080 => (\"start\", \"end\"), #A^\n    2170 => (\"start\", \"end\"), #^\n    =#\n);\n\nWe then loop through each site to scrape and follow an automated data pipeline, consisting of:\n\nExtracting the daily and hourly timeseries from the site\nApplying the sensor bounds over each data timeseries (i.e. remove sensor error)\nConverting the hourly dataset into a daily dataset\nCoalescing the converted-hourly and daily data into one dataset\nScaling all data to the appropriate metric units\nRestricting data to complete cases\nMaking the differential variables ( fracdzdt, etc.)\nResetting negative precipitation cases (i.e. where the water year resets), and using daily precipitation rates dprecipdt instead of accumulated precipitation precip\nAttaching appropriate metadata\n\nA few steps are commented out, which indicate steps implemented in scrape_site_paper() like quality-control measures, which could be substituted with other user-defined steps.\n\nallsites = Any[];\nfor site in sort(collect(keys(good_stations)))\n    state = metadata[metadata[!, :id] .== site, :state][1]\n    start_date = good_stations[site][1]\n    end_date = good_stations[site][2]\n\n    hourly = DataTools.apply_bounds(\n        DataTools.sitedata_hourly(\n             site,\n            state,\n            start = start_date,\n            finish = end_date,\n        ),\n       filter_val,\n    )\n    hourly[!, :id] .= site\n    #hourly = DataTools.bcqc_hourly(hourly)\n    hourly_d = DataTools.hourly2daily(hourly)\n    #DataFrames.allowmissing!(hourly_d)\n    #sflags = DataTools.qc_filter(hourly_d, :sol_rad_avg, t1 = 2)\n   #hourly_d[sflags, :sol_rad_avg] .= missing\n\n    daily = DataTools.apply_bounds(\n        DataTools.sitedata_daily(\n            site,\n            state,\n            start = start_date,\n            finish = end_date,\n        ),\n        filter_val,\n    )\n    daily[!, :id] .= site\n    gap_daily = DataTools.rectify_daily_hourly(daily, hourly_d)\n    #gap_daily = DataTools.bcqc_daily(gap_daily, site, state)\n    #gap_daily = DataTools.d_impute(gap_daily)\n    daily_scaled = DataTools.scale_cols(gap_daily, scales)\n    daily_clean = daily_scaled[completecases(daily_scaled), :]\n    daily_clean = DataTools.makediffs(daily_clean, Day(1))\n    good_vals = daily_clean[!, :dprecipdt] .>= 0.0\n    daily_clean[(!).(good_vals), :dprecipdt] .= 0.0\n    daily_clean = daily_clean[!, Not(:precip)]\n    #show(describe(daily_clean), allrows = true, allcols = true)\n    #print(\"\\nSIZE: \", nrow(daily_clean), \"\\n\")\n\n    daily_clean[!, :id] .= site\n    daily_clean[!, :elev] .= metadata[metadata[!, :id] .== site, :elev][1]\n    daily_clean[!, :lat] .= metadata[metadata[!, :id] .== site, :lat][1]\n    daily_clean[!, :lon] .= metadata[metadata[!, :id] .== site, :lon][1]\n\n    push!(allsites, daily_clean)\nend;\n\nWith the sites complete, we condense all sites into a single DataFrame,\n\ntotaldata = deepcopy(allsites[1])\nfor site in allsites[2:end]\n    append!(totaldata, site)\nend\n\nand a final CSV.write(\"data.csv\", totaldata) call will save the file.\n\nMany of the functions above contain default or optional arguments which can be explored to obtain a richer set of functionality, or implement some of the special cases mentioned above. Such options can be explored in the code documentation.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Model-Site-Level-Calibration-Tutorial-Using-Observations","page":"Single site observations","title":"Model Site-Level Calibration Tutorial Using Observations","text":"In this tutorial we will calibrate the Vcmax25 and g1 parameters using latent heat flux observations from the FLUXNET site (US-MOz).","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Overview","page":"Single site observations","title":"Overview","text":"The tutorial covers:\n\nSetting up a land surface model for a FLUXNET site (US-MOz)\nObtaining the observation dataset\nImplementing Ensemble Kalman Inversion to calibrate Vcmax25 and g1\nAnalyzing the calibration results","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Setup-and-Imports","page":"Single site observations","title":"Setup and Imports","text":"Load all the necessary packages for land surface modeling, diagnostics, plotting, and ensemble methods:\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Canopy\nusing ClimaLand.Simulations\nimport ClimaLand.FluxnetSimulations as FluxnetSimulations\nimport ClimaLand.Parameters as LP\nimport ClimaLand.LandSimVis as LandSimVis\nimport ClimaDiagnostics\nimport ClimaUtilities.TimeManager: date\nimport EnsembleKalmanProcesses as EKP\nimport EnsembleKalmanProcesses.ParameterDistributions as PD\nusing CairoMakie\nCairoMakie.activate!()\nusing Statistics\nusing Logging\nimport Random\nusing Dates\nusing ClimaAnalysis, GeoMakie, Printf, StatsBase","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Configuration-and-Site-Setup","page":"Single site observations","title":"Configuration and Site Setup","text":"Configure the experiment parameters and set up the FLUXNET site (US-MOz) with its specific location, time settings, and atmospheric conditions.\n\nSet random seed for reproducibility and floating point precision\n\nrng_seed = 1234\nrng = Random.MersenneTwister(rng_seed)\nconst FT = Float32\n\nFloat32\n\nInitialize land parameters and site configuration.\n\ntoml_dict = LP.create_toml_dict(FT)\nsite_ID = \"US-MOz\"\nsite_ID_val = FluxnetSimulations.replace_hyphen(site_ID);\n\nGet site-specific information: location coordinates, time offset, and sensor height.\n\n(; time_offset, lat, long) =\n    FluxnetSimulations.get_location(FT, Val(site_ID_val))\n(; atmos_h) = FluxnetSimulations.get_fluxtower_height(FT, Val(site_ID_val));\n\nGet simulation start and stop dates in UTC; these must be included in the forcing data range Here we calibrate with only two months of data.\n\nstart_date = DateTime(2010, 5, 1)\nstop_date = DateTime(2010, 7, 1)\nΔt = 450.0; # seconds","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Domain-and-Forcing-Setup","page":"Single site observations","title":"Domain and Forcing Setup","text":"Create the computational domain and load the necessary forcing data for the land surface model. ClimaLand includes the domain, forcing, and LAI as part of the model, but here we will need to recreate a model many times (for each parameter value tried), while the domain, forcing, and LAI are held fixed. Because of that, we define them here, once, outside of the function that is called to make the model.\n\nCreate a column domain representing a 2-meter deep soil column with 10 vertical layers.\n\nzmin = FT(-2)  # 2m depth\nzmax = FT(0)   # surface\ndomain = Column(; zlim = (zmin, zmax), nelements = 10, longlat = (long, lat));\n\nLoad prescribed atmospheric and radiative forcing from FLUXNET data\n\nforcing = FluxnetSimulations.prescribed_forcing_fluxnet(\n    site_ID,\n    lat,\n    long,\n    time_offset,\n    atmos_h,\n    start_date,\n    toml_dict,\n    FT,\n);\n\nGet Leaf Area Index (LAI) data from MODIS satellite observations.\n\nLAI = ClimaLand.Canopy.prescribed_lai_modis(\n    domain.space.surface,\n    start_date,\n    stop_date,\n);","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Model-Setup","page":"Single site observations","title":"Model Setup","text":"Create an integrated land model that couples canopy, snow, soil, and soil CO2 components. This comprehensive model allows us to simulate the full land surface system and its interactions.\n\nfunction model(Vcmax25, g1)\n    Vcmax25 = FT(Vcmax25)\n    g1 = FT(g1)\n\n    #md # Set up models; note: we are not using the default soil, which relies on global\n    #md # maps of parameters to estimate the parameters at the site.\n    #md # Instead we use parameter more tailored to this site.\n    prognostic_land_components = (:canopy, :snow, :soil, :soilco2)\n    #md # Create soil model\n    retention_parameters = (;\n        ν = FT(0.55),\n        θ_r = FT(0.04),\n        K_sat = FT(4e-7),\n        hydrology_cm = ClimaLand.Soil.vanGenuchten{FT}(;\n            α = FT(0.05),\n            n = FT(2.0),\n        ),\n    )\n    composition_parameters =\n        (; ν_ss_om = FT(0.1), ν_ss_quartz = FT(0.1), ν_ss_gravel = FT(0.0))\n    soil = ClimaLand.Soil.EnergyHydrology{FT}(\n        domain,\n        forcing,\n        toml_dict;\n        prognostic_land_components,\n        additional_sources = (ClimaLand.RootExtraction{FT}(),),\n        runoff = ClimaLand.Soil.Runoff.SurfaceRunoff(),\n        retention_parameters,\n        composition_parameters,\n        S_s = FT(1e-2),\n    )\n    surface_domain = ClimaLand.Domains.obtain_surface_domain(domain)\n    canopy_forcing = (;\n        atmos = forcing.atmos,\n        radiation = forcing.radiation,\n        ground = ClimaLand.PrognosticGroundConditions{FT}(),\n    )\n    #md # Set up photosynthesis using the Farquhar model\n    photosyn_defaults =\n        Canopy.clm_photosynthesis_parameters(surface_domain.space.surface)\n    photosynthesis = Canopy.FarquharModel{FT}(\n        surface_domain,\n        toml_dict;\n        photosynthesis_parameters = (;\n            is_c3 = photosyn_defaults.is_c3,\n            Vcmax25,\n        ),\n    )\n    #md # Set up stomatal conductance using the Medlyn model\n    conductance =\n        Canopy.MedlynConductanceModel{FT}(surface_domain, toml_dict; g1)\n\n    #md # Create canopy model\n    canopy = Canopy.CanopyModel{FT}(\n        surface_domain,\n        canopy_forcing,\n        LAI,\n        toml_dict;\n        photosynthesis,\n        conductance,\n        prognostic_land_components,\n    )\n\n    #md # Create integrated land model\n    land_model = LandModel{FT}(\n        forcing,\n        LAI,\n        toml_dict,\n        domain,\n        Δt;\n        prognostic_land_components,\n        soil,\n        canopy,\n    )\n\n    #md # Set initial conditions from FLUXNET data\n    set_ic! = FluxnetSimulations.make_set_fluxnet_initial_conditions(\n        site_ID,\n        start_date,\n        time_offset,\n        land_model,\n    )\n\n    #md # Configure diagnostics to output sensible and latent heat fluxes half-hourly\n    #md # Since fluxnet data is recorded every half hour, with the average of the half hour,\n    #md # we need to be consistent here.\n    output_vars = [\"lhf\"]\n    diagnostics = ClimaLand.default_diagnostics(\n        land_model,\n        start_date;\n        output_writer = ClimaDiagnostics.Writers.DictWriter(),\n        output_vars,\n        reduction_period = :halfhourly,\n    )\n\n    #md # Create and run the simulation\n    simulation = Simulations.LandSimulation(\n        start_date,\n        stop_date,\n        Δt,\n        land_model;\n        set_ic!,\n        updateat = Second(Δt),\n        user_callbacks = (),\n        diagnostics,\n    )\n    solve!(simulation)\n    return simulation\nend;","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Observation-and-Helper-Functions","page":"Single site observations","title":"Observation and Helper Functions","text":"Define the observation function G that maps from parameter space to observation space, along with supporting functions for data processing:\n\nThis function runs the model and computes diurnal average of latent heat flux\n\nfunction G(Vcmax25, g1)\n    simulation = model(Vcmax25, g1)\n    lhf = get_lhf(simulation)\n    observation =\n        Float64.(\n            get_diurnal_average(\n                lhf,\n                simulation.start_date,\n                simulation.start_date + Day(20),\n                stop_date,\n            ),\n        )\n    return observation\nend;\n\nHelper function: Extract latent heat flux from simulation diagnostics\n\nfunction get_lhf(simulation)\n    return ClimaLand.Diagnostics.diagnostic_as_vectors(\n        simulation.diagnostics[1].output_writer,\n        \"lhf_30m_average\",\n    )\nend;\n\nHelper function: Compute diurnal average of a variable\n\nfunction get_diurnal_average(var, start_date, spinup_date, stop_date)\n    (times, data) = var\n    model_dates = if times isa Vector{DateTime}\n        times\n    else\n        date.(times)\n    end\n    spinup_idx = findfirst(spinup_date .<= model_dates)\n    stop_idx = findlast(model_dates .< stop_date)\n    model_dates = model_dates[spinup_idx:stop_idx]\n    data = data[spinup_idx:stop_idx]\n\n    hour_of_day = Hour.(model_dates)\n    mean_by_hour = [mean(data[hour_of_day .== Hour(i)]) for i in 0:23]\n    return mean_by_hour\nend;","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Experiment-Setup","page":"Single site observations","title":"Experiment Setup","text":"We obtain observations from the FLUXNET site. The dataset contains multiple variables, but we will just use latent heat flux in this calibration.\n\ndataset = FluxnetSimulations.get_comparison_data(site_ID, time_offset)\nobservations = get_diurnal_average(\n    (dataset.UTC_datetime, dataset.lhf),\n    start_date,\n    start_date + Day(20),\n    stop_date,\n);\n\nDefine observation noise covariance for the ensemble Kalman process. A flat covariance matrix is used here for simplicity.\n\nnoise_covariance = 0.05 * EKP.I;","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Prior-Distribution-and-Calibration-Configuration","page":"Single site observations","title":"Prior Distribution and Calibration Configuration","text":"Set up the prior distribution for the parameter and configure the ensemble Kalman inversion:\n\nConstrained Gaussian prior for Vcmax25 with bounds [0, 1e-3], and g1 with bounds [0, 1000]. The first two arguments of each prior are the mean and standard deviation of the Gaussian function.\n\npriors = [\n    PD.constrained_gaussian(\"Vcmax25\", 1e-4, 5e-5, 0, 1e-3),\n    PD.constrained_gaussian(\"g1\", 150, 90, 0, 1000),\n]\nprior = PD.combine_distributions(priors);\n\nSet the ensemble size and number of iterations\n\nensemble_size = 10\nN_iterations = 4;","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Ensemble-Kalman-Inversion","page":"Single site observations","title":"Ensemble Kalman Inversion","text":"Initialize and run the ensemble Kalman process:\n\nSample the initial parameter ensemble from the prior distribution\n\ninitial_ensemble = EKP.construct_initial_ensemble(rng, prior, ensemble_size)\n\nensemble_kalman_process = EKP.EnsembleKalmanProcess(\n    initial_ensemble,\n    observations,\n    noise_covariance,\n    EKP.Inversion();\n    scheduler = EKP.DataMisfitController(\n        terminate_at = Inf,\n        on_terminate = \"continue\",\n    ),\n    rng,\n);\n\n┌ Warning: For 2 parameters, the recommended minimum ensemble size (`N_ens`) is 20. Got `N_ens` = 10`.\n└ @ EnsembleKalmanProcesses ~/.julia/packages/EnsembleKalmanProcesses/MwCAA/src/EnsembleKalmanProcess.jl:266\n\n\nRun the ensemble of forward models to iteratively update the parameter ensemble\n\nLogging.with_logger(SimpleLogger(devnull, Logging.Error)) do\n    for i in 1:N_iterations\n        println(\"Iteration $i\")\n        params_i = EKP.get_ϕ_final(prior, ensemble_kalman_process)\n        G_ens = hcat([G(params_i[:, j]...) for j in 1:ensemble_size]...)\n        EKP.update_ensemble!(ensemble_kalman_process, G_ens)\n    end\nend;\n\nIteration 1\nIteration 2\nIteration 3\nIteration 4\n","category":"section"},{"location":"generated/calibration/obs_site_level_calibration/#Results-Analysis-and-Visualization","page":"Single site observations","title":"Results Analysis and Visualization","text":"Get the mean of the final parameter ensemble:\n\nEKP.get_ϕ_mean_final(prior, ensemble_kalman_process);\n\nNow, let's analyze the calibration results by examining parameter evolution and comparing model outputs across iterations.\n\nPlot the parameter ensemble evolution over iterations to visualize convergence:\n\ndim_size = sum(length.(EKP.batch(prior)))\nfig = CairoMakie.Figure(size = ((dim_size + 1) * 500, 500))\n\nfor i in 1:dim_size\n    EKP.Visualize.plot_ϕ_over_iters(\n        fig[1, i],\n        ensemble_kalman_process,\n        prior,\n        i,\n    )\nend\n\nEKP.Visualize.plot_error_over_iters(\n    fig[1, dim_size + 1],\n    ensemble_kalman_process,\n)\nCairoMakie.save(\"obs_constrained_params_and_error.png\", fig);\n\n(Image: )\n\nCompare the model output between the first and last iterations to assess improvement:\n\nfig = CairoMakie.Figure(size = (900, 400))\n\nfirst_G_ensemble = EKP.get_g(ensemble_kalman_process, 1)\nlast_iter = EKP.get_N_iterations(ensemble_kalman_process)\nlast_G_ensemble = EKP.get_g(ensemble_kalman_process, last_iter)\nn_ens = EKP.get_N_ens(ensemble_kalman_process)\n\nax = Axis(\n    fig[1, 1];\n    title = \"G ensemble: first vs last iteration (n = $(n_ens), iters 1 vs $(last_iter))\",\n    xlabel = \"Observation index\",\n    ylabel = \"G\",\n)\n\nAxis with 0 plots:\n\n\nPlot model output of first vs last iteration ensemble\n\nfor g in eachcol(first_G_ensemble)\n    lines!(ax, 1:length(g), g; color = (:red, 0.6), linewidth = 1.5)\nend\n\nfor g in eachcol(last_G_ensemble)\n    lines!(ax, 1:length(g), g; color = (:blue, 0.6), linewidth = 1.5)\nend\n\nlines!(\n    ax,\n    1:length(observations),\n    observations;\n    color = (:black, 0.6),\n    linewidth = 3,\n)\n\naxislegend(\n    ax,\n    [\n        LineElement(color = :red, linewidth = 2),\n        LineElement(color = :blue, linewidth = 2),\n        LineElement(color = :black, linewidth = 4),\n    ],\n    [\"First ensemble\", \"Last ensemble\", \"Observations\"];\n    position = :rb,\n    framevisible = false,\n)\n\nCairoMakie.resize_to_layout!(fig)\nCairoMakie.save(\"obs_G_first_and_last.png\", fig);\n\n(Image: ) Here we can see that the calibration has improved the fit to the data; but this it not the fully story. If other parameters have been set to unrealistic values, the parameters here may be compensating to achieve a lower loss. Moreover, we have only calibrated with two months of data. Production-level calibration runs require careful choice of free parameters and target observations.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/standalone/Bucket/coupled_bucket/#Setting-up-a-Coupled-Simulation","page":"Coupled bucket model","title":"Setting up a Coupled Simulation","text":"For more information about the bucket model, please see the bucket model tutorial.\n\nThis tutorial shows how to set up a simulation for a coupled simulation. More detail for coupled runs can be found in the ClimaCoupler.jl documentation. In preparation for understanding this tutorial, we recommend also reading the intro to multi-component models tutorial as well as being familiar with multiple dispatch programming in Julia.","category":"section"},{"location":"generated/standalone/Bucket/coupled_bucket/#Background","page":"Coupled bucket model","title":"Background","text":"Recall that in order to drive the system in standalone mode, the user must provide prescribed functions of time for the water volume flux in precipitation,  for the net downward shortwave and longwave radiative energy fluxes, for the atmospheric temperature T_a, wind speed u_a (m/s), specific humidity q_a, and air density ρ_a (kg/m^3) at a reference height h_a (m).\n\nTurbulent surface fluxes are computed by the bucket model at each step of the simulation, using the land surface properties as well as the prescribed atmospheric properties, according to Monin-Obukhov theory. These fluxes, as well as the net radiation, are stored in the auxiliary state of the bucket model: p.bucket.turbulent_fluxes.lhf, p.bucket.turbulent_fluxes.shf, p.bucket.turbulent_fluxes.vapor_flux, p.bucket.R_n, where they are accessible when boundary conditions are required in the ODE functions (right hand side) of the prognostic equations. Similarily, the precipitation rates are provided from prescribed conditions and stored in p.drivers.P_liq, p.drivers.P_snow.\n\nIn a coupled simulation, this changes. The coupler computes turbulent surface fluxes based on information (prognostic state, parameters) passed to it by both the atmosphere and land models. Net radiation is computed within the atmosphere model, using the prognostic land surface temperature and the land surface albedo, and passed back to the land model via the coupler. These details are important, but from the point of view of the land model, we only need to know that the coupler accesses land model variables to compute fluxes, and that the coupler passes these fluxes back to the land model.\n\nIn our current setup, \"passed back to the land model via the coupler\" means that the coupler accesses the auxiliary state of the land model and modifies it, at each step in the simulation, so that it holds the current net radiation, precipitation, and turbulent surface fluxes (p.bucket.turbulent_fluxes, p.bucket.R_n, p.drivers.P_liq, p.drivers.P_snow). These quantities are then still available in the ODE functions of the prognostic equations for the bucket model, as in the standalone case.\n\nIn order for the land model to be able to run both in standalone mode, and a coupled mode, within a single interface, we make use of multiple dispatch.","category":"section"},{"location":"generated/standalone/Bucket/coupled_bucket/#Turbulent-Surface-Fluxes-and-Radiation","page":"Coupled bucket model","title":"Turbulent Surface Fluxes and Radiation","text":"Let's review how turbulent surface fluxes and radiation are computed by the land model. The user first creates the prescribed atmosphere and prescribed radiation drivers. In pseudo code, this might look something like:\n\nprescribed_atmos = PrescribedAtmosphere{FT}(*driver data passed in here*)\nprescribed_radiation = PrescribedRadiativeFluxes{FT}(*driver data passed in here*)\n\nThese are stored in the BucketModel object, along with BucketParameters. In order to compute turbulent surface fluxes, we call turbulent_fluxes!, with arguments including prescribed_atmos. Since this argument is of the type PrescribedAtmosphere, the method of turbulent_fluxes which is executed is one which computes the turbulent surface fluxes using MOST. We have a similar function for net_radiation and which computes the net radiation based on the prescribed downwelling radiative fluxes, stored in an argument prescribed_radiation, which is of type PrescribedRadiation.\n\nIn the coupled case, we want different behavior. We have defined new coupled types to use instead of the \"prescribed\" types:\n\nstruct CoupledAtmosphere{FT} <: AbstractAtmosphericDrivers{FT} end\nstruct CoupledRadiativeFluxes{FT} <: AbstractRadiativeDrivers{FT} end\n\nThen, we have defined a new method for turbulent_fluxes! and net_radiation! which dispatch for these types. Since the coupler has updated p.bucket.turbulent_fluxes and p.bucket.R_n in place, we do not need to do anything. In code:\n\nfunction ClimaLand.turbulent_fluxes!(\n   dest,\n   atmos::CoupledAtmosphere,\n   model::BucketModel,\n   p)\n   return nothing\nend\n\nsimilarily:\n\nfunction ClimaLand.net_radiation!(\n    dest,\n    radiation::CoupledRadiativeFluxes{FT},\n    model::BucketModel{FT},\n    p)\n    return nothing\nend\n\nImportantly, these functions are called by the bucket model each time step after the coupler has already computed these values (or extracted them from another model) and modified p! Please note that the behavior in the LandModel is different. In that case, the land model computes its fluxes in its step, regardless of if the simulation is coupled or standalone. We will unify this behavior in the future.","category":"section"},{"location":"generated/standalone/Bucket/coupled_bucket/#Surface-air-density","page":"Coupled bucket model","title":"Surface air density","text":"Within the right hand side/ODE function calls for the bucket model, we need both the surface air density (for computing specific humidity at the surface). In standalone runs, we call the function surface_air_density, This function uses the atmospheric state and surface temperature to estimate the surface air density assuming an ideal gas and hydrostatic balance and by extrapolating from the air density at the lowest level of the atmosphere.\n\nAgain, this functions is called in the ODE function of the bucket model after the coupler has updated the values of p with the correct values at that timestep.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"physical_units/#Physical-units","page":"Physical units","title":"Physical units","text":"CliMA, in all its repositories, uses Standard Units, reminded below:\n\nQuantity Unit Name SI Symbol SI Unit Equivalent\nLength Meter m 1 m\nMass Kilogram kg 1 kg\nTime Second s 1 s\nTemperature Kelvin K 1 K\nAmount of Substance Mole mol 1 mol\nEnergy Joule J 1 J = 1 N·m\nPower Watt W 1 W = 1 J/s\nPressure Pascal Pa 1 Pa = 1 N/m²\nFrequency Hertz Hz 1 Hz = 1 s⁻¹","category":"section"},{"location":"APIs/SolverFunctions/#Solver-Functions","page":"Solver Functions","title":"Solver Functions","text":"","category":"section"},{"location":"APIs/SolverFunctions/#Prognostic-Variables","page":"Solver Functions","title":"Prognostic Variables","text":"","category":"section"},{"location":"APIs/SolverFunctions/#Sources","page":"Solver Functions","title":"Sources","text":"","category":"section"},{"location":"APIs/SolverFunctions/#Boundary-Conditions","page":"Solver Functions","title":"Boundary Conditions","text":"","category":"section"},{"location":"APIs/SolverFunctions/#Implicit-Tendencies","page":"Solver Functions","title":"Implicit Tendencies","text":"","category":"section"},{"location":"APIs/SolverFunctions/#Explicit-Tendencies","page":"Solver Functions","title":"Explicit Tendencies","text":"","category":"section"},{"location":"APIs/SolverFunctions/#ClimaLand.prognostic_vars","page":"Solver Functions","title":"ClimaLand.prognostic_vars","text":"prognostic_vars(soil::RichardsModel)\n\nA function which returns the names of the prognostic variables of RichardsModel.\n\n\n\n\n\nprognostic_vars(soil::EnergyHydrology)\n\nA function which returns the names of the prognostic variables of EnergyHydrology.\n\n\n\n\n\nprognostic_vars(::SnowModel)\n\nReturns the prognostic variable names of the snow model.\n\nFor this model, we track the snow water equivalent S in meters (liquid water volume per ground area) and the energy per unit ground area U [J/m^2] prognostically.\n\n\n\n\n\nprognostic_vars(m::AbstractModel)\n\nReturns the prognostic variable symbols for the model in the form of a tuple.\n\nNote that this default suggests that a model has no prognostic variables, which is an invalid model setup. This function is meant to be extended for all models.\n\n\n\n\n\nClimaLand.prognostic_vars(::AbstractCanopyComponent)\n\nReturns the prognostic vars of the canopy component passed in as an argument.\n\n\n\n\n\nprognostic_vars(canopy::CanopyModel)\n\nReturns the prognostic variables for the canopy model by looping over each sub-component name in canopy_components.\n\nThis relies on the propertynames of CanopyModel being the same as those returned by canopy_components.\n\n\n\n\n\nprognostic_vars(model::PlantHydraulicsModel)\n\nA function which returns the names of the prognostic variables of the PlantHydraulicsModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.prognostic_types","page":"Solver Functions","title":"ClimaLand.prognostic_types","text":"prognostic_types(soil::EnergyHydrology{FT}) where {FT}\n\nA function which returns the types of the prognostic variables of EnergyHydrology.\n\n\n\n\n\nprognostic_types(::SnowModel{FT})\n\nReturns the prognostic variable types of the snow model; both snow water equivalent and energy per unit area are scalars.\n\n\n\n\n\nprognostic_types(m::AbstractModel{FT}) where {FT}\n\nReturns the prognostic variable types for the model in the form of a tuple.\n\nTypes provided must have ClimaCore.RecursiveApply.rzero(T::DataType)  defined. Common examples  include\n\nFloat64, Float32 for scalar variables (a scalar value at each\n\ncoordinate point)\n\nSVector{k,Float64} for a mutable but statically sized array of\n\nlength k at each coordinate point.\n\nHere, the coordinate points are those returned by coordinates(model).\n\nNote that this default suggests that a model has no prognostic variables, which is an invalid model setup. This function is meant to be extended for all models.\n\n\n\n\n\nClimaLand.prognostic_types(::AbstractCanopyComponent)\n\nReturns the prognostic types of the canopy component passed in as an argument.\n\n\n\n\n\nprognostic_types(canopy::CanopyModel)\n\nReturns the prognostic types for the canopy model by looping over each sub-component name in canopy_components.\n\nThis relies on the propertynames of CanopyModel being the same as those returned by canopy_components.\n\n\n\n\n\nClimaLand.prognostic_types(model::PlantHydraulicsModel{FT}) where {FT}\n\nDefines the prognostic types for the PlantHydraulicsModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.prognostic_domain_names","page":"Solver Functions","title":"ClimaLand.prognostic_domain_names","text":"prognostic_domain_names(::SnowModel)\n\nReturns the prognostic variable domain names of the snow model; both snow water equivalent and energy per unit area are modeling only as a function of (x,y), and not as a function of depth. Therefore their domain name is \":surface\".\n\n\n\n\n\nprognostic_domain_names(m::AbstractModel)\n\nReturns the domain names for the prognostic variables in the form of a tuple.\n\nExamples: (:surface, :surface, :subsurface).\n\nNote that this default suggests that a model has no prognostic variables, which is an invalid model setup. This function is meant to be extended for all models.\n\n\n\n\n\nprognostic_domain_names(m::AbstractCanopyComponent)\n\nReturns the domain names for the prognostic variables in the form of a tuple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.initialize_prognostic","page":"Solver Functions","title":"ClimaLand.initialize_prognostic","text":"initialize_prognostic(model::AbstractModel, state::NamedTuple)\n\nReturns a FieldVector of prognostic variables for model with the required structure, with values equal to similar(state). This assumes that all prognostic variables are defined over the entire domain, and that all prognostic variables have the same dimension and type.\n\nIf a model has no prognostic variables, the returned FieldVector contains only an empty array.\n\nThe input state is an array-like object, usually a ClimaCore Field or a Vector{FT}.\n\nAdjustments to this - for example because different prognostic variables have different dimensions - require defining a new method.\n\n\n\n\n\ninitialize_prognostic(\n    component::AbstractCanopyComponent,\n    state,\n)\n\nCreates and returns a ClimaCore.Fields.FieldVector with the prognostic variables of the canopy component  component, stored using the name of the component.\n\nThe input state is usually a ClimaCore Field object.\n\n\n\n\n\ninitialize_prognostic(\n    model::CanopyModel{FT},\n    coords,\n) where {FT}\n\nCreates the prognostic state vector of the CanopyModel and returns it as a ClimaCore.Fields.FieldVector.\n\nThe input state is usually a ClimaCore Field object.\n\nThis function loops over the components of the CanopyModel and appends each component models prognostic state vector into a single state vector, structured by component name.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.AbstractSource","page":"Solver Functions","title":"ClimaLand.AbstractSource","text":"AbstractSource{FT <: AbstractFloat}\n\nAn abstract type for types of source terms.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SolverFunctions/#ClimaLand.source!","page":"Solver Functions","title":"ClimaLand.source!","text":"source!(dY::ClimaCore.Fields.FieldVector,\n        src::PhaseChange{FT},\n        Y::ClimaCore.Fields.FieldVector,\n        p::NamedTuple,\n        model\n        )\n\nComputes the source terms for phase change explicitly in time.\n\n\n\n\n\nsource!(dY::ClimaCore.Fields.FieldVector,\n        src::SoilSublimation{FT},\n        Y::ClimaCore.Fields.FieldVector,\n        p::NamedTuple,\n        model\n        )\n\nUpdates dY.soil.θ_i in place with a term due to sublimation; this only affects the surface layer of soil.\n\n\n\n\n\nsource!(dY::ClimaCore.Fields.FieldVector,\n        src::AbstractSource,\n        Y::ClimaCore.Fields.FieldVector,\n        p::NamedTuple\n        )::ClimaCore.Fields.Field\n\nA stub function, which is extended by ClimaLand.\n\n\n\n\n\nsource!(dY::ClimaCore.Fields.FieldVector,\n        src::SoilSublimationwithSnow{FT},\n        Y::ClimaCore.Fields.FieldVector,\n        p::NamedTuple,\n        model\n        )\n\nUpdates dY.soil.θ_i in place with a term due to sublimation; this only affects the surface layer of soil.\n\n\n\n\n\nClimaLand.source!(dY::ClimaCore.Fields.FieldVector,\n                 src::RootExtraction,\n                 Y::ClimaCore.Fields.FieldVector,\n                 p::NamedTuple\n                 model::EnergyHydrology)\n\nAn extension of the ClimaLand.source! function,  which computes source terms for the soil model; this method returns the water and energy loss/gain due to root extraction.\n\n\n\n\n\nClimaLand.source!(dY::ClimaCore.Fields.FieldVector,\n                      src::MicrobeProduction,\n                      Y::ClimaCore.Fields.FieldVector,\n                      p::NamedTuple,\n                      params)\n\nA method which extends the ClimaLand source! function for the case of microbe production of CO2 in soil, consumption of O2_f (volumetric O2 fraction), and consumption of SOC.\n\nPhysics:\n\nCO2 production from microbial respiration (kg C m⁻³ s⁻¹)\nO2 consumption with correct stoichiometry: C + O₂ → CO₂ For every 12 kg C respired, 32 kg O₂ is consumed (ratio = 32/12 = 8/3)\nSOC consumption equals CO2 production to conserve carbon mass\n\n\n\n\n\nClimaLand.source!(\n    dY::ClimaCore.Fields.FieldVector,\n    src::TOPMODELSubsurfaceRunoff,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    model::AbstractSoilModel{FT},\n) where {FT}\n\nAdjusts dY.soil.ϑ_l in place to account for the loss of water due to subsurface runoff.\n\nThe sink term is given by - Rss/h∇ H(twc - ν), where H is the Heaviside function, h∇ is the water table thickness (defined to be where twc>ν), where twc is the total water content,  and Rss is the runoff as a flux(m/s).\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.AbstractBC","page":"Solver Functions","title":"ClimaLand.AbstractBC","text":"AbstractBC\n\nAn abstract type for types of boundary conditions, which will include prescribed functions of space and time as Dirichlet conditions or Neumann conditions, in addition to other  convenient conditions.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SolverFunctions/#ClimaLand.AbstractBoundary","page":"Solver Functions","title":"ClimaLand.AbstractBoundary","text":"AbstractBoundary\n\nAn abstract type to indicate which boundary we are doing calculations for. Currently, we support the top boundary (TopBoundary) and bottom boundary (BottomBoundary).\n\n\n\n\n\n","category":"type"},{"location":"APIs/SolverFunctions/#ClimaLand.TopBoundary","page":"Solver Functions","title":"ClimaLand.TopBoundary","text":"TopBoundary{} <: AbstractBoundary{}\n\nA simple object which should be passed into a function to indicate that we are considering the top boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SolverFunctions/#ClimaLand.BottomBoundary","page":"Solver Functions","title":"ClimaLand.BottomBoundary","text":"BottomBoundary{} <: AbstractBoundary{}\n\nA simple object which should be passed into a function to indicate that we are considering the bottom boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SolverFunctions/#ClimaLand.boundary_vars","page":"Solver Functions","title":"ClimaLand.boundary_vars","text":"boundary_vars(::RichardsAtmosDrivenFluxBC{<:PrescribedPrecipitation,\n                                          <:Runoff.AbstractRunoffModel,\n                                          }, ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_vars method for RichardsAtmosDrivenFluxBC with runoff.\n\nThese variables are updated in place in boundary_flux!.\n\n\n\n\n\nboundary_vars(::AtmosDrivenFluxBC, ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_vars method for AtmosDrivenFluxBC. This adds the surface conditions (SHF, LHF, evaporation, and resistance) and the net radiation to the auxiliary variables.\n\nThese variables are updated in place in soil_boundary_fluxes!.\n\n\n\n\n\nboundary_vars(::MoistureStateBC, ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_vars method for MoistureStateBC at the top boundary.\n\nThese variables are updated in place in boundary_flux!.\n\n\n\n\n\nboundary_vars(::AbstractBC , ::ClimaLand.TopBoundary)\n\nThe list of symbols for additional variables to add to the model auxiliary state, for models solving PDEs, which defaults  to adding storage for the top boundary flux fields, but which can be extended depending on the type of  boundary condition used.\n\nFor the Soil and SoilCO2 models - which solve PDEs - the  tendency functions and  updateboundaryfluxes functions are coded to access the field  :top_bc  to be present in the model cache, which is why  this is the default.  If this is not your (PDE) model's  desired behavior, you can extend this function with a new method.\n\nThe field top_bc_wvec is created to prevent allocations only; it is used in the tendency function only.\n\nUse this function in the exact same way you would use auxiliary_vars.\n\n\n\n\n\nboundary_vars(::AbstractBC, ::ClimaLand.BottomBoundary)\n\nThe list of symbols for additional variables to add to the model auxiliary state, for models solving PDEs, which defaults  to adding storage for the bottom boundary flux fields, but which can be extended depending on the type of  boundary condition used.\n\nFor the Soil and SoilCO2 models - which solve PDEs - the  tendency functions and  updateboundaryfluxes functions are coded to access the field  :bottom_bc  to be present in the model cache, which is why  this is the default.  If this is not your (PDE) model's  desired behavior, you can extend this function with a new method.\n\nThe field bottom_bc_wvec is created to prevent allocations only; it is used in the tendency function only.\n\nUse this function in the exact same way you would use auxiliary_vars.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.boundary_var_domain_names","page":"Solver Functions","title":"ClimaLand.boundary_var_domain_names","text":"boundary_var_domain_names(::RichardsAtmosDrivenFluxBC{<:PrescribedPrecipitation,\n                                          <:Runoff.AbstractRunoffModel,\n                                          },\n                          ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_var_domain_names method for RichardsAtmosDrivenFluxBC with runoff.\n\n\n\n\n\nboundary_var_domain_names(::AtmosDrivenFluxBC,\n                          ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_var_domain_names method for AtmosDrivenFluxBC. This specifies the part of the domain on which the additional variables should be defined.\n\n\n\n\n\nboundary_var_domain_names(::MoistureStateBC, ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_var_domain_names method for MoistureStateBC at the top boundary.\n\n\n\n\n\nboundary_var_domain_names(::AbstractBC, ::ClimaLand.AbstractBoundary)\n\nThe list of domain names for additional variables to add to the model auxiliary state, for models solving PDEs, which defaults  to adding storage on the surface domain  for the top or bottom boundary flux fields, but which can be extended depending on the type of  boundary condition used.\n\nUse in conjunction with boundary_vars, in the same way you would use auxiliary_var_domain_names. \n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.boundary_var_types","page":"Solver Functions","title":"ClimaLand.boundary_var_types","text":"boundary_var_types(::RichardsModel{FT},\n                    ::RichardsAtmosDrivenFluxBC{<:PrescribedPrecipitation,\n                                                <: Runoff.AbstractRunoffModel,\n                                              },\n                    ::ClimaLand.TopBoundary,\n                    ) where {FT}\n\nAn extension of the boundary_var_types method for RichardsAtmosDrivenFluxBC with runoff.\n\n\n\n\n\nboundary_var_types(::Soil.EnergyHydrology{FT}, ::AbstractEnergyHydrologyBC, ::ClimaLand.AbstractBoundary) where {FT}\n\nThe list of domain names for additional variables added to the EnergyHydrology model auxiliary state, which defaults to adding storage for the  boundary flux field.\n\nBecause we supply boundary conditions for water and heat, we found it convenient to have these stored as a NamedTuple under the names top_bc and bottom_bc.\n\n\n\n\n\nboundary_var_types(\n    ::EnergyHydrology{FT},\n    ::AtmosDrivenFluxBC,\n    ::ClimaLand.TopBoundary,\n) where {FT}\n\nAn extension of the boundary_var_types method for AtmosDrivenFluxBC. This specifies the type of the additional variables.\n\n\n\n\n\nboundary_var_types(\n    ::EnergyHydrology{FT},\n    ::AtmosDrivenFluxBC{<:CoupledAtmosphere, <:CoupledRadiativeFluxes},\n    ::ClimaLand.TopBoundary,\n) where {FT}\n\nAn extension of the boundary_var_types method for AtmosDrivenFluxBC with coupled atmosphere and radiative fluxes. This specifies the type of the additional variables.\n\nThis method includes additional fluxes needed by the atmosphere: momentum fluxes (ρτxz, ρτyz) and the buoyancy flux (buoy_flux). These are updated in place when the coupler computes turbulent fluxes, rather than in soil_boundary_fluxes!.\n\nNote that we currently store these in the land model because the coupler computes turbulent land/atmosphere fluxes using ClimaLand functions, and the land model needs to be able to store the fluxes as an intermediary. Once we compute fluxes entirely within the coupler, we can remove this.\n\n\n\n\n\nboundary_var_types(::RichardsModel{FT},\n                    ::MoistureStateBC,\n                    ::ClimaLand.TopBoundary,\n                    ) where {FT}\n\nAn extension of the boundary_var_types method for MoistureStateBC at the     top boundary.\n\n\n\n\n\nboundary_var_types(model::AbstractModel{FT}, ::AbstractBC, ::ClimaLand.AbstractBoundary) where {FT}\n\nThe list of types for additional variables to add to the model auxiliary state, for models solving PDEs, which defaults  to adding a scalar variable on the surface domain  for the top or bottom boundary flux fields, but which can be extended depending on the type of  boundary condition used.\n\nUse in conjunction with boundary_vars, in the same way you would use auxiliary_var_types. The use of a scalar is appropriate for models with a single PDE; models with multiple PDEs will need to supply multiple scalar fields.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.make_imp_tendency","page":"Solver Functions","title":"ClimaLand.make_imp_tendency","text":"make_imp_tendency(model::AbstractImExModel)\n\nReturns an imp_tendency that updates auxiliary variables and updates the prognostic state of variables that are stepped implicitly.\n\ncompute_imp_tendency! should be compatible with SciMLBase.jl solvers.\n\n\n\n\n\nmake_imp_tendency(model::AbstractModel)\n\nReturns an imp_tendency that does nothing. This model type is not stepped explicity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.make_compute_imp_tendency","page":"Solver Functions","title":"ClimaLand.make_compute_imp_tendency","text":"make_compute_imp_tendency(model::RichardsModel)\n\nAn extension of the function make_compute_imp_tendency, for the Richardson- Richards equation.\n\nThis function creates and returns a function which computes the entire right hand side of the PDE for ϑ_l, and updates dY.soil.ϑ_l in place with that value.\n\n\n\n\n\nmake_compute_imp_tendency(model::EnergyHydrology)\n\nAn extension of the function make_compute_imp_tendency, for the integrated soil energy and heat equations, including phase change.\n\nThis version of this function computes the right hand side of the PDE for Y.soil.ϑ_l, which is the only quantity we currently step implicitly.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_compute_imp_tendency(model::AbstractModel)\n\nReturn a compute_imp_tendency! function that updates state variables that we will be stepped implicitly. This fallback sets all tendencies of this model to zero, which is appropriate for models that do not have any implicit tendencies to update. Note that we cannot set dY .= 0 here because this would overwrite the tendencies of all models in the case of an integrated LSM.\n\ncompute_imp_tendency! should be compatible with SciMLBase.jl solvers.\n\n\n\n\n\n ClimaLand.make_compute_imp_tendency(component::AbstractCanopyComponent, canopy)\n\nCreates the computeimptendency!(dY,Y,p,t) function for the canopy component.\n\nSince component models are not standalone models, other information may be needed and passed in (via the canopy model itself). The right hand side for the entire canopy model can make use of these functions for the individual components.\n\n\n\n\n\nmake_compute_imp_tendency(canopy::CanopyModel)\n\nCreates and returns the computeimptendency! for the CanopyModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.make_compute_jacobian","page":"Solver Functions","title":"ClimaLand.make_compute_jacobian","text":"ClimaLand.make_compute_jacobian(model::RichardsModel{FT}) where {FT}\n\nCreates and returns the compute_jacobian! function for RichardsModel. This updates the contribution for the soil liquid water content.\n\nUsing this Jacobian with a backwards Euler timestepper is equivalent to using the modified Picard scheme of Celia et al. (1990).\n\n\n\n\n\nClimaLand.make_compute_jacobian(model::EnergyHydrology{FT}) where {FT}\n\nCreates and returns the compute_jacobian! function for the EnergyHydrology model. This updates the contribution for the soil liquid water content only.\n\nUsing this Jacobian with a backwards Euler timestepper is equivalent to using the modified Picard scheme of Celia et al. (1990).\n\n\n\n\n\nmake_compute_jacobian(model::AbstractModel)\n\nCreates and returns a function which computes the entries of the Jacobian matrix W in place.\n\nIf the implicit tendency function is given by T!(dY, Y, p, t) = make_implicit_tendency(model), the Jacobian should be given by W_{i,j}! = ∂T!_i/∂Y_j, where Y_j is the j-th state variable and T!_i is the implicit tendency of the i-th state variable.\n\nThe default is that no updates are required, but this function must be extended for models that use implicit timestepping.\n\n\n\n\n\nClimaLand.make_compute_jacobian(canopy::CanopyModel)\n\nCreates and returns the compute_jacobian! for the CanopyModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.make_jacobian","page":"Solver Functions","title":"ClimaLand.make_jacobian","text":"make_jacobian(model::AbstractModel)\n\nCreates and returns a function which updates the auxiliary variables p in place and then updates the entries of the Jacobian matrix W for the model in place.\n\nThe default is that no updates are required, no implicit tendency is present, and hence the timestepping is entirely explicit.\n\nNote that the returned function jacobian! should be used as Wfact! in ClimaTimeSteppers.jl and SciMLBase.jl.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.FieldMatrixWithSolver","page":"Solver Functions","title":"ClimaLand.FieldMatrixWithSolver","text":"FieldMatrixWithSolver(Y::ClimaCore.Fields.FieldVector)\n\nOuter constructor for the FieldMatrixWithSolver Jacobian matrix struct. This extends the constructor from ClimaCore.FieldMatrix, filling the object with ClimaLand-specific values.\n\nFor variables that will be stepped implicitly, the Jacobian matrix is a tridiagonal matrix. For variables that will be stepped explicitly, the Jacobian matrix is a negative identity matrix.\n\nTo run a model with one or more prognostic variables stepped implicitly, the Jacobian matrix must be constructed and passed to the solver. All implicitly-stepped variables of the model should be added to the implicit_names tuple, and any explicitly-stepped variables should be added to the explicit_names tuple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.make_exp_tendency","page":"Solver Functions","title":"ClimaLand.make_exp_tendency","text":"make_exp_tendency(model::AbstractModel)\n\nReturns an exp_tendency that updates auxiliary variables and updates the prognostic state of variables that are stepped explicitly.\n\ncompute_exp_tendency! should be compatible with SciMLBase.jl solvers.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SolverFunctions/#ClimaLand.make_compute_exp_tendency","page":"Solver Functions","title":"ClimaLand.make_compute_exp_tendency","text":"make_explicit_tendency(model::Soil.RichardsModel)\n\nAn extension of the function make_compute_imp_tendency, for the Richardson- Richards equation.\n\nConstruct the tendency computation function for the explicit terms of the RHS, which are horizontal components and source/sink terms.\n\n\n\n\n\nmake_compute_exp_tendency(model::EnergyHydrology)\n\nAn extension of the function make_compute_exp_tendency, for the integrated soil energy and heat equations, including phase change.\n\nThis function creates and returns a function which computes the entire right hand side of the PDE for Y.soil.ϑ_l, Y.soil.θ_i, Y.soil.ρe_int, and updates dY.soil in place with those values. All of these quantities will be stepped explicitly.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_compute_exp_tendency(model::BucketModel{FT}) where {FT}\n\nCreates the computeexptendency! function for the bucket model.\n\n\n\n\n\nmake_compute_exp_tendency(model::AbstractModel)\n\nReturn a compute_exp_tendency! function that updates state variables that we will be stepped explicitly. This fallback sets all tendencies of this model to zero, which is appropriate for models that do not have any explicit tendencies to update. Note that we cannot set dY .= 0 here because this would overwrite the tendencies of all models in the case of an integrated LSM.\n\ncompute_exp_tendency! should be compatible with SciMLBase.jl solvers.\n\n\n\n\n\n ClimaLand.make_compute_exp_tendency(component::AbstractCanopyComponent, canopy)\n\nCreates the computeexptendency!(dY,Y,p,t) function for the canopy component.\n\nSince component models are not standalone models, other information may be needed and passed in (via the canopy model itself). The right hand side for the entire canopy model can make use of these functions for the individual components.\n\n\n\n\n\nmake_compute_exp_tendency(canopy::CanopyModel)\n\nCreates and returns the computeexptendency! for the CanopyModel.\n\n\n\n\n\nmake_compute_exp_tendency(model::SoilCO2Model)\n\nAn extension of the function make_compute_exp_tendency, for the soilco2 equation. This function creates and returns a function which computes the entire right hand side of the PDE for CO2, O2_f, and SOC, and updates dY.soilco2.CO2, dY.soilco2.O2_f, and dY.soilco2.SOC in place with those values. These quantities will be stepped explicitly.\n\nFor O2f (volumetric fraction), we convert to O2 mass concentration using ideal gas law, apply diffusion, then convert back to O2f tendency.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_compute_exp_tendency(model::PlantHydraulicsModel, _)\n\nA function which creates the computeexptendency! function for the PlantHydraulicsModel. The computeexptendency! function must comply with a rhs function of SciMLBase.jl.\n\nBelow, fa denotes a flux multiplied by the relevant cross section (per unit area ground, or area index, AI). The tendency for the ith compartment can be written then as: ∂ϑ[i]/∂t = 1/(AI*dz)[fa[i]-fa[i+1]).\n\nNote that if the area_index is zero because no plant is present, AIdz is zero, and the fluxes fa appearing in the numerator are zero because they are scaled by AI.\n\nTo prevent dividing by zero, we change AI/(AI x dz)\" to \"AI/max(AI x dz, eps(FT))\"\n\n\n\n\n\n","category":"function"},{"location":"generated/integrated/snowy_land_fluxnet_tutorial/#soilcanopy_fluxnet","page":"Canopy, soil, and snow","title":"Fluxnet simulations with the full land model: snow, soil, canopy","text":"In the SoilCanopyModel tutorial, we demonstrated how to run the an integrated model with a soil and canopy component at the US-MOz fluxnet site. Here we add in a snow component, and run at the Niwot Ridge site instead. The forcing data was obtained from AmeriFlux FLUXNET Blanken et al. [23]\n\nThe focus of this tutorial is to learn the steps towards setting up and running an integrated simulation, and less on the parameterization choices. As such, the default parameters are implicitly set. To experiment with modularity in the parameters and parameterizations, please see the soil parameterizations tutorial, the canopy parameterizations tutorial, or the snowy land parameterizations tutorial.","category":"section"},{"location":"generated/integrated/snowy_land_fluxnet_tutorial/#Preliminary-Setup","page":"Canopy, soil, and snow","title":"Preliminary Setup","text":"using Dates\nimport ClimaParams as CP\nusing ClimaDiagnostics\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Simulations\nimport ClimaLand.Parameters as LP\nusing DelimitedFiles\nimport ClimaLand.FluxnetSimulations as FluxnetSimulations\nusing CairoMakie, ClimaAnalysis, GeoMakie, Printf, StatsBase\nimport ClimaLand.LandSimVis as LandSimVis;\n\nDefine the floating point precision desired (64 or 32 bit), and get the parameter set holding constants used across CliMA Models.\n\nconst FT = Float32;\ntoml_dict = LP.create_toml_dict(FT);\n\nWe will use prescribed atmospheric and radiative forcing from the US-NR1 tower.  We also read in the MODIS LAI and let that vary in time in a prescribed manner.\n\nsite_ID = \"US-NR1\";\nsite_ID_val = FluxnetSimulations.replace_hyphen(site_ID);\n\nGet the latitude and longitude in degrees, as well as the time offset in hours of local time from UTC\n\n(; time_offset, lat, long) =\n    FluxnetSimulations.get_location(FT, Val(site_ID_val));\n\nGet the height of the sensors in m\n\n(; atmos_h) = FluxnetSimulations.get_fluxtower_height(FT, Val(site_ID_val));\n\nSet a start and stop date of the simulation in UTC, as well as a timestep in seconds\n\n(start_date, stop_date) =\n    FluxnetSimulations.get_data_dates(site_ID, time_offset)\nΔt = 450.0;\n\nSetup the domain for the model. This corresponds to a column of 2m in depth, with 10 equally spaced layers. The lat and long are provided so that we can look up default parameters for this location using the default ClimaLand parameter maps.\n\nzmin = FT(-2) # in m\nzmax = FT(0) # in m\ndomain = Column(; zlim = (zmin, zmax), nelements = 10, longlat = (long, lat));\n\nForcing data for the site - this uses our interface for working with Fluxnet data\n\nforcing = FluxnetSimulations.prescribed_forcing_fluxnet(\n    site_ID,\n    lat,\n    long,\n    time_offset,\n    atmos_h,\n    start_date,\n    toml_dict,\n    FT,\n);\n\nLAI for the site - this uses our interface for working with MODIS data.\n\nLAI = ClimaLand.Canopy.prescribed_lai_modis(\n    domain.space.surface,\n    start_date,\n    stop_date,\n);","category":"section"},{"location":"generated/integrated/snowy_land_fluxnet_tutorial/#Setup-the-integrated-model","page":"Canopy, soil, and snow","title":"Setup the integrated model","text":"We want to simulate the canopy-soil-snow system together, so the model type LandModel is chosen. Here we use the highest level model constructor, which uses default parameters, and parameterizations, for the soil, snow, and canopy models.\n\nland_model = LandModel{FT}(forcing, LAI, toml_dict, domain, Δt);\nset_ic! = FluxnetSimulations.make_set_fluxnet_initial_conditions(\n    site_ID,\n    start_date,\n    time_offset,\n    land_model,\n);\noutput_vars = [\"swu\", \"lwu\", \"shf\", \"lhf\", \"swe\", \"swc\", \"si\"]\ndiagnostics = ClimaLand.default_diagnostics(\n    land_model,\n    start_date;\n    output_writer = ClimaDiagnostics.Writers.DictWriter(),\n    output_vars,\n    reduction_period = :hourly,\n);\n\nChoose how often we want to update the forcing. Choosing a frequency > the data frequency results in linear interpolation in time to the intermediate times.\n\ndata_dt = Second(FluxnetSimulations.get_data_dt(site_ID));\n\nNow we can construct the simulation object and solve it.\n\nsimulation = Simulations.LandSimulation(\n    start_date,\n    stop_date,\n    Δt, # seconds\n    land_model;\n    set_ic!,\n    updateat = Second(data_dt),\n    user_callbacks = (),\n    diagnostics,\n);\nsolve!(simulation);\n\nWe can optionally save the simulation parameters to a file for later reference. Here we specify the filepath where we want to save the parameters, and then ClimaParams handles the saving. Note that any parameters overwritten via keyword arguments when constructing models will not be reflected in this file (in this example there are none).\n\nparameter_log_file = \"snowy_land_fluxnet_parameters.toml\"\nCP.log_parameter_information(toml_dict, parameter_log_file)\n\n┌ Warning: Keys are present in parameter file but not used in the simulation. \n│  Typically this is due to a mismatch in parameter name in toml and in source. Offending keys: Any[\"bucket_z_0m\", \"pmodel_Ha_Vcmax\", \"pmodel_ϕ0_c3\", \"molar_mass_oxygen\", \"pmodel_ϕ0_c4\", \"pmodel_ϕa1_c4\", \"pmodel_bRd\", \"bucket_z_0b\", \"critical_snow_fraction\", \"molar_mass_carbon\", \"michaelis_constant\", \"soil_C_substrate_diffusivity\", \"alpha_0\", \"oxygen_diffusion_coefficient\", \"moisture_stress_c\", \"x0\", \"pmodel_oi\", \"bucket_beta_decay_exponent\", \"bucket_capacity_fraction\", \"soilCO2_activation_energy\", \"pmodel_ΔHko\", \"k\", \"alpha_snow\", \"pmodel_α\", \"pmodel_ΔHkc\", \"pmodel_aRd\", \"pmodel_ϕa0_c3\", \"pmodel_Kc25\", \"pmodel_ϕa2_c4\", \"pmodel_Hd_Vcmax\", \"pmodel_Γstar25\", \"pmodel_ϕa1_c3\", \"pmodel_Ha_Jmax\", \"delta_alpha\", \"pmodel_Hd_Jmax\", \"pmodel_aS_Vcmax\", \"pmodel_bS_Vcmax\", \"bucket_soil_conductivity\", \"O2_michaelis_constant\", \"pmodel_aS_Jmax\", \"CO2_diffusion_coefficient\", \"soilCO2_pre_exponential_factor\", \"critical_snow_water_equivalent\", \"pmodel_fC3\", \"pmodel_cstar\", \"pmodel_ΔHΓstar\", \"pmodel_bS_Jmax\", \"pmodel_ϕa2_c3\", \"land_bucket_capacity\", \"bucket_soil_heat_capacity\", \"pmodel_Ko25\", \"soluble_soil_carbon_fraction\", \"beta\", \"pmodel_β\", \"pmodel_ϕa0_c4\"]\n└ @ ClimaParams ~/.julia/packages/ClimaParams/FGt0m/src/ClimaParams.jl:370\n","category":"section"},{"location":"generated/integrated/snowy_land_fluxnet_tutorial/#Plotting-results","page":"Canopy, soil, and snow","title":"Plotting results","text":"LandSimVis.make_diurnal_timeseries(\n    simulation;\n    short_names = [\"shf\", \"lhf\", \"swu\", \"lwu\"],\n    spinup_date = start_date + Day(20),\n    plot_stem_name = \"US_NR1_diurnal_timeseries\",\n);\n\n(Image: ) (Image: ) (Image: ) (Image: )\n\nLandSimVis.make_timeseries(\n    simulation;\n    short_names = [\"swc\", \"si\", \"swe\"],\n    spinup_date = start_date + Day(20),\n    plot_stem_name = \"US_NR1_timeseries\",\n);\n\n(Image: ) (Image: ) (Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"standalone/pages/vegetation/canopy_structure/prescribed_structure/#Canopy-Structure-(Prescribed)","page":"Prescribed structure","title":"Canopy Structure (Prescribed)","text":"The canopy structure is prescribed. the following states are read from maps:\n\nLeaf area index (LAI) and rooting depth.\n\nThe Following are scalars:\n\nStem area index (SAI), root area index (RAI) and canopy height.","category":"section"},{"location":"APIs/canopy/soil_moisture_stress/#Soil-moisture-stress","page":"Soil moisture stress","title":"Soil moisture stress","text":"","category":"section"},{"location":"APIs/canopy/soil_moisture_stress/#Models-and-Parameters","page":"Soil moisture stress","title":"Models and Parameters","text":"","category":"section"},{"location":"APIs/canopy/soil_moisture_stress/#Methods","page":"Soil moisture stress","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/soil_moisture_stress/#ClimaLand.Canopy.TuzetMoistureStressModel","page":"Soil moisture stress","title":"ClimaLand.Canopy.TuzetMoistureStressModel","text":"TuzetMoistureStressModel{FT} <: AbstractSoilMoistureStressModel{FT}\n\nAn implementation of the Tuzet moisture stress function.\n\nβm = min(1, (1 + exp(sc * pc)) / (1 + exp(sc * (pc - p_leaf)))), where sc and pc are stored in the parameter struct.\n\nTUZET, A., PERRIER, A. and LEUNING, R. (2003), A coupled model of stomatal conductance,     photosynthesis and transpiration. Plant, Cell & Environment, 26: 1097-1116.     https://doi.org/10.1046/j.1365-3040.2003.01035.x\n\nDuursma, R. A., and Medlyn, B. E. (2012). MAESPA: A model to study interactions between water limitation, environmental drivers and vegetation function at tree and stand levels, with an example application to [CO2] ! drought interactions. Geoscientific Model Development, 5, 919–940.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/soil_moisture_stress/#ClimaLand.Canopy.TuzetMoistureStressModel-Union{Tuple{ClimaParams.ParamDict}, Tuple{FT}} where FT","page":"Soil moisture stress","title":"ClimaLand.Canopy.TuzetMoistureStressModel","text":"TuzetMoistureStressModel{FT}(toml_dict; sc::FT = toml_dict[\"moisture_stress_sc\"], pc::FT = toml_dict[\"moisture_stress_pc\"]) where{FT}\n\nA constructor for TuzetMoistureStressModel which uses the toml_dict values, allowing optional overrides by keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/soil_moisture_stress/#ClimaLand.Canopy.PiecewiseMoistureStressModel","page":"Soil moisture stress","title":"ClimaLand.Canopy.PiecewiseMoistureStressModel","text":"PiecewiseMoistureStressModel{FT,  F <: Union{FT, ClimaCore.Fields.Field}}\n<: AbstractSoilMoistureStressModel{FT}\n\nAn implementation of a piecewise moisture stress model, taking the form\n\nβm(z) = min(1, [(θ(z)-θlow)/(θhigh - θlow)]^c), where θhigh, θ_low, and c are parameters, and θ(z) is the soil moisture at z.\n\nThe parameters should fall within the following ranges:\n\nθhigh>θlow should be in (θ_r, ν) where ν is the porosity of the soil\nc should be positive\n\nSee Egea et al. (2011) for details. Citation: https://doi.org/10.1016/j.agrformet.2011.05.019\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/soil_moisture_stress/#ClimaLand.Canopy.PiecewiseMoistureStressModel-Tuple{Any, ClimaParams.ParamDict}","page":"Soil moisture stress","title":"ClimaLand.Canopy.PiecewiseMoistureStressModel","text":"PiecewiseMoistureStressModel{FT}(\ndomain,\ntoml_dict::CP.ParamDict;\nc::FT = toml_dict[\"moisture_stress_c\"],\nsoil_params\n\n) where {FT <: AbstractFloat}\n\nHelper function to create PiecewiseMoistureStressModel by calculating field capacity (θhigh) and wilting point (θlow) from the soil parameters.\n\nThe low and high thresholds for the piecewise soil moisture stress function are given by the residual soil water content and the soil porosity, respectively.\n\nThe soil parameters should be a named tuple with keys of ν and θ_r  (additional keys may be present but they will not be used). These may  be ClimaCore fields or floats, but must be consistently one or the other.\n\nNote that unlike other Canopy components, this model is defined on the subsurface domain.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/soil_moisture_stress/#ClimaLand.Canopy.NoMoistureStressModel","page":"Soil moisture stress","title":"ClimaLand.Canopy.NoMoistureStressModel","text":"struct NoMoistureStressModel{FT} <: AbstractSoilMoistureStressModel{FT} end\n\nA constructor for NoMoistureStressModel, which sets βm = 1.0 always.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/soil_moisture_stress/#ClimaLand.Canopy.update_soil_moisture_stress!","page":"Soil moisture stress","title":"ClimaLand.Canopy.update_soil_moisture_stress!","text":"update_soil_moisture_stress!(\n    p,\n    Y,\n    model::TuzetMoistureStressModel,\n    canopy,\n)\n\nComputes and updates in place the soil moisture stress for the Tuzet formulation.\n\n\n\n\n\nupdate_soil_moisture_stress!(\n    p,\n    Y,\n    model::PiecewiseMoistureStressModel,\n    canopy,\n)\n\nThis updates the soil moisture stress factor according to the piecewise soil moisture stress model. It calls the function update_piecewise_soil_moisture_stress!, which has different methods for PrognosticGroundConditions and PrescribedGroundConditions.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/soil_moisture_stress/#ClimaLand.Canopy.update_piecewise_soil_moisture_stress!","page":"Soil moisture stress","title":"ClimaLand.Canopy.update_piecewise_soil_moisture_stress!","text":"update_piecewise_soil_moisture_stress!(ground::PrognosticGroundConditions, p, Y, model, canopy)\n\nUpdates the soil moisture stress using the piecewise model for a prognostic soil model, where θ is vertically resolved and prognostic.\n\n\n\n\n\nupdate_piecewise_soil_moisture_stress!(ground::PrescribedGroundConditions, p, Y, model, canopy)\n\nUpdates the soil moisture stress using the piecewise model for PrescribedGroundConditions. Since θ is prescribed, we access the relevant parameters from the moisture stress model and compute the stress factor directly from p.drivers.θ.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/soil_moisture_stress/#ClimaLand.Canopy.compute_tuzet_moisture_stress","page":"Soil moisture stress","title":"ClimaLand.Canopy.compute_tuzet_moisture_stress","text":"compute_tuzet_moisture_stress(\n    p_leaf::FT,\n    pc::FT,\n    sc::FT\n) where {FT}\n\nThis pointwise function computes the soil moisture stress factor using the leaf water potential (Pa) and two parameters sc (sensitivity to low water potential, Pa^-1) and pc (reference water potential, Pa).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/soil_moisture_stress/#ClimaLand.Canopy.compute_piecewise_moisture_stress","page":"Soil moisture stress","title":"ClimaLand.Canopy.compute_piecewise_moisture_stress","text":"compute_piecewise_moisture_stress(\n    θ_high::FT,\n    θ_low::FT,\n    c::FT,\n    θ::FT,\n) where {FT}\n\nThis function computes at a point the soil moisture stress factor using the volumetric water content θ (m^3/m^3) and four parameters: θ_high (field capacity, m^3/m^3), θ_low (wilting point, m^3/m^3), c (curvature parameter, unitless). See  Egea et al. (2011).\n\nCitation: https://doi.org/10.1016/j.agrformet.2011.05.019\n\n\n\n\n\n","category":"function"},{"location":"APIs/AbstractModels/#ClimaLand-Abstract-Models-and-Functions","page":"Abstract Models and Functions","title":"ClimaLand Abstract Models and Functions","text":"","category":"section"},{"location":"APIs/AbstractModels/#ClimaLand.AbstractModel","page":"Abstract Models and Functions","title":"ClimaLand.AbstractModel","text":"abstract type AbstractModel{FT <: AbstractFloat}\n\nAn abstract type for all models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/AbstractModels/#ClimaLand.AbstractExpModel","page":"Abstract Models and Functions","title":"ClimaLand.AbstractExpModel","text":"AbstractExpModel{FT} <: AbstractModel{FT}\n\nAn abstract type for models which must be treated explicitly. This inherits all the default function definitions from AbstractModel, as well as a make_imp_tendency default.\n\n\n\n\n\n","category":"type"},{"location":"APIs/AbstractModels/#ClimaLand.AbstractImExModel","page":"Abstract Models and Functions","title":"ClimaLand.AbstractImExModel","text":"AbstractImExModel{FT} <: AbstractModel{FT}\n\nAn abstract type for models which must be treated implicitly (and which may also have tendency terms that can be treated explicitly). This inherits all the default function definitions from AbstractModel, as well as make_imp_tendency and make_compute_imp_tendency defaults.\n\n\n\n\n\n","category":"type"},{"location":"APIs/AbstractModels/#ClimaLand.name","page":"Abstract Models and Functions","title":"ClimaLand.name","text":"name(model::AbstractModel)\n\nReturns a symbol of the model component name, e.g. :soil or :vegetation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AbstractModels/#ClimaLand.initialize","page":"Abstract Models and Functions","title":"ClimaLand.initialize","text":"initialize(model::AbstractModel)\n\nCreates the prognostic and auxiliary states structures, but with unset values; constructs and returns the coordinates for the model domain. We may need to consider this default more as we add diverse components and Simulations.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AbstractModels/#ClimaLand.get_earth_param_set","page":"Abstract Models and Functions","title":"ClimaLand.get_earth_param_set","text":"get_earth_param_set(model::AbstractModel)\n\nA helper function which returns the earthparamset of the model.\n\n\n\n\n\n","category":"function"},{"location":"standalone/pages/soil/physics/energy_model/#EnergyHydrology","page":"Energy+Hydrology model","title":"Energy+Hydrology","text":"In more complex situations, describing the flow of liquid water in soil is not sufficient. For example, to understand frozen soils, one must also model phase changes, and keep track of the soil temperature to determine when the water in the soil will freeze or melt. The more complex soil model tracks liquid water, frozen water, and the energy of the soil, and is able to capture phase change as well, by augmenting Richards Equation with an equation for ice and energy.\n\nWe have\n\nfracpartial vartheta_lpartial t = - nabla cdot -K nabla h + F_Tρ_l + S_l\nfracd theta_id t = - F_Tρ_i + S_i\nfracpartial rho e_rmintpartial t = - nabla cdot -kappa nabla T - rho e_rmintl K nabla h+S_e\n\n\nwhere:\n\nϑ_l\nis the augmented volumetric liquid fraction, t is the time, K is the hydraulic conductivity, computed from ϑ_l given a retention curve and a permeability curve, ψ is the pressure head, which is computed from ϑ_l given a retention curve function, and h = ψ + z is the hydraulic head,\nθ_i\nis the volumetric ice fraction,\nρe_rmint\nis the volumetric internal energy, κ is the thermal conductivity, T is the temperature, ρe_intl is the volumetric internal energy of the soil liquid water,\nS_e\n, S_i, S_l represent other sources of energy, ice, and water,\nF_T\nis a source term representing phase changes, with ρ_l and ρ_i the density of ice and liquid water.\n\nIn order to solve these equations, the functions ψ(ϑ_lθ_i), K(θ_i ϑ_l T), κ(θ_i ϑ_l), and T(ρe_intθ_i ϑ_l)  must be specified. This in turn requires defining the saturated conductivity K_rmsat, the porosity ν, the residual water content θ_r, and the parameters mapping saturation ϑ_l to K and ψ, and the volumetric specific heat of the soil.\n\nOther sources include root extraction of water (and corresponding extraction of energy), subsurface runoff, and sublimation of ice.\n\nClimaLand supports both the van Genuchten and Brooks and Corey retenton curve/permeability curve pairs, which we refer to in places as the hydrology closure model. For the thermal conductivity, we use the model of Balland and Arp (2003).\n\nSince the liquid water and energy  partial differential equations ire stiff, an implicit timestepping scheme must be used to advance them in time.","category":"section"},{"location":"generated/standalone/Soil/richards_equation/#Hydrostatic-Equilibrium-test-for-Richards-Equation","page":"Richards Equation","title":"Hydrostatic Equilibrium test for Richards Equation","text":"This tutorial shows how to use ClimaLand code to solve Richards equation in a column of soil. We choose boundary conditions of zero flux at the top and bottom of the column, and then run the simulation long enough to see that the system is approaching hydrostatic equilibrium, where the gradient of the pressure head is equal and opposite the gradient of the gravitational head.\n\nThe equations are:\n\nfrac  ϑ_l t =   K (ϑ_l ν ) h( ϑ_l z ν )\n\nHere\n\nt is the time (s),\n\nz is the location in the vertical (m),\n\nK is the hydraulic conductivity (m/s),\n\nh is the hydraulic head (m),\n\nϑ_l is the augmented volumetric liquid water fraction,\n\nν  denotes parameters relating to soil type, such as porosity.\n\nWe will solve this equation in a 1-d domain with z  -50, and with the following boundary and initial conditions:\n\n- K h(t z = 0) = 0 ẑ\n\n-K h(t z = -5) = 0 ẑ\n\nϑ(t = 0 z) = ν-0001\n\nθ_i(t = 0 z) = 00\n\nwhere nu is the porosity.\n\nWhen solving Richards equation (not a fully integrated energy and hydrology model), the hydraulic conductivity is only a function of liquid moisture content.\n\nLastly, our formulation of this equation allows for a continuous solution in both saturated and unsaturated areas, following Woodward and Dawson [4].","category":"section"},{"location":"generated/standalone/Soil/richards_equation/#Preliminary-setup","page":"Richards Equation","title":"Preliminary setup","text":"Load external packages\n\nimport SciMLBase\nusing Plots\n\nLoad CliMA packages and ClimaLand modules\n\nusing ClimaCore\nimport ClimaParams as CP\nimport ClimaTimeSteppers as CTS\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nimport ClimaLand.Simulations: LandSimulation, solve!\nusing ClimaLand.Soil\n\nimport ClimaLand\nimport ClimaLand.Parameters as LP\n\nDefine the float type desired (Float64 or Float32), and create the TOML dictionary, which holds constants used across CliMA models:\n\nconst FT = Float32;\ntoml_dict = LP.create_toml_dict(FT)\n\nParamDict{Float32} with 669 parameters","category":"section"},{"location":"generated/standalone/Soil/richards_equation/#Set-up-the-soil-model","page":"Richards Equation","title":"Set up the soil model","text":"We want to solve Richards equation alone, without simultaneously solving the heat equation. Because of that, we choose a RichardsModel. Taking a look at the documentation (linked), we see that we need to supply parameters, a domain, boundary conditions, and sources.\n\nFirst, we define the parameters: porosity \\nu, Ksat, the van Genuchten parameters `vgα,vgm,vgn,θ_r`, and the specific storage value for the soil. Note that all values must be given in mks units.\n\nK_sat = FT(0.0443 / (3600 * 100))\nS_s = FT(1e-3)\nν = FT(0.495)\nvg_α = FT(2.6)\nvg_n = FT(2)\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n);\nθ_r = FT(0)\nparams = Soil.RichardsParameters(;\n    ν = ν,\n    hydrology_cm = hcm,\n    K_sat = K_sat,\n    S_s = S_s,\n    θ_r = θ_r,\n);\n\nNext, we define the domain. Here, we are considering a 1D domain, discretized using finite difference, with coordinates z:\n\nzmax = FT(0)\nzmin = FT(-5)\nnelems = 10\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\n\nWe also need to specify the boundary conditions. The user must specify two conditions,  at the top and at the bottom of the domain. We currently support two broad types of boundary conditions: boundary conditions on the state ϑl = ϑl_BC (MoistureStateBC) or on the flux (WaterFluxBC, FreeDrainage, or RichardsAtmosDrivenFluxBC). Flux boundary conditions are passed as the (scalar) z-component of the flux f, i.e. F⃗ = f ẑ. The flux BC RichardsAtmosDrivenFluxBC is for driving Richards equation with a spatially and temporally varying map of precipitation. FreeDrainage is an option only at the bottom of the domain. Here, we set zero flux boundary conditons. WaterFluxBCs require a function of the cache p and the simulation time t:\n\nsurface_flux = Soil.WaterFluxBC((p, t) -> 0.0)\nbottom_flux = Soil.WaterFluxBC((p, t) -> 0.0)\nboundary_conditions = (; top = surface_flux, bottom = bottom_flux);\n\nLastly, in this case we don't have any sources, so we pass an empty tuple:\n\nsources = ();\n\nNow we can make the model itself. This contains every piece of information needed to turn the continuous form of Richards equation into a set of ODEs, ready to be passed off to a timestepper.\n\nsoil = Soil.RichardsModel{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_conditions,\n    sources = sources,\n);\n\n\nfunction set_ic!(Y, p, t0, model)\n    Y.soil.ϑ_l .= FT(0.494)\nend\n\nset_ic! (generic function with 1 method)\n\nWe choose the initial and final simulation times:\n\nt0 = Float64(0)\ntf = Float64(60 * 60 * 24 * 36);\n\nNext, we turn to timestepping. As usual, your timestep depends on the problem you are solving, the accuracy of the solution required, and the timestepping algorithm you are using.\n\ndt = Float64(1e3);\n\nNow, we choose the timestepping algorithm we want to use. We'll use the ARS111 algorithm with 1 Newton iteration per timestep; you can also specify a convergence criterion and a maximum number of Newton iterations.\n\nstepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    stepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\n\nsimulation = LandSimulation(\n    t0,\n    tf,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    solver_kwargs = (; save_everystep = true),\n    timestepper = ode_algo,\n    user_callbacks = (),\n    diagnostics = (),\n);\n\n┌ Warning: Callback period (10800.0 seconds [counter = 10800, period = 1 second]) is not an integer multiple of dt 1000.0 seconds [counter = 1000, period = 1 second]\n└ @ ClimaLand ~/work/ClimaLand.jl/ClimaLand.jl/src/shared_utilities/utils.jl:753\n\n\nWe can now take a peek at what the initialized variables are:\n\nY = simulation._integrator.u\np = simulation._integrator.p\nY.soil |> propertynames\n\np.soil |> propertynames\n\n(:total_water, :K, :ψ, :bidiag_matrix_scratch, :full_bidiag_matrix_scratch, :top_bc, :top_bc_wvec, :bottom_bc, :bottom_bc_wvec)\n\nNote that the variables are nested into Y and p in a hierarchical way. Since we have the vectors (composed of ClimaCore Fields) handy, we can now set them to the desired initial conditions.\n\nsol = solve!(simulation);","category":"section"},{"location":"generated/standalone/Soil/richards_equation/#Create-some-plots","page":"Richards Equation","title":"Create some plots","text":"We'll plot the moisture content vs depth in the soil, as well as the expected profile of ϑ_l in hydrostatic equilibrium. For ϑ_l values above porosity, the soil is saturated, and the pressure head changes from being equal to the matric potential to the pressure generated by compression of water and the soil matrix. The profile can be solved for analytically by (1) solving for the form that ϑ_l(z) must take in both the saturated and unsaturated zones to satisfy the steady-state requirement with zero flux boundary conditions, (2) requiring that at the interface between saturated and unsaturated zones, the water content equals porosity, and (3) solving for the location of the interface by requiring that the integrated water content at the end matches that at the beginning (yielding an interface location of z≈-0.56m).\n\nt = FT.(sol.t) ./ (60 * 60 * 24);\nϑ_l = [parent(sol.u[k].soil.ϑ_l) for k in 1:length(t)]\nz = parent(soil.domain.fields.z)\nplot(\n    ϑ_l[1],\n    z,\n    label = string(\"t = \", string(t[1]), \"days\"),\n    xlim = [0.47, 0.501],\n    ylabel = \"z\",\n    xlabel = \"ϑ_l\",\n    legend = :bottomleft,\n    title = \"Equilibrium test\",\n);\nplot!(1e-3 .+ ϑ_l[1], z, label = \"porosity\");\nplot!(ϑ_l[end], z, label = string(\"t = \", string(t[end]), \"days\"));\nfunction hydrostatic_equilibrium(z, z_interface)\n    ν = 0.495\n    S_s = 1e-3\n    α = 2.6\n    n = 2.0\n    m = 0.5\n    if z < z_interface\n        return -S_s * (z - z_interface) + ν\n    else\n        return ν * (1 + (α * (z - z_interface))^n)^(-m)\n    end\nend\nplot!(hydrostatic_equilibrium.(z, -0.56), z, label = \"equilibrium solution\");\n\nSave the output:\n\nsavefig(\"equilibrium_test_ϑ_l.png\");\n\nGKS: cannot open display - headless operation mode active\n\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/standalone/Canopy/changing_canopy_parameterizations/#Changing-Canopy-Parameterizations","page":"Changing canopy parameterizations","title":"Changing Canopy Parameterizations","text":"In Default Canopy, we ran a simple canopy model simulation using all of the default parameterizations and parameters. ClimaLand provides multiple options for many parameterizations; in this tutorial, we will demonstrate how to change a canopy model parameterization.\n\nSpecifically, we'll use non-default parameterizations for two canopy components:\n\nenergy model: from the default BigLeafEnergyModel to PrescribedCanopyTempModel\nradiative transfer: from the default TwoStreamModel to BeerLambertModel\n\nFirst import the Julia packages we'll need.\n\nimport ClimaParams as CP\nusing ClimaUtilities.TimeVaryingInputs: TimeVaryingInput\nusing ClimaLand\nusing ClimaLand.Domains\nusing ClimaLand.Canopy\nimport ClimaLand.Simulations: LandSimulation, solve!\nimport ClimaLand.Parameters as LP\nusing Dates\nimport ClimaDiagnostics\nusing CairoMakie, ClimaAnalysis, GeoMakie, Printf, StatsBase\nimport ClimaLand.LandSimVis as LandSimVis\n\nChoose a floating point precision, and get the parameter set, which holds constants used across CliMA models.\n\nFT = Float32\ntoml_dict = LP.create_toml_dict(FT);\n\nWe will run this simulation on a point domain at a lat/lon location near Yellowstone National Park. This is different from the soil example, which ran on a column, because the soil model has depth and the canopy model does not.\n\nlonglat = FT.((-110.6, 44.6))\ndomain = Domains.Point(; z_sfc = FT(0.0), longlat);\nsurface_space = domain.space.surface;\n\nWe choose the initial and final simulation times as DatesTimes, and a timestep in seconds.\n\nstart_date = DateTime(2008);\nstop_date = start_date + Second(60 * 60 * 72);\ndt = 900.0;\n\nWhereas the soil model takes in 2 forcing objects (atmosphere and radiation), the canopy takes in 3 (atmosphere, radiation, and ground). Here we read in the first two from ERA5 data, and specify that the following ground conditions will be prescribed: emissivity, albedo, temperature, and soil moisture. We also set up a constant leaf area index (LAI); for an example reading LAI from MODIS data, please see the canopy tutorial. This differs from the soil example because we have the extra inputs of the ground conditions and LAI.\n\natmos, radiation = ClimaLand.prescribed_forcing_era5(\n    start_date,\n    stop_date,\n    surface_space,\n    toml_dict,\n    FT;\n    use_lowres_forcing = true,\n);\nground = PrescribedGroundConditions{FT}();\nLAI = TimeVaryingInput((t) -> FT(1.0));\n\nNow, we can create the canopy model.\n\nFirst, let's set up the PrescribedCanopyTempModel parameterization. This parameterization acts as a flag to signal that the atmosphere temperature from the prescribed forcing should be used as the canopy temperature. Since this only involves retrieving the temperature from the atmosphere forcing, we do not need to provide any additional parameters, and this setup is straightforward.\n\nenergy = Canopy.PrescribedCanopyTempModel{FT}();\n\nNow let's set up the BeerLambertModel radiative transfer parameterization. We'll explore three different ways to construct this parameterization. The first way is to use the BeerLambertModel constructor with the default parameters. This method requires the simulation domain as it reads in radiation parameters from a map of CLM parameters by default.\n\nradiative_transfer = Canopy.BeerLambertModel{FT}(domain, toml_dict);\n\nAlternatively, we could use the same constructor but provide custom values for each of the parameters. For example, we might want to use the global maps for albedo, but explore how the results change when we assume a spherical distribution of leaves (G = 0.5) and no clumping (Ω = 1).\n\nG_Function = Canopy.ConstantGFunction(FT(0.5)); # leaf angle distribution value 0.5\nΩ = 1; # clumping index\nα_PAR_leaf = 0.1;\nα_NIR_leaf = 0.4;\nradiation_parameters = (; G_Function, Ω, α_PAR_leaf, α_NIR_leaf);\nradiative_transfer =\n    Canopy.BeerLambertModel{FT}(domain, toml_dict; radiation_parameters);\n\nIf you want to overwrite all of the parameters, you do not need to use global maps, and therefore do not need the domain. In a case like this, we may want to use a different BeerLambertModel constructor, which takes the parameters object directly:\n\nradiative_transfer_parameters = Canopy.BeerLambertParameters(\n    toml_dict;\n    G_Function,\n    Ω,\n    α_PAR_leaf,\n    α_NIR_leaf,\n);\nradiative_transfer = Canopy.BeerLambertModel(radiative_transfer_parameters);\n\nNote these parameters must all be scalars (or a single instance of a G_Function) or fields of floats and a field of a G_Function.\n\nAll three of these methods will construct a BeerLambertModel; the first will use the default parameters, while the second and third use the custom parameters. The method you choose will depend on your use case and whether you want to use the default parameters or provide custom ones. The set of available constructors for all ClimaLand models can be found in the \"APIs\" section of the documentation.\n\nNow we can create the CanopyModel model with the specified energy and radiative transfer parameterizations passed as keyword arguments.\n\nmodel = Canopy.CanopyModel{FT}(\n    domain,\n    (; atmos, radiation, ground),\n    LAI,\n    toml_dict;\n    energy,\n    radiative_transfer,\n);\n\nDefine a function to set initial conditions for the prognostic variables. Since these are specific to the model physics, the contents here differ from the soil example, but the function structure remains the same. The variables initialized here are described in the Model Equations section of the documentation. Note that here we previously set the initial condition for the canopy energy model's prognostic temperature. Since we're using the PrescribedCanopyTempModel, we do not need to set it here.\n\nfunction set_ic!(Y, p, t0, model)\n    ψ_leaf_0 = FT(-2e5 / 9800)\n    (; retention_model, ν, S_s) = model.hydraulics.parameters\n    S_l_ini = Canopy.PlantHydraulics.inverse_water_retention_curve(\n        retention_model,\n        ψ_leaf_0,\n        ν,\n        S_s,\n    )\n    Y.canopy.hydraulics.ϑ_l.:1 .=\n        Canopy.PlantHydraulics.augmented_liquid_fraction.(ν, S_l_ini)\nend\n\nset_ic! (generic function with 1 method)\n\nSince we'll want to make some plots, let's set up an object to save the model output periodically, as we did for the soil tutorial.\n\ndiag_writer = ClimaDiagnostics.Writers.DictWriter();\ndiagnostics = ClimaLand.Diagnostics.default_diagnostics(\n    model,\n    start_date;\n    output_vars = [\"ct\", \"trans\"],\n    output_writer = diag_writer,\n    reduction_period = :hourly,\n);\n\nNow construct the LandSimulation object, which contains the model and additional timestepping information. This is identical to the soil example.\n\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    dt,\n    model;\n    set_ic!,\n    updateat = Second(dt),\n    user_callbacks = (),\n    diagnostics,\n);\n\nNow we can run the simulation!\n\nsolve!(simulation);\n\nLet's plot some results, for example diurnally averaged canopy temperature and transpiration over time:\n\nLandSimVis.make_diurnal_timeseries(\n    simulation;\n    short_names = [\"ct\", \"trans\"],\n    plot_stem_name = \"canopy_parameterizations\",\n);\n\n(Image: ) (Image: )\n\nNow you can compare these plots to those generated in the default canopy tutorial. How are the results different? How are they the same?\n\nAtmospheric forcing data citation: Hersbach et al. [18]\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/canopy/PlantHydraulics/#PlantHydraulics","page":"Plant Hydraulics","title":"PlantHydraulics","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/#Models-and-Parameters","page":"Plant Hydraulics","title":"Models and Parameters","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/#Plant-Hydraulics-Parameterizations","page":"Plant Hydraulics","title":"Plant Hydraulics Parameterizations","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/#Constructor-Methods","page":"Plant Hydraulics","title":"Constructor Methods","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/#Plant-Hydraulics-Diagnostic-Variables","page":"Plant Hydraulics","title":"Plant Hydraulics Diagnostic Variables","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.AbstractPlantHydraulicsModel","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.AbstractPlantHydraulicsModel","text":"AbstractPlantHydraulicsModel{FT} <: AbstractCanopyComponent{FT}\n\nAn abstract type for plant hydraulics models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsModel","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsModel","text":"PlantHydraulicsModel{FT, PS, T, AA} <: AbstractPlantHydraulicsModel{FT}\n\nDefines, and constructs instances of, the PlantHydraulicsModel type, which is used for simulation flux of water to/from soil, along roots of different depths, along a stem, to a leaf, and ultimately being lost from the system by transpiration. Note that the canopy height is specified as part of the PlantHydraulicsModel and the biomass model, these must be consistent.\n\nThe model can be used in Canopy standalone mode by prescribing the soil matric potential at the root tips or flux in the roots. There is also the option (intendend only for debugging) to use a prescribed transpiration rate.\n\nn_stem: The number of stem compartments for the plant; can be zero\nn_leaf: The number of leaf compartments for the plant; must be >=1\ncompartment_midpoints: The height of the center of each leaf compartment/stem compartment, in meters\ncompartment_surfaces: The height of the compartments' top faces, in meters. The canopy height is the last element of the vector.\ncompartment_labels: The label (:stem or :leaf) of each compartment\nparameters: Parameters required by the Plant Hydraulics model\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsParameters","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsParameters","text":"PlantHydraulicsParameters\n\nA struct for holding parameters of the PlantHydraulics Model.\n\nν: porosity (m3/m3)\nS_s: storativity (m3/m3)\nconductivity_model: Conductivity model and parameters\nretention_model: Water retention model and parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.AbstractConductivityModel","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.AbstractConductivityModel","text":"AbstractConductivityModel{FT <: AbstractFloat}\n\nAn abstract type for the plant hydraulics conductivity model.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.Weibull","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.Weibull","text":"Weibull{FT} <: AbstractConductivityModel{FT}\n\nA concrete type specifying that a Weibull conductivity model is to be used; the struct contains the require parameters for this model.\n\nFields\n\nK_sat: Maximum Water conductivity in the above-ground plant compartments (m/s) at saturation\nψ63: The absolute water potential in xylem (or xylem water potential) at which ∼63%     of maximum xylem conductance is lost (Liu, 2020).\nc: Weibull parameter c, which controls shape the shape of the conductance curve (Sperry, 2016).\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.AbstractRetentionModel","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.AbstractRetentionModel","text":"AbstractRetentionModel{FT <: AbstractFloat}\n\nAn abstract type for the plant retention curve model.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.LinearRetentionCurve","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.LinearRetentionCurve","text":"LinearRetentionCurve{FT} <: AbstractRetentionModel{FT}\n\nA concrete type specifying that a linear water retention  model is to be used; the struct contains the require parameters for this model.\n\nWhen ψ = 0, the effective saturation is one, so the intercept is not a free parameter, and only the slope must be specified.\n\nFields\n\na: Bulk modulus of elasticity and slope of potential to volume curve. See also Corcuera, 2002, and Christoffersen, 2016.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsModel-Union{Tuple{FT}, Tuple{Any, ClimaParams.ParamDict}} where FT<:AbstractFloat","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsModel","text":"PlantHydraulicsModel{FT}(\n    domain,\n    toml_dict::CP.ParamDict;\n    n_stem::Int = 0,\n    n_leaf::Int = 1,\n    h_stem::FT = FT(0),\n    h_leaf::FT = FT(1),\n    ν::FT = FT(1.44e-4),\n    S_s::FT = FT(1e-2 * 0.0098), # m3/m3/MPa to m3/m3/m\n    conductivity_model = Weibull{FT}(\n        K_sat = FT(7e-8),\n        ψ63 = FT(-4 / 0.0098),\n        c = FT(4),\n    ),\n    retention_model = LinearRetentionCurve{FT}(a = FT(0.2 * 0.0098)),\n) where {FT <: AbstractFloat}\n\nCreates a PlantHydraulicsModel on the provided domain, using paramters from toml_dict.\n\nThe following default parameters are used:\n\nn_stem = 0 (unitless) - number of stem compartments\nn_leaf = 1 (unitless) - number of leaf compartments\nh_stem = 0 (m) - height of the stem compartment\nh_leaf = 1 (m) - height of the leaf compartment\nν = 1.44e-4 (m3/m3) - porosity\nS_s = 1e-2 * 0.0098 (m⁻¹) - storativity\nK_sat = 7e-8 (m/s) - saturated hydraulic conductivity\nψ63 = -4 / 0.0098 (MPa to m) - xylem percentage loss of conductivity curve parameters;\nc = 4 (unitless) - Weibull parameter;\na = 0.2 * 0.0098 (m) - bulk modulus of elasticity;\n\nCitation: Holtzman, N., Wang, Y., Wood, J. D., Frankenberg, C., & Konings, A. G. (2023). Constraining plant hydraulics with microwave radiometry in a land surface model: Impacts of temporal resolution. Water Resources Research, 59, e2023WR035481. https://doi.org/10.1029/2023WR035481\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.water_flux","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.water_flux","text":"water_flux(\n    z1,\n    z2,\n    ψ1,\n    ψ2,\n    K1,\n    K2,\n) where {FT}\n\nComputes the water flux given the absolute potential ψ (pressure/(ρg))  and the conductivity K (m/s) at the center of the two layers with midpoints z1 and z2.\n\nWe currently assuming a harmonic mean for effective conducticity between the two layers (see CLM Technical Documentation).\n\nTo account for different path lengths in the two compartments Δz1 and Δz2, we would require the following conductance k (1/s) k_eff = K1/Δz1*K2/Δz2/(K1/Δz1+K2/Δz2) and a water flux of F = -k_eff * (ψ1 +z1 - ψ2 - z2) (m/s).\n\nThis currently assumes the path lengths are equal.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.effective_saturation","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.effective_saturation","text":"effective_saturation(\n    ν::FT,\n    ϑ_l::FT) where {FT}\n\nComputes the effective saturation given the augmented liquid fraction.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.augmented_liquid_fraction","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.augmented_liquid_fraction","text":"augmented_liquid_fraction(\n    ν::FT,\n    S_l::FT) where {FT}\n\nComputes the augmented liquid fraction from porosity and effective saturation.\n\nAugmented liquid fraction allows for oversaturation: an expansion of the volume of space available for storage in a plant compartment.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.water_retention_curve","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.water_retention_curve","text":"water_retention_curve(\n    S_l::FT,\n    b::FT,\n    ν::FT,\n    S_s::FT) where {FT}\n\nReturns the potential ψ given the effective saturation S at a point, according to a linear model for the retention curve with parameters specified by retention_params.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.inverse_water_retention_curve","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.inverse_water_retention_curve","text":"inverse_water_retention_curve(\n    ψ::FT,\n    b::FT,\n    ν::FT,\n    S_s::FT) where {FT}\n\nReturns the effective saturation given the potential at a point, according to the linear retention curve model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.root_water_flux_per_ground_area!","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.root_water_flux_per_ground_area!","text":"PlantHydraulics.root_water_flux_per_ground_area!(\n    fa::ClimaCore.Fields.Field,\n    s::PrognosticGroundConditions,\n    model::Canopy.PlantHydraulics.PlantHydraulicsModel,\n    canopy,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nAn extension of the PlantHydraulics.root_water_flux_per_ground_area! function,  which returns the net flux of water between the roots and the soil, per unit ground area, when both soil and plant hydraulics are modeled prognostically. This is for use in an LSM.\n\nIt is computed by summing the flux of water per ground area between roots and soil at each soil layer.\n\n\n\n\n\nroot_water_flux_per_ground_area!(\n    fa::ClimaCore.Fields.Field,\n    ground::PrescribedGroundConditions,\n    model::PlantHydraulicsModel{FT},\n    canopy,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n) where {FT}\n\nA method which computes the water flux between the soil and the stem, via the roots, and multiplied by the RAI, in the case of a model running without a prognostic soil model:\n\nFlux = -Keff x [(ψstem - ψsoil)/(zstem - zsoil) + 1], where Keff = Ksoil Kstem /(Kstem + Ksoil)\n\nNote that in PrescribedSoil mode, we compute the flux using Ksoil = Kplant(ψsoil) and Kstem = Kplant(ψstem). In PrognosticSoil mode, we compute the flux using Ksoil = Ksoil(ψsoil) and Kstem = Kplant(ψstem). The latter is a better model, but our PrescribedSoil struct does not store Ksoil, only θsoil. θsoil is converted to ψsoil using the retention curve supplied by hydrology_cm.\n\nThe returned flux is per unit ground area. This assumes that the stem compartment is the first element of Y.canopy.hydraulics.ϑ_l.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.hydraulic_conductivity","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.hydraulic_conductivity","text":"hydraulic_conductivity(conductivity_params::Weibull{FT}, ψ::FT) where {FT}\n\nComputes the hydraulic conductivity at a point, using the Weibull formulation, given the potential ψ.\n\n\n\n\n\n","category":"function"},{"location":"itime/#ITime","page":"ITime type","title":"ITime","text":"ITime, or integer time, is a time type used by CliMA simulations to keep track of simulation time. For more information, refer to the TimeManager section in ClimaUtilities and the ITime section in ClimaAtmos.","category":"section"},{"location":"itime/#How-do-I-use-ITime?","page":"ITime type","title":"How do I use ITime?","text":"There are three fields to an ITime which are counter, period, and epoch. An ITime represents the amount of time, computed as counter * period, that has passed since the epoch. See the example below of constructing an ITime.\n\nusing ClimaUtilities.TimeManager, Dates # ITime is from ClimaUtilities\nt = ITime(3, period = Minute(1), epoch = DateTime(2008))\ncounter(t)\nperiod(t)\nepoch(t)\n\nThe ITime t represents that three minutes have elapsed since 2008. The epoch is chosen to be the start date of the simulation. Note that the counter must be an integer. This means no floating point error can occur!\n\nHowever, what are the differences between the following constructions of ITime?\n\ndt1 = ITime(60000, period = Millisecond(1), epoch = DateTime(2010))\ndt2 = ITime(60, period = Second(1), epoch = DateTime(2010))\ndt3 = ITime(1, period = Minute(1), epoch = DateTime(2010))\n\nThe ITimes dt1, dt2, and dt3 represent the same quantity which is 1 minute since 2010. However, the periods are different between the ITimes. As a result, t1, t2, and t3 can only represent times in terms of milliseconds, seconds, and minutes respectively.\n\nFurthermore, dt1, dt2, and dt3 are all different types.\n\ntypeof(dt1)\ntypeof(dt2)\ntypeof(dt3)\n\nThis raises two concerns to keep in mind when working with ITimes. The period in ITime represents how accurate time is kept tracked of. In the example above, dt3 can only keep track of time that is accurate up to a minute.  This can result in a loss of precision in a simulation if time needs to be resolved with a higher precision than a minute. For example, in the time stepping stages, the result of t + α * dt may be rounded. However, one cannot use nanoseconds for the period because the counter will be large. This runs the risk of integer overflow in the counter. As such, one needs to be careful about what period is chosen for the ITime.\n\nnote: Maximum representable date\nWith a period of Dates.Second(1), an epoch of 2008, and a counter of type Int32, the maximum representable date is 2076-01-19T03:14:07. With Int64 instead for the type of the counter, the maximum representable date is 292277025-08-17T07:12:55.807.With a period of Dates.Millisecond(1), an epoch of 2008, and a counter of type Int32, the maximum representable date is 2008-01-25T20:31:23.647. With Int64 instead for the type of the counter, the maximum representable date is 292277025-08-17T07:12:55.807.\n\nnote: No period provided\nIf no period is provided, then the constructor for ITime will assume the provided value is in seconds and choose a reasonable value for the period. See TimeManager section in ClimaUtilities for more information.\n\nNext, the different types of dt1, dt2, and dt3 can lead to problems as most functions and structs expect a single type for time. This can be solved by using promote which makes all the ITimes have the same type. See the example below.\n\ndt1, dt2, dt3 = promote(dt1, dt2, dt3)\ntypeof(dt1) == typeof(dt2)\ntypeof(dt2) == typeof(dt3)\n\nFinally, other useful functions to know about ITime are date and float. The function date returns the date of t and the function float convert t into a floating point number. See the examples below.\n\nt = ITime(60, period = Second(1), epoch = DateTime(2008))\ndate(t)\nfloat(t)","category":"section"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Single column tutorial","title":"Single column tutorial","text":"The AbstractModel tutorial describes how a user can run simulations of a physical system governed by differential equations. In this framework, the user must define a model type for their problem, which contains all of the information required to set up the system of equations. By extending the methods for make_compute_exp_tendency(model), prognostic_variables(model), etc, the information stored in the model is used to make the system of equations. Given initial conditions, these equations can then be stepped forward in time using the time-stepper of your choice. Note that a model requiring implicit timestepping would instead use an AbstractImExModel framework.\n\nThe benefit of this framework is that it can be used for both individual components of an LSM (soil, snow, rivers, canopy biophysics, carbon...) as well as the LSM itself. Here we explain how a simple two component model can be set up using this software interface.\n\nWe'll first demonstrate how to set up two components in standalone mode, before spending time explaining the LSM setup. In our example, we have a component which accounts for soil hydrology via the Richardson-Richards (RR) equation.  Our second component is a surface water model without lateral flow (standing water, as in a pond). For more details on these models, and how they were set up, please feel free to look at the source code here and here. This tutorial focuses on using the AbstractModels framework to set up the equations, rather than on running simulations.\n\nFirst, let's load the required modules:\n\nusing ClimaLand\nusing ClimaLand.Domains: Column, obtain_surface_domain\nusing ClimaLand.Soil\nusing ClimaLand.Pond\n\nFT = Float32;","category":"section"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/#The-individual-component-models-I-Soil-Hydrology","page":"Single column tutorial","title":"The individual component models I - Soil Hydrology","text":"The RR equation for the volumetric water content of soil is given by\n\nfracpartial ϑpartial t = -  (-K(ψ+z)) + S(xyz t)\n\nIn order to solve this, one must specify:\n\nboundary conditions,\nrelevant parameters (closure models for K and ψ),\na domain and a spatial discretization scheme,\nadditional source terms S, if applicable,\na time-stepping algorithm,\ninitial conditions.\n\nWe make the distinction between the spatially discretized equations (for which you need parameters, boundary conditions, source terms, and domain/ discretization scheme information in order to write down and evaluate), and the simulation you want to run (for which you need the equations, initial conditions, a time span, and a time-stepping scheme in order to specify completely).\n\nHere, we'll focus on what you need to write the equations. This information is stored in the model structure itself, so that we can call make_exp_tendency(model) and get back a function which computes the time derivative of the prognostic variables, which the ODE timestepper needs to advance the state forward in time.\n\nFor the RR equation, we can create this as follows. First, we specify parameters:\n\nν = FT(0.495);\nK_sat = FT(0.0443 / 3600 / 100); # m/s\nS_s = FT(1e-3); #inverse meters\nvg_n = FT(2.0);\nvg_α = FT(2.6); # inverse meters\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n);\nθ_r = FT(0);\nsoil_ps = Soil.RichardsParameters(;\n    ν = ν,\n    hydrology_cm = hcm,\n    K_sat = K_sat,\n    S_s = S_s,\n    θ_r = θ_r,\n);\n\nNext, let's define the spatial domain and discretization:\n\nzmax = FT(0);\nzmin = FT(-1);\nnelems = 20;\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\n\nAnd boundary conditions and source terms (none currently):\n\ntop_flux_bc = WaterFluxBC((p, t) -> 0.0);\nbot_flux_bc = WaterFluxBC((p, t) -> 0.0);\nsources = ()\nboundary_fluxes = (; top = top_flux_bc, bottom = bot_flux_bc)\n\n(top = ClimaLand.Soil.WaterFluxBC{Main.var\"##364\".var\"#1#2\"}(Main.var\"##364\".var\"#1#2\"()), bottom = ClimaLand.Soil.WaterFluxBC{Main.var\"##364\".var\"#3#4\"}(Main.var\"##364\".var\"#3#4\"()))\n\nWith this information, we can make our model:\n\nsoil = Soil.RichardsModel{FT}(;\n    parameters = soil_ps,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n);\n\nWe also can create the soil prognostic and auxiliary ClimaCore.Field.FieldVectors using the default method for initialize,\n\nY_soil, p_soil, coords_soil = initialize(soil);\n\nand we can set up the tendency function using the default as well,\n\nsoil_ode! = make_exp_tendency(soil);\n\nwhich computes, for the column domain,\n\n-frac z (-Kfrac(ψ+z) z)\n\nfor each value of ϑ on the mesh of our soil_domain.\n\nNote that the soil model does includes hydraulic K, pressure head ψ, and the boundary fluxes at the top and bottom of the domain in the auxiliary vector. These are updated first in each call to soil_ode!, as follows:\n\nfunction soil_ode!(dY, Y, p, t)\n         update_aux!(p,Y,t) # updates p.soil.K, p.soil.ψ in place\n         update_boundary_fluxes!(p,Y,t) # updates p.soil.top_bc, p.soil.bottom_bc in place\n         compute_exp_tendency!(dY, Y, p, t) # computes the divergence of the Darcy flux, updates dY in place.\nend\n\nIt is crucial the the cache p is correctly updated before the tendency is computed. The default method for make_exp_tendency creates the update_aux! and update_boundary_fluxes! functions, given the model, and evaluates them before computing the tendency, so we do not need to define that for the soil model.\n\nNote also that we have defined methods make_compute_exp_tendency, make_update_aux, and make_update_boundary_fluxes, which only take the model as argument, and which return the functions compute_exp_tendency!, update_aux!, and update_boundary_fluxes!. Please see the API documentation or source code for more information.\n\nLastly, the coordinates returned by initialize contain the z-coordinates of the centers of the finite difference layers used for spatial discretization of the PDE.","category":"section"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/#The-individual-component-models-II-Surface-Water","page":"Single column tutorial","title":"The individual component models II - Surface Water","text":"The pond model has a single variable, the pond height η, which satisfies the ODE:\n\nfrac η t = -(P - I) = R\n\nwhere P is the precipitation, I the infiltration into the soil, and R is the runoff. Note that P, I < 0 indicates flow in the -ẑ direction.\n\nTo write down the pond equations, we need to specify\n\nP\nI\n\nwhich are akin to boundary fluxes. In standalone mode,  one would need to pass in prescribed functions of time and store them inside our pond model, since again, the pond model structure must contain everything needed to make the tendency function:\n\nprecipitation(t) = t < 20 ? -1e-5 : 0.0 # m/s\n\ninfiltration(t) = -(1e-6) #m/s\npond_model =\n    Pond.PondModel{FT}(; runoff = PrescribedRunoff(precipitation, infiltration));\n\nHere, PrescribedRunoff is the structure holding the prescribed driving functions for P and I.\n\nAgain we can initialize the state vector and auxiliary vectors:\n\nY_pond, p_pond, coords_pond = initialize(pond_model);\n\nWe can make the tendency function in the same way, for stepping the state forward in time:\n\npond_ode! = make_exp_tendency(pond_model);\n\nThe pond_ode! function works in the same way as for the soil model:\n\nfunction pond_ode!(dY, Y, p, t)\n         update_aux!(p,Y,t) # falls back to default; does nothing\n         update_boundary_fluxes!(p,Y,t)  # p.surface_water.runoff in place\n         compute_exp_tendency!(dY, Y, p, t)\nend","category":"section"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/#An-LSM-with-pond-and-soil:","page":"Single column tutorial","title":"An LSM with pond and soil:","text":"The LSM model must contain everything needed to write down the joint system of equations\n\nfracpartial etapartial t = -(P(t) - I(ϑ η P)) = R\n\nfracpartial ϑpartial t = -  (-K(ψ+z)) + S\n\n-K (ψ+z)_z = zmax   z = I(ϑ η P)\n\n-K (ψ+z)_z = zmin   z = 00\n\nThese two components interact via the infiltration term I. Infiltration is a boundary condition for the soil, and affects the source term for the surface water equation. Infiltration depends on precipitation, the soil moisture state, and the pond height.\n\nAs in the standalone cases, defining our model requires specifying\n\nparameters,\ndomains, discretizations\nprecipitation,\nboundary conditions,\nsources in the soil equation, if any.\n\nFirst, let's make our single column domain.\n\nlsm_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\n\nLet's now collect the needed arguments for the soil model. The pond model only has one argument, the runoff model, but that will be set internally. Similarily, the boundary conditions of the soil model will be set internally to be consisent with the equations of the pond-soil model - see below for detail.\n\nsoil_args = (parameters = soil_ps, domain = lsm_domain, sources = ());\nsurface_water_args = NamedTuple();\n\nAtmospheric drivers don't \"belong\" to either component alone:\n\nland_args = (precip = precipitation,);\nland = LandHydrology{FT}(;\n    land_args = land_args,\n    soil_model_type = Soil.RichardsModel{FT},\n    soil_args = soil_args,\n    surface_water_model_type = Pond.PondModel{FT},\n    surface_water_args = surface_water_args,\n);\n\nHere, LandHydrology is a type of AbstractModel which has a surface water model (Pond or otherwise) and a soil model (RR, or perhaps otherwise).\n\nNow, note that we did not specify the infiltration function, like we did in standalone pond mode, nor did we specify boundary conditions for the soil model, nor did we specify the pond model domain. Yet, before we stressed that the model needs to have everything required to write down and evaluate the time derivative of the ODEs. So, how does this work?\n\nHere, the LSM model constructor is given the information needed to make both the soil model and the pond model. Then, it is like running the pond and soil model in standalone mode, in series, except we have defined methods internally for computing the boundary condition and pond source term correctly, based on I, instead of using prescribed values passed in. The LSM constructor creates the correct boundary_fluxes object for the soil model, and the correct infiltration object for the pond model under the hood.\n\nTo advance the state of the joint system (ϑ, η) from time t to time t+Δt, we must compute the infiltration at t. This value is stored in p.soil_infiltration.  In pseudo code, we have:\n\nfunction make_update_aux(land)\n         soil_update_aux! = make_update_aux(land.soil)\n         surface_update_aux! = make_update_aux(land.surface_water)\n         function update_aux!(p,Y,t)\n                  surface_update_aux!(p,Y,t) # does nothing to `p`\n                  soil_update_aux!(p,Y,t) # updates p.soil.K and p.soil.ψ\n         end\n         return update_aux!\nend\n\nfunction make_update_boundary_fluxes(land)\n         update_soil_bf! = make_update_boundary_fluxes(land.soil)\n         update_pond_bf! = make_update_boundary_fluxes(land.surface_water)\n         function update_boundary_fluxes!(p,Y,t)\n                  p.soil_infiltration = compute_infiltration(Y,p, t)\n                  update_soil_bf!(p,Y,t) # updates p.soil.top_bc using p.soil_infiltration\n                  update_pond_bf!(p,Y,t) # updates p.surface_water.runoff using p.soil_infiltration\n         end\n         return update_boundary_fluxes!\nend\n\nand similarily for the compute_exp_tendency! functions:\n\nfunction make_compute_exp_tendency(land)\n         soil_compute_exp_tendency! = make_update_aux(land.soil)\n         surface_compute_exp_tendency! = make_update_aux(land.surface_water)\n         function compute_exp_tendency!(dY,Y,p,t)\n                  surface_compute_exp_tendency!(dY,Y,p, t), # computes dY.surface.η\n                  soil_compute_exp_tendency!(dY,Y,p,t) # computes dY.soil.ϑ\n         end\n         return compute_exp_tendency!\nend\n\nThe exp_tendency! for the land model is then again just\n\nfunction exp_tendency!(dY, Y, p, t)\n         update_aux!(p,Y,t)\n         update_boundary_fluxes!(p,Y,t)\n         compute_exp_tendency!(dY, Y, p, t)\nend\n\nIn the above, we showed explicitly what occurs by hardcoding the compute_exp_tendency!, update_aux! with names for soil and surface_water. In reality, this is done by looping over the components of the land model, meaning that we can use the same code internally for land models with different components.\n\nA similar composition occurs for initializing the state itself: Calling initialize(land) does four things:\n\ninitialize(land.soil)\ninitialize(land.surface_water)\ninitializes additional auxiliary variables, like p.soil_infiltration\nappend these into Y, p, and coords:\n\nY, p, coords = initialize(land);\n\nWe have volumetric liquid water fraction:\n\npropertynames(Y.soil)\n\n(:ϑ_l, :∫F_vol_liq_water_dt)\n\nand surface height of the pond:\n\npropertynames(Y.surface_water)\n\n(:η,)\n\nas well as auxiliary variables for the soil:\n\npropertynames(p.soil)\n\n(:total_water, :K, :ψ, :bidiag_matrix_scratch, :full_bidiag_matrix_scratch, :top_bc, :top_bc_wvec, :bottom_bc, :bottom_bc_wvec)\n\nand the runoff for surface water:\n\npropertynames(p.surface_water)\n\n(:runoff,)\n\nand the additional variable required in the LSM is stored here as well:\n\npropertynames(p)\n\n(:soil_infiltration, :soil, :surface_water)\n\nand finally, coordinates - useful for visualization of solutions:\n\ncoords.subsurface\n\nClimaCore.Geometry.ZPoint{Float32}-valued Field:\n  z: Float32[-0.975, -0.925, -0.875, -0.825, -0.775, -0.725, -0.675, -0.625, -0.575, -0.525, -0.475, -0.425, -0.375, -0.325, -0.275, -0.225, -0.175, -0.125, -0.075, -0.025]\n\nand the coordinates of the surface variables:\n\ncoords.surface\n\nClimaCore.Geometry.ZPoint{Float32}-valued Field:\n  z: Float32[0.0]\n\nAnd we can make the tendency function as before:\n\nland_ode! = make_exp_tendency(land);\n\nNext up would be to set initial conditions, choose a timestepping scheme, and run your simulation.","category":"section"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/#Advantages-and-disadvantages","page":"Single column tutorial","title":"Advantages and disadvantages","text":"Some advantages to our interface design are as follows:\n\na developer only needs to learn a few concepts (compute_exp_tendency!, prognostic vs. aux variables, update_aux!/update_boundary_fluxes!, initialize, domains) to make a model which can be run in standalone or work with other components.\nlikewise, a user only needs to learn one interface to run all models, regardless of if they are standalone components or LSMs with multiple components.\nthe exp_tendency!is completely seperate from the timestepping scheme used, so any scheme can be used (with the exception of mixed implicit/explicit schemes, which we can't handle yet).\nalthough we wrote it here in a hardwired fashion for surface water and soil, the update_aux!, compute_exp_tendency! methods for LSM models generalize to any number and mix of components. One just needs to write a new model type (e.g. BiophysicsModel <: AbstractModel for a vegetation and carbon component model) and the appropriate make_update_boundary_var methods for that model.\nthe order in which the components are treated in the tendency or in update aux does not matter. What matters is that (1) auxiliary/cache variables are updated prior to calling update_boundary_fluxes!, and that (2) update_boundary_fluxes! is called prior to evaluating the tendency.\nthe code is also modular in terms of swapping out a simple component model for a more complex version.\n\nPossible disadvantages to our interface design:\n\nEven in standalone model, variables are accessed in a nested way: Y.soil, p.soil, etc, which is excessive.\nTo accomodate the fact that some components involve PDEs, a developer for purely ODE based component does need to at least handle ClimaCore.Field.FieldVectors.\nstandalone models need to play by the rules of AbstractModels, and LSMs need to play by the rules of ClimaLand.jl.\nwe need to define multiple update cache functions in order to handle dependencies between cache variables of one component model and boundary fluxes of another.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/soil/Soil/#Soil-Models","page":"Soil Energy and Hydrology","title":"Soil Models","text":"","category":"section"},{"location":"APIs/soil/Soil/#Soil-Models-2","page":"Soil Energy and Hydrology","title":"Soil Models","text":"","category":"section"},{"location":"APIs/soil/Soil/#Soil-Parameter-Structs","page":"Soil Energy and Hydrology","title":"Soil Parameter Structs","text":"","category":"section"},{"location":"APIs/soil/Soil/#Soil-Hydrology-Parameterizations","page":"Soil Energy and Hydrology","title":"Soil Hydrology Parameterizations","text":"","category":"section"},{"location":"APIs/soil/Soil/#Soil-Heat-Parameterizations","page":"Soil Energy and Hydrology","title":"Soil Heat Parameterizations","text":"","category":"section"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.AbstractSoilModel","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.AbstractSoilModel","text":"AbstractSoilModel{FT} <: ClimaLand.AbstractImExModel{FT}\n\nThe abstract type for all soil models.\n\nCurrently, we only have plans to support a RichardsModel, simulating the flow of liquid water through soil via the Richardson-Richards equation, and a fully integrated soil heat and water model, with phase change.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.RichardsModel","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.RichardsModel","text":"RichardsModel\n\nA model for simulating the flow of water in a porous medium by solving the Richardson-Richards Equation.\n\nA variety of boundary condition types are supported, including FluxBC, RichardsAtmosDrivenFluxBC, MoistureStateBC, and FreeDrainage (only for the bottom of the domain).\n\nIf you wish to simulate soil hydrology under the context of a prescribed precipitation volume flux (m/s) as a function of time, the RichardsAtmosDrivenFluxBC type should be chosen. Please see the documentation for more details.\n\nparameters: the parameter set\ndomain: the soil domain, using ClimaCore.Domains\nboundary_conditions: the boundary conditions, of type AbstractSoilBoundaryConditions\nsources: A tuple of sources, each of type AbstractSoilSource\nlateral_flow: A boolean flag which, when false, turns off the horizontal flow of water\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.RichardsModel-Union{Tuple{}, Tuple{D}, Tuple{FT}} where {FT, D}","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.RichardsModel","text":"RichardsModel{FT}(;\n    parameters::RichardsParameters,\n    domain::D,\n    boundary_conditions::NamedTuple,\n    sources::Tuple,\n    lateral_flow::Bool = true\n) where {FT, D}\n\nA constructor for a RichardsModel, which sets the default value of lateral_flow to be true.\n\n\n\n\n\n","category":"method"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.RichardsModel-Union{Tuple{FT}, Tuple{Any, Any}} where FT","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.RichardsModel","text":"RichardsModel{FT}(domain, forcing;\n                     runoff =  ClimaLand.Soil.Runoff.TOPMODELRunoff{FT}(f_over = FT(3.28),\n                                                                        R_sb = FT(1.484e-4 / 1000),\n                                                                        f_max = topmodel_fmax(domain.space.surface,FT),\n                                                                        ),\n                     retention_parameters = soil_vangenuchten_parameters(domain.space.subsurface, FT),\n                     S_s = ClimaCore.Fields.zeros(domain.space.subsurface) .+ 1e-3,\n                     )\n\nCreates a RichardsModel model with the given float type FT, domain and forcing. Here, forcing should be a NamedTuple containing a field atmos with the atmospheric forcing.\n\nDefault spatially varying parameters (for retention curve parameters and specific storativity) are provided but can be changed with keyword arguments.\n\nThe runoff parameterization is also provided and can be changed via keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.EnergyHydrology","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.EnergyHydrology","text":"EnergyHydrology <: AbstractSoilModel\n\nA model for simulating the flow of water and heat in a porous medium by solving the Richardson-Richards equation and the heat equation, including terms for phase change.\n\nA variety of boundary condition types are supported, including FluxBC, MoistureStateBC/TemperatureStateBC, FreeDrainage (only for the bottom of the domain), and an AtmosDrivenFluxBC (under which radiative fluxes and turbulent surface fluxes are computed and used as boundary conditions). Please see the documentation for this boundary condition type for more details.\n\nparameters: The parameter sets\ndomain: the soil domain, using ClimaCore.Domains\nboundary_conditions: the boundary conditions for RRE and heat, of type AbstractSoilBoundaryConditions\nsources: A tuple of sources, each of type AbstractSoilSource\nlateral_flow: A boolean flag which, when false, turns off the horizontal flow of water and heat\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.EnergyHydrology-Union{Tuple{}, Tuple{PSE}, Tuple{D}, Tuple{FT}} where {FT, D, PSE}","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.EnergyHydrology","text":"EnergyHydrology{FT}(;\n    parameters::PS\n    domain::D,\n    boundary_conditions::NamedTuple,\n    sources::Tuple,\n    lateral_flow::Bool = false,\n) where {FT, D, PS}\n\nA constructor for a EnergyHydrology model, which sets the default value of the lateral_flow flag to false.\n\n\n\n\n\n","category":"method"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.EnergyHydrology-Union{Tuple{FT}, Tuple{Any, Any, ClimaParams.ParamDict}} where FT<:AbstractFloat","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.EnergyHydrology","text":"EnergyHydrology{FT}(domain, forcing, toml_dict::CP.ParamDict;\n                     prognostic_land_components = (:soil),\n                     albedo = CLMTwoBandSoilAlbedo{FT}(; clm_soil_albedo_parameters(domain.space.surface)...),\n                     runoff::Runoff.AbstractRunoffModel = Runoff.TOPMODELRunoff(toml_dict,\n                                                            f_max = topmodel_fmax(domain.space.surface, FT),\n                                                        ),\n                     retention_parameters = soil_vangenuchten_parameters(domain.space.subsurface, FT),\n                     composition_parameters = soil_composition_parameters(domain.space.subsurface, FT),\n                     S_s = ClimaCore.Fields.zeros(domain.space.subsurface) .+ 1e-3,\n                     z_0m = toml_dict[\"soil_momentum_roughness_length\"],\n                     z_0b = toml_dict[\"soil_scalar_roughness_length\"],\n                     emissivity = toml_dict[\"emissivity_bare_soil\"],\n                     additional_sources = (),\n                     bottom_bc =\n                         WaterHeatBC(; water = WaterFluxBC((p, t) -> 0.0), heat = HeatFluxBC((p, t) -> 0.0)),\n                     ) where {FT <: AbstractFloat}\n\nCreates a EnergyHydrology model with the given float type FT, domain, toml_dict, forcing, and prognostic land components.\n\nThe argument forcing should be a NamedTuple containing two fields: atmos and radiation.\n\nWhen running the soil model in standalone mode, prognostic_land_components = (:soil,), while for running integrated land models, this should be a list of the component models. This value of this argument must be the same across all components in the land model.\n\nDefault spatially varying parameters (for retention curve parameters, composition, and specific storativity) are provided but can be changed with keyword arguments. Note that these parameters must all be of the same type: either FT or ClimaCore Fields. By default they are Fields read in from data, so in practice this means if some values are provided as Floats, all of these parameter defaults must be overwritten as Floats.\n\nretention_parameters should be a NamedTuple with the following fields:\n\nν: soil porosity\nhydrology_cm: the hydrology closure model being used\nK_sat: saturated hydraulic conductivity\nθ_r: residual water content\n\ncomposition_parameters should be a NamedTuple with the following fields:\n\nν_ss_om: soil organic matter volume fraction\nν_ss_quartz: soil quartz volume fraction\nν_ss_gravel: soil gravel volume fraction\n\nThe runoff and albedo parameterizations are also provided and can be changed via keyword argument; additional sources may be required in your model if the soil model will be composed with other component models.\n\nRoughness lengths and soil emissivity are currently treated as constants; these can be passed in as Floats by kwarg; otherwise the default values are used.\n\nThis sets the bottom boundary conditions to be no flux by default, but these can be changed using the  bottom_bc kwarg.\n\n\n\n\n\n","category":"method"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.RichardsParameters","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.RichardsParameters","text":"RichardsParameters{F <: Union{<: AbstractFloat, ClimaCore.Fields.Field}, C <: AbstractSoilHydrologyClosure}\n\nA struct for storing parameters of the RichardsModel.\n\nν: The porosity of the soil (m^3/m^3)\nhydrology_cm: The hydrology closure model: vanGenuchten or BrooksCorey\nK_sat: The saturated hydraulic conductivity (m/s)\nS_s: The specific storativity (1/m)\nθ_r: The residual water fraction (m^3/m^3)\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.RichardsParameters-Tuple{}","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.RichardsParameters","text":"RichardsParameters(;\n    hydrology_cm::C,\n    ν::F,\n    K_sat::F,\n    S_s::F,\n    θ_r::F,\n) where {F <: Union{<:AbstractFloat, ClimaCore.Fields.Field}, C}\n\nConstruct a RichardsParameters.\n\n\n\n\n\n","category":"method"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.EnergyHydrologyParameters","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.EnergyHydrologyParameters","text":"EnergyHydrologyParameters{\n        FT <: AbstractFloat,\n        F <: Union{<:AbstractFloat, ClimaCore.Fields.Field},\n        AP,\n        C,\n        PSE,\n    }\n\nA parameter structure for the integrated soil water and energy  equation system.\n\nsoil composition and retention model parameters defined in the interior\nan albedo parameterization\nScalar parameters: emissivity, α, β, γ, γT_ref, Ω,\n\nroughness lengths z0, dds ) (FT)\n\nκ_dry: The dry soil thermal conductivity, W/m/K\nκ_sat_frozen: The saturated thermal conductivity of frozen soil, W/m/K\nκ_sat_unfrozen: The saturated thermal conductivity of unfrozen soil, W/m/K\nρc_ds: The volumetric heat capacity of dry soil, J/m^3/K (per volume dry soil, not per volume soil solids)\nν: The porosity of the soil (m^3/m^3)\nν_ss_om: The volumetric fraction of the soil solids in organic matter (m^3/m^3)\nν_ss_quartz: The volumetric fraction of the soil solids in quartz (m^3/m^3)\nν_ss_gravel: The volumetric fraction of the soil solids in gravel (m^3/m^3)\nα: The parameter α used in computing Kersten number, unitless\nβ: The parameter β used in computing Kersten number, unitless\nhydrology_cm: The soil hydrology closure model: van Genuchten or Brooks and Corey\nK_sat: The saturated hydraulic conductivity (m/s)\nS_s: The specific storativity (1/m)\nθ_r: The residual water fraction (m^3/m^3)\nΩ: Ice impedance factor for the hydraulic conductivity\nγ: Coefficient of viscosity factor for the hydraulic conductivity\nγT_ref: Reference temperature for the viscosity factor\nalbedo: Soil Albedo Parameterization\nemissivity: Soil Emissivity\nz_0m: Roughness length for momentum\nz_0b: Roughness length for scalars\nd_ds: Maximum dry soil layer thickness under evaporation (m)\nearth_param_set: Physical constants and clima-wide parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.EnergyHydrologyParameters-Union{Tuple{Type{FT}}, Tuple{FT}} where FT<:AbstractFloat","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.EnergyHydrologyParameters","text":"EnergyHydrologyParameters(\n    toml_dict;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm,\n    K_sat,\n    S_s,\n    θ_r,\n    albedo = Soil.ConstantTwoBandSoilAlbedo{FT}(),\n    kwargs...,)\n\nEnergyHydrologyParameters has two constructors: float-type and toml dict based. Additional parameters must be added manually: ν, ν_ss_om, ν_ss_quartz, ν_ss_gravel, hydrology_cm,Ksat,Ss, andθ_r. All parameters can be manually overridden via keyword arguments. Note, however, that certain parameters must have the same type (e.g, if a field is supplied for porosity, it must be supplied for all other parameters defined in the interior of the domain). Some parameters are defined only on the surface of the domain (e.g albedo), while other are defined everywhere (e.g. porosity). These are indicated with typesFandSF`. If both dry/wet albedos and general albedos are given as keywords, the dry/wet albedos will override the general albedos.\n\nPlease see the EnergyHydrologyParameters documentation for a complete list.\n\n\n\n\n\n","category":"method"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.volumetric_liquid_fraction","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.volumetric_liquid_fraction","text":"volumetric_liquid_fraction(ϑ_l::FT, ν_eff::FT, θ_r::FT) where {FT}\n\nA pointwise function returning the volumetric liquid fraction given the augmented liquid fraction and the effective porosity. The output is guaranteed to be in (θ_r, ν_eff].\n\nFor Richards model, ν_eff = ν; and the clipping below is not required, (and will do nothing; ν_eff_safe = ν_eff), but we leave it in for a simpler interface.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.pressure_head","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.pressure_head","text":"pressure_head(\n    cm::vanGenuchten{FT},\n    θ_r::FT,\n    ϑ_l::FT,\n    ν_eff::FT,\n    S_s::FT,\n) where {FT}\n\nA point-wise function returning the pressure head in variably saturated soil, using the van Genuchten matric potential if the soil is not saturated, and an approximation of the positive pressure in the soil if the soil is saturated.\n\n\n\n\n\npressure_head(\n    cm::BrooksCorey{FT},\n    θ_r::FT,\n    ϑ_l::FT,\n    ν_eff::FT,\n    S_s::FT,\n) where {FT}\n\nA point-wise function returning the pressure head in variably saturated soil, using the Brooks and Corey matric potential if the soil is not saturated, and an approximation of the positive pressure in the soil if the soil is saturated.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.hydraulic_conductivity","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.hydraulic_conductivity","text":"hydraulic_conductivity(cm::vanGenuchten{FT}, K_sat::FT, S::FT) where {FT}\n\nA point-wise function returning the hydraulic conductivity, using the van Genuchten formulation.\n\n\n\n\n\n hydraulic_conductivity(cm::BrooksCorey{FT}, K_sat::FT, S::FT) where {FT}\n\nA point-wise function returning the hydraulic conductivity, using the Brooks and Corey formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.impedance_factor","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.impedance_factor","text":"impedance_factor(\n    f_i::FT,\n    Ω::FT\n) where {FT}\n\nReturns the multiplicative factor reducing conductivity when a fraction of ice f_i is present.\n\nOnly for use with the EnergyHydrology model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.viscosity_factor","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.viscosity_factor","text":"viscosity_factor(\n    T::FT,\n    γ::FT,\n    γT_ref::FT,\n) where {FT}\n\nReturns the multiplicative factor which accounts for the temperature dependence of the conductivity.\n\nOnly for use with the EnergyHydrology model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.effective_saturation","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.effective_saturation","text":"effective_saturation(ν_eff::FT, ϑ_l::FT, θr::FT) where {FT}\n\nA point-wise function computing the effective saturation given the effective porosity, augmented liquid fraction, and residual water fraction as input.\n\nFor Richards model, or any other parameterization where ice is not relevant, νeff = ν; and the clipping below is not required, (and will do nothing; νeffsafe = νeff), but we leave it in for a  simpler interface.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.matric_potential","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.matric_potential","text":" matric_potential(cm::vanGenuchten{FT}, S::FT) where {FT}\n\nA point-wise function returning the matric potential, using the van Genuchten formulation.\n\n\n\n\n\n matric_potential(cm::BrooksCorey{FT}, S::FT) where {FT}\n\nA point-wise function returning the matric potential, using the Brooks and Corey formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.dψdϑ","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.dψdϑ","text":"dψdϑ(cm::vanGenuchten{FT}, ϑ, ν_eff, θ_r, S_s)\n\nComputes and returns the derivative of the pressure head with respect to ϑ for the van Genuchten formulation.\n\n\n\n\n\ndψdϑ(cm::BrooksCorey{FT}, ϑ, νeff, θr, S_s)\n\nComputes and returns the derivative of the pressure head with respect to ϑ for the Brooks and Corey formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.inverse_matric_potential","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.inverse_matric_potential","text":"inverse_matric_potential(cm::vanGenuchten{FT}, ψ::FT) where {FT}\n\nA point-wise function returning the effective saturation, given the matric potential, using the van Genuchten formulation.\n\n\n\n\n\ninverse_matric_potential(cm::BrooksCorey{FT}, ψ::FT) where {FT}\n\nA point-wise function returning the effective saturation, given the matric potential, using the Brooks and Corey formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.AbstractSoilHydrologyClosure","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.AbstractSoilHydrologyClosure","text":"AbstractSoilHydrologyClosure{FT <: AbstractFloat}\n\nThe abstract type of soil hydrology closure, of which vanGenuchten{FT} and BrooksCorey{FT} are the two supported concrete types.\n\nTo add a new parameterization, methods are required for:\n\nmatric_potential,\ninversematricpotential,\npressure_head,\ndψdϑ,\nhydraulic_conductivity.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.vanGenuchten","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.vanGenuchten","text":"vanGenuchten{FT} <: AbstractSoilHydrologyClosure{FT}\n\nThe van Genuchten soil hydrology closure, chosen when the hydraulic conductivity and matric potential are modeled using the van Genuchten parameterization (van Genuchten 1980; see also Table 8.2 of G. Bonan 2019).\n\nα: The inverse of the air entry potential (1/m)\nn: The van Genuchten pore-size distribution index (unitless)\nm: The van Genuchten parameter m = 1 - 1/n (unitless)\nS_c: A derived parameter: the critical saturation at which capillary flow no longer replenishes the surface\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.BrooksCorey","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.BrooksCorey","text":"BrooksCorey{FT} <: AbstractSoilHydrologyClosure{FT}\n\nThe Brooks and Corey soil hydrology closure, chosen when the hydraulic conductivity and matric potential are modeled using the Brooks and Corey parameterization (Brooks and Corey, 1964, 1966; see also Table 8.2 of G. Bonan 2019).\n\nc: The pore-size distribution index (unitless)\nψb: The air entry matric potential, when S=1 (m)\nS_c: A derived parameter: the critical saturation at which capillary flow no longer replenishes the surface\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.volumetric_heat_capacity","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.volumetric_heat_capacity","text":"volumetric_heat_capacity(\n    θ_l::FT,\n    θ_i::FT,\n    ρc_ds::FT,\n    earth_param_set::EP,\n) where {FT,EP}\n\nCompute the expression for volumetric heat capacity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.κ_solid","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_solid","text":"κ_solid(ν_ss_om::FT,\n        ν_ss_quartz::FT,\n        κ_om::FT,\n        κ_quartz::FT,\n        κ_minerals::FT) where {FT}\n\nComputes the thermal conductivity of the solid material in soil. The _ss_ subscript denotes that the volumetric fractions of the soil components are referred to the soil solid components, not including the pore space.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.κ_sat_frozen","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_sat_frozen","text":"function κ_sat_frozen(\n    κ_solid::FT,\n    ν::FT,\n    κ_ice::FT\n) where {FT}\n\nComputes the thermal conductivity for saturated frozen soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.κ_sat_unfrozen","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_sat_unfrozen","text":"function κ_sat_unfrozen(\n    κ_solid::FT,\n    ν::FT,\n    κ_l::FT\n) where {FT}\n\nComputes the thermal conductivity for saturated unfrozen soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.κ_sat","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_sat","text":"κ_sat(\n    θ_l::FT,\n    θ_i::FT,\n    κ_sat_unfrozen::FT,\n    κ_sat_frozen::FT\n) where {FT}\n\nCompute the expression for saturated thermal conductivity of soil matrix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.κ_dry","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_dry","text":"function κ_dry(ρp::FT,\n               ν::FT,\n               κ_solid::FT,\n               κ_air::FT;\n               a = FT(0.053)) where {FT}\n\nComputes the thermal conductivity of dry soil according to the model of Balland and Arp.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.kersten_number","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.kersten_number","text":"kersten_number(\n    θ_i::FT,\n    S_r::FT,\n    α::FT,\n    β::FT,\n    ν_ss_om::FT,\n    ν_ss_quartz::FT,\n    ν_ss_gravel::FT,\n    ) where {FT}\n\nCompute the expression for the Kersten number, using the Balland and Arp model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.relative_saturation","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.relative_saturation","text":"relative_saturation(\n        θ_l::FT,\n        θ_i::FT,\n        ν::FT\n) where {FT}\n\nCompute the expression for relative saturation. This is referred to as θ_sat in Balland and Arp's paper.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.volumetric_internal_energy","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.volumetric_internal_energy","text":"volumetric_internal_energy(θ_i::FT, ρc_s::FT, T::FT,\n                             earth_param_set::EP) where {FT, EP}\n\nA pointwise function for computing the volumetric internal energy of the soil, given the volumetric ice content, volumetric heat capacity, and temperature.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.volumetric_internal_energy_liq","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.volumetric_internal_energy_liq","text":"volumetric_internal_energy_liq(T::FT, earth_param_set::EP) where {FT, EP}\n\nA pointwise function for computing the volumetric internal energy of the liquid water in the soil, given the temperature T.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.temperature_from_ρe_int","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.temperature_from_ρe_int","text":"temperature_from_ρe_int(ρe_int::FT, θ_i::FT, ρc_s::FT\n                        earth_param_set::EP) where {FT, EP}\n\nA pointwise function for computing the temperature from the volumetric internal energy, volumetric ice content, and volumetric heat capacity of the soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.thermal_conductivity","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.thermal_conductivity","text":"thermal_conductivity(\n    κ_dry::FT,\n    K_e::FT,\n    κ_sat::FT\n) where {FT}\n\nCompute the expression for thermal conductivity of soil matrix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.phase_change_source","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.phase_change_source","text":"phase_change_source(\n    θ_l::FT,\n    θ_i::FT,\n    T::FT,\n    τ::FT,\n    ν::FT,\n    θ_r::FT,\n    hydrology_cm::CM,\n    _ρ_i::FT,\n    _ρ_l::FT,\n    _LH_f0::FT,\n    _T_freeze::FT,\n    _grav::FT\n    ) where {FT, CM}\n\nReturns the source term (1/s) used for converting liquid water and ice into each other during phase changes. Note that there are unitless prefactors multiplying this term in the equations.\n\nNote that these equations match what is in Dall'Amico (for θstar, ψ(T), ψw0). We should double check them in the case where we have ϑl > θl, but they should be very close to the form we want regardless.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/Soil/#ClimaLand.Soil.thermal_time","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.thermal_time","text":"thermal_time(ρc::FT, Δz::FT, κ::FT) where {FT}\n\nReturns the thermal timescale for temperature differences across a typical thickness Δz to equilibrate.\n\n\n\n\n\n","category":"function"},{"location":"standalone/pages/soil/physics/richards_model/#Richards-Equation","page":"Richards model","title":"Richards Equation","text":"Richards Equation is a single variable partial differential equation describing how water is distributed and flows in soil. In three-dimensional space, we have\n\nfracpartial vartheta_lpartial t = - nabla cdot -K nabla h\n\nwhere ϑ_l is the augmented volumetric liquid fraction, t is the time, K is the hydraulic conductivity, computed from ϑ_l given a retention curve and a permeability curve, ψ is the pressure head, which is computed from ϑ_l given a retention curve function, and h = ψ + z is the hydraulic head.\n\nIn order to solve this equation, the functions ψ(ϑ_l) and K(ϑ_l) must be specified. This in turn requires defining the saturated conductivity K_rmsat, the porosity ν, the residual water content θ_r, and the parameters mapping saturation ϑ_l to K and ψ.\n\nClimaLand supports both the van Genuchten and Brooks and Corey retenton curve/permeability curve pairs, which we refer to in places as the hydrology closure model.\n\nSince this partial differential equation is stiff, an implicit timestepping scheme must be used to advance it in time.","category":"section"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/#Evaporation-from-Gilat-Loess-soil","page":"Gilat Loess Evaporation","title":"Evaporation from Gilat Loess soil","text":"This sets up the simulation that mimicks the lab experiment presented in Gardner [15] and modeled also by Lehmann and Or [16].\n\nFor further details on how to setup a simulation, please see our other Soil tutorials. This one is very terse and does not provide complete explanations\n\nThe same experiment is carried out 3 times\n\nNo evaporation (zero flux boundary conditions)\nWith evaporation but no drainage (Ksat = 0)\nWith evaporation and drainage\n\nusing CairoMakie\nimport SciMLBase\nimport ClimaTimeSteppers as CTS\nusing Thermodynamics\n\nusing ClimaCore\nimport ClimaParams as CP\nusing SurfaceFluxes\nusing StaticArrays\nusing Dates\nusing DelimitedFiles: readdlm\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\nimport ClimaLand\nimport ClimaLand.Parameters as LP\nimport ClimaLand.Simulations: LandSimulation, solve!\nimport SurfaceFluxes.Parameters as SFP\n\nFT = Float64;\ntoml_dict = LP.create_toml_dict(FT)\nearth_param_set = LP.LandParameters(toml_dict)\nthermo_params = LP.thermodynamic_parameters(earth_param_set);\n\nParameters\n\nK_sat = FT(0.01 / 3600 / 24)\nvg_n = FT(1.55)\nvg_α = FT(1.5)\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n)\nν = FT(0.4)\nθ_r = FT(0.04)\nS_s = FT(1e-3)\nν_ss_om = FT(0.0)\nν_ss_quartz = FT(0.3)\nν_ss_gravel = FT(0.0)\nemissivity = FT(1.0)\nz_0m = FT(1e-3)\nz_0b = FT(1e-4)\nd_ds = FT(0.01)# 10mm\nparams = ClimaLand.Soil.EnergyHydrologyParameters(\n    toml_dict;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm = hcm,\n    K_sat,\n    S_s,\n    θ_r,\n    emissivity,\n    z_0m,\n    z_0b,\n    d_ds,\n);\n\nstart_date = DateTime(2005)\nstop_date = start_date + Day(15)\ndt = Float64(900.0)\nSW_d = (t) -> 0\nLW_d = (t) -> 294.15^4 * 5.67e-8\nradiation = PrescribedRadiativeFluxes(\n    FT,\n    TimeVaryingInput(SW_d),\n    TimeVaryingInput(LW_d),\n    start_date,\n)\n\nPrescribedRadiativeFluxes{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#1#2\"}, Nothing, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#3#4\"}, Dates.DateTime, Nothing, Nothing}(ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#1#2\"}(Main.var\"##270\".var\"#1#2\"()), nothing, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#3#4\"}(Main.var\"##270\".var\"#3#4\"()), Dates.DateTime(\"2005-01-01T00:00:00\"), nothing, nothing)\n\nAtmos\n\nT_air = FT(301.15)\nrh = FT(0.38)\nesat = Thermodynamics.saturation_vapor_pressure(\n    thermo_params,\n    T_air,\n    Thermodynamics.Liquid(),\n)\ne = rh * esat\nq = FT(0.622 * e / (101325 - 0.378 * e))\nprecip = (t) -> 0.0\nT_atmos = (t) -> T_air\nu_atmos = (t) -> 1.0\nq_atmos = (t) -> q\nh_atmos = FT(0.1)\nP_atmos = (t) -> 101325\ngustiness = FT(1e-2)\natmos = PrescribedAtmosphere(\n    TimeVaryingInput(precip),\n    TimeVaryingInput(precip),\n    TimeVaryingInput(T_atmos),\n    TimeVaryingInput(u_atmos),\n    TimeVaryingInput(q_atmos),\n    TimeVaryingInput(P_atmos),\n    start_date,\n    h_atmos,\n    toml_dict;\n    gustiness = gustiness,\n)\n\nPrescribedAtmosphere{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#7#8\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#9#10\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#11#12\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#13#14\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{ClimaLand.var\"#69#72\"}, Dates.DateTime, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}}(ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#5#6\"}(Main.var\"##270\".var\"#5#6\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#5#6\"}(Main.var\"##270\".var\"#5#6\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#7#8\"}(Main.var\"##270\".var\"#7#8\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#9#10\"}(Main.var\"##270\".var\"#9#10\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#11#12\"}(Main.var\"##270\".var\"#11#12\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##270\".var\"#13#14\"}(Main.var\"##270\".var\"#13#14\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{ClimaLand.var\"#69#72\"}(ClimaLand.var\"#69#72\"()), Dates.DateTime(\"2005-01-01T00:00:00\"), 0.1, 0.01, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}(273.16, 101325.0, 100000.0, 287.0, 461.5, 1004.5, 1859.0, 4181.0, 2070.0, 2.5008e6, 2.8344e6, 611.657, 273.16, 273.15, 1.0, 1000.0, 150.0, 298.15, 6864.8, 10513.6, 8.3144598, 0.02897, 0.01801528, 290.0, 220.0, 9.81, 233.0, 1.0))\n\nSimulation setup - no evaporation Boundary conditions\n\nzero_water_flux = WaterFluxBC((p, t) -> 0)\nzero_heat_flux = HeatFluxBC((p, t) -> 0)\nno_flux_boundary_fluxes = (;\n    top = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n    bottom = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n);\n\nΔz = 0.01\nzmax = FT(0)\nzmin = FT(-1.6)\nnelems = Int((zmax - zmin) / Δz)\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems)\nz = ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z\n\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = no_flux_boundary_fluxes,\n    sources = (),\n);\n\nInitial conditions\n\nfunction estimated_ic(z)\n    0.34 / (1 + exp(-(z + 0.165) / 0.005)) + 0.05\nend\nfunction set_ic!(Y, p, t0, model)\n    params = model.parameters\n    z = model.domain.fields.z\n    FT = eltype(Y.soil.ϑ_l)\n    Y.soil.ϑ_l .= estimated_ic.(z)\n    Y.soil.θ_i .= 0\n    T = FT(294.15)\n    ρc_s = @. Soil.volumetric_heat_capacity(\n        Y.soil.ϑ_l,\n        Y.soil.θ_i,\n        params.ρc_ds,\n        params.earth_param_set,\n    )\n    Y.soil.ρe_int =\n        Soil.volumetric_internal_energy.(\n            Y.soil.θ_i,\n            ρc_s,\n            T,\n            params.earth_param_set,\n        )\nend\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\n\nSaving callback\n\nsaveat = Hour(1)\nsaving_cb = ClimaLand.NonInterpSavingCallback(start_date, stop_date, saveat)\nsv = saving_cb.affect!.saved_values\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    updateat = nothing, # disables driver updates\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    user_callbacks = (saving_cb,),\n    diagnostics = (),\n);\nsol_no_evap = solve!(simulation);\n\nRepeat with evaporation and drainage This requires different initial conditions\n\ntop_bc = ClimaLand.Soil.AtmosDrivenFluxBC(atmos, radiation)\nevap_boundary_fluxes = (;\n    top = top_bc,\n    bottom = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n)\n\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = evap_boundary_fluxes,\n    sources = (),\n)\n\ntimestepper = CTS.ARS111();\nsaveat = Hour(1)\nsaving_cb = ClimaLand.NonInterpSavingCallback(start_date, stop_date, saveat)\nsv = saving_cb.affect!.saved_values\n\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    updateat = Hour(1),\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    user_callbacks = (saving_cb,),\n    diagnostics = (),\n);\nsol = solve!(simulation);\nevap = [\n    parent(sv.saveval[k].soil.turbulent_fluxes.vapor_flux_liq)[1] for\n    k in 1:length(sol.t)\n];\n\n# Repeat with no drainage (Ksat = 0, different BC), and with evaporation, in shorter domain\n\n[ Info: Warning: No runoff model was provided; zero runoff generated.\n\n\nThis requires different boundary conditions yet again: Wet boundary at bottom, zero heat flux at bottom, the previously defined atmos driven evaporation at the top.\n\nbottom_water_bc = MoistureStateBC((p, t) -> 0.35)\nno_drainage_boundary_fluxes = (;\n    top = top_bc,\n    bottom = WaterHeatBC(; water = bottom_water_bc, heat = zero_heat_flux),\n)\nzmax = FT(0)\nzmin = FT(-0.16)\nnelems = Int((zmax - zmin) / Δz)\ndt = Float64(10.0)\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems)\nz_no_evap = ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = no_drainage_boundary_fluxes,\n    sources = (),\n)\nsaveat = Hour(1)\nsaving_cb = ClimaLand.NonInterpSavingCallback(start_date, stop_date, saveat);\nsv = saving_cb.affect!.saved_values;\nsimulation = LandSimulation(\n    start_date,\n    stop_date,\n    dt,\n    soil;\n    set_ic! = set_ic!,\n    updateat = Hour(1),\n    solver_kwargs = (; saveat),\n    timestepper = ode_algo,\n    user_callbacks = (saving_cb,),\n    diagnostics = (),\n);\nsol_no_drainage = solve!(simulation);\nevap_no_drainage = [\n    parent(sv.saveval[k].soil.turbulent_fluxes.vapor_flux_liq)[1] for\n    k in 1:length(sol.t)\n];\n\nFigures\n\nfig = Figure(size = (800, 400))\nax = Axis(fig[1, 1], xlabel = \"Day\", ylabel = \"Evaporation rate (mm/d)\")\nCairoMakie.lines!(\n    ax,\n    FT.(sol.t) ./ 3600 ./ 24,\n    evap .* (1000 * 3600 * 24),\n    label = \"With drainage\",\n    color = :red,\n)\nCairoMakie.lines!(\n    ax,\n    FT.(sol_no_drainage.t) ./ 3600 ./ 24,\n    evap_no_drainage .* (1000 * 3600 * 24),\n    label = \"No drainage\",\n    color = :blue,\n)\n\nCairoMakie.axislegend(ax)\nax2 = Axis(fig[1, 2], xlabel = \"Day\", ylabel = \"Cumulative evaporation (mm)\")\nCairoMakie.lines!(\n    ax2,\n    FT.(sol.t) ./ 3600 ./ 24,\n    cumsum(evap) .* (1000 * 3600),\n    color = :red,\n)\nCairoMakie.lines!(\n    ax2,\n    FT.(sol_no_drainage.t) ./ 3600 ./ 24,\n    cumsum(evap_no_drainage) .* (1000 * 3600),\n    color = :blue,\n)\nsave(\"evaporation_lehmann2024_figS6.png\", fig);\n\n(Image: )\n\nfig2 = Figure(size = (800, 1200))\nax1 = Axis(fig2[1, 1], title = \"Drainage only\")\nCairoMakie.ylims!(-0.35, 0)\nCairoMakie.xlims!(0.0, 0.4)\nlinestyles = [:solid, :dash, :dashdot, :dashdotdot, :dot]\ndays = [0, 1, 2, 10]\nfor i in 1:1:4\n    CairoMakie.lines!(\n        ax1,\n        parent(sol_no_evap.u[days[i] * 24 + 1].soil.ϑ_l)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\nax2 = Axis(fig2[2, 1], title = \"Evap+Drainage\", ylabel = \"Depth(cm)\")\n\nCairoMakie.ylims!(-0.3, 0)\nCairoMakie.xlims!(0.0, 0.4)\ndays = [0, 1, 2, 5, 13]\nfor i in 1:1:5\n    CairoMakie.lines!(\n        ax2,\n        parent(sol.u[days[i] * 24 + 1].soil.ϑ_l)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\nax3 = Axis(fig2[3, 1], title = \"Evap only\", xlabel = \"Volumetric Water Content\")\nCairoMakie.ylims!(-0.15, 0)\nCairoMakie.xlims!(0.0, 0.4)\ndays = [0, 2, 9, 14]\nfor i in 1:1:4\n    CairoMakie.lines!(\n        ax3,\n        parent(sol_no_drainage.u[days[i] * 24 + 1].soil.ϑ_l)[:],\n        label = \"$(days[i]) days\",\n        parent(z_no_evap)[:],\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\n\nCairoMakie.axislegend(ax3, position = :lt)\nCairoMakie.axislegend(ax2, position = :lt)\nCairoMakie.axislegend(ax1, position = :lt)\nsave(\"evaporation_gardner_fig1.png\", fig2);\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/Snow/","page":"Snow Model","title":"Snow Model","text":"Snow Model","category":"section"},{"location":"APIs/Snow/#Snow-Model-and-Parameters","page":"Snow Model","title":"Snow Model and Parameters","text":"","category":"section"},{"location":"APIs/Snow/#Snow-Functions-of-State","page":"Snow Model","title":"Snow Functions of State","text":"","category":"section"},{"location":"APIs/Snow/#Computing-fluxes-for-snow","page":"Snow Model","title":"Computing fluxes for snow","text":"","category":"section"},{"location":"APIs/Snow/#Snow-parameterizations","page":"Snow Model","title":"Snow parameterizations","text":"","category":"section"},{"location":"APIs/Snow/#ClimaLand.Snow.SnowModel","page":"Snow Model","title":"ClimaLand.Snow.SnowModel","text":"struct SnowModel{\n    FT,\n    PS <: SnowParameters{FT},\n    BC,\n    D,\n} <: AbstractSnowModel{FT}\n\nA container/type for the bulk snow model, based on the UEB snow model of Tarboton et al. (1995) and Tarboton and Luce (1996).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Snow/#ClimaLand.Snow.SnowModel-Tuple{}","page":"Snow Model","title":"ClimaLand.Snow.SnowModel","text":"SnowModel(;\n    parameters::SnowParameters{FT, DM, PSE},\n    domain::ClimaLand.Domains.AbstractDomain,\n    boundary_conditions::BC\n) where {FT, DM, PSE, BC}\n\nConstruct a SnowModel with parameters, domain, and boundary_conditions.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Snow/#ClimaLand.Snow.SnowModel-Tuple{Any, Any, Any, ClimaParams.ParamDict, Any}","page":"Snow Model","title":"ClimaLand.Snow.SnowModel","text":"SnowModel(\n    FT,\n    domain,\n    forcing,\n    toml_dict::CP.ParamDict,\n    Δt;\n    prognostic_land_components = (:snow,),\n    z_0m = toml_dict[\"snow_momentum_roughness_length\"],\n    z_0b = toml_dict[\"snow_scalar_roughness_length\"],\n    ϵ_snow = toml_dict[\"snow_emissivity\"],\n    α_snow = ConstantAlbedoModel(toml_dict[\"snow_albedo\"]),\n    density = MinimumDensityModel(toml_dict[\"snow_density\"]),\n    scf = WuWuSnowCoverFractionModel(toml_dict, FT(1)),\n    θ_r = toml_dict[\"holding_capacity_of_water_in_snow\"],\n    Ksat = toml_dict[\"wet_snow_hydraulic_conductivity\"],\n    ΔS = toml_dict[\"delta_S\"],\n)\n\nCreates a SnowModel model with the given float type FT, domain, toml_dict, forcing, and prognostic land components.\n\nWhen running the snow model in standalone mode, provide prognostic_land_components = (:snow,), while for running integrated land models, this should be a list of the component models. This value of this argument must be the same across all components in the integrated land model.\n\nDefault parameterizations and parameters can be overwritten using keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Snow/#ClimaLand.Snow.SnowParameters","page":"Snow Model","title":"ClimaLand.Snow.SnowParameters","text":"SnowParameters{FT <: AbstractFloat, PSE}\n\nA struct for storing parameters of the SnowModel.\n\nNote that in our current implementation of runoff, a physical timescale is required and computed using Ksat and the depth of the snow. For shallow snowpacks, this will fall below the timestep of the model. For that reason, we pass the timestep of the model as a parameter, and take the larger of the timestep and the physical timescale as the value used in the model. Future implementations will revisit this.\n\ndensity: Choice of parameterization for snow density\nz_0m: Roughness length over snow for momentum (m)\nz_0b: Roughness length over snow for scalars (m)\nα_snow: Albedo parameterization for snow\nϵ_snow: Emissivity of snow (unitless)\nθ_r: Volumetric holding capacity of water in snow (unitless)\nKsat: Hydraulic conductivity of wet snow (m/s)\nκ_ice: Thermal conductivity of ice (W/m/K)\nΔt: Timestep of the model (s)\nΔS: Parameter to prevent dividing by zero when computing snow temperature (m)\nscf: Snow cover fraction parameterization\nearth_param_set: Clima-wide parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/Snow/#ClimaLand.Snow.SnowParameters-Tuple{ClimaParams.ParamDict, Any}","page":"Snow Model","title":"ClimaLand.Snow.SnowParameters","text":"function SnowParameters(\n    toml_dict::CP.ParamDict,\n    Δt;\n    ρ_snow = toml_dict[\"snow_density\"],\n    α_snow_param = toml_dict[\"snow_albedo\"],\n    density::DM = MinimumDensityModel(ρ_snow),\n    α_snow::AM = ConstantAlbedoModel(α_snow_param),\n    scf ::SCFM = WuWuSnowCoverFractionModel(\n        toml_dict,\n        CP.float_type(toml_dict)(1.0),\n    ),\n    z_0m = toml_dict[\"snow_momentum_roughness_length\"],\n    z_0b = toml_dict[\"snow_scalar_roughness_length\"],\n    κ_ice = toml_dict[\"thermal_conductivity_of_water_ice\"],\n    ϵ_snow = toml_dict[\"snow_emissivity\"],\n    θ_r = toml_dict[\"holding_capacity_of_water_in_snow\"],\n    Ksat = toml_dict[\"wet_snow_hydraulic_conductivity\"],\n    ΔS = toml_dict[\"delta_S\"],\n) where {DM, AM, SCFM}\n\nTOML dictionary constructor for the SnowParameters` struct.\n\nΔt = 450.0\n# TOML Dictionary:\nimport ClimaParams as CP\ntoml_dict = CP.create_toml_dict(Float32);\nClimaLand.Canopy.SnowParameters(toml_dict, Δt; ϵ_snow = Float32(0.99), Ksat = Float32(1e-4))\n\n\n\n\n\n","category":"method"},{"location":"APIs/Snow/#ClimaLand.Snow.specific_heat_capacity","page":"Snow Model","title":"ClimaLand.Snow.specific_heat_capacity","text":"specific_heat_capacity(q_l::FT,\n                       parameters::SnowParameters{FT}\n                       ) where {FT}\n\nComputes the specific heat capacity of the snow, neglecting any contribution from air in the pore spaces, given the liquid water mass fraction q_l and other parameters.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_surface_temperature","page":"Snow Model","title":"ClimaLand.Snow.snow_surface_temperature","text":"snow_surface_temperature(T::FT) where {FT}\n\nReturns the snow surface temperature assuming it is the same as the bulk temperature T.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_thermal_conductivity","page":"Snow Model","title":"ClimaLand.Snow.snow_thermal_conductivity","text":"snow_thermal_conductivity(ρ_snow::FT,\n                     parameters::SnowParameters{FT},\n                     ) where {FT}\n\nComputes the thermal conductivity, given the density of the snow, according to Equation 5.33 from Bonan's textbook, which in turn is taken from Jordan (1991).\n\nWe have adjusted the original equation to make the coefficients non-dimensional by multiplying by the first by x = ρ_ice/ρ_ice and the second by x², with ρ_ice in kg/m³.\n\nWhen ρ_snow = ρ_ice, we recover κ_snow = κ_ice.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_bulk_temperature","page":"Snow Model","title":"ClimaLand.Snow.snow_bulk_temperature","text":"snow_bulk_temperature(U::FT,\n                      S::FT,\n                      q_l::FT,\n                      parameters::SnowParameters{FT}) where {FT}\n\nComputes the bulk snow temperature from the snow water equivalent S, energy per unit area U, liquid water fraction ql, and specific heat capacity cs, along with other needed parameters.\n\nIf there is no snow (U = S = q_l = 0), the bulk temperature is the reference temperature, which is 273.16K.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.liquid_mass_fraction","page":"Snow Model","title":"ClimaLand.Snow.liquid_mass_fraction","text":"liquid_mass_fraction(S::FT, S_l::FT)::FT where {FT}\n\nDiagnoses the liquid mass fraction from the prognostic variables Sl and S, while preventing from division by zero and enforcing that ql = S_l/S must lie between 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.maximum_liquid_mass_fraction","page":"Snow Model","title":"ClimaLand.Snow.maximum_liquid_mass_fraction","text":"maximum_liquid_mass_fraction(ρ_snow::FT, T::FT, parameters::SnowParameters{FT}) where {FT}\n\nComputes the maximum liquid water mass fraction, given the density of the snow ρ_snow and other parameters.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.runoff_timescale","page":"Snow Model","title":"ClimaLand.Snow.runoff_timescale","text":"runoff_timescale(z::FT, Ksat::FT, Δt::FT) where {FT}\n\nComputes the timescale for liquid water to percolate and leave the snowpack, given the depth of the snowpack z and the hydraulic conductivity Ksat.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.compute_water_runoff","page":"Snow Model","title":"ClimaLand.Snow.compute_water_runoff","text":"compute_energy_runoff(S::FT, S_l::FT, T::FT, parameters) where {FT}\n\nComputes the rate of change in the snow water equivalent S due to loss of liquid water (runoff) from the snowpack.\n\nRunoff occurs as the snow melts and exceeds the water holding capacity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.energy_from_q_l_and_swe","page":"Snow Model","title":"ClimaLand.Snow.energy_from_q_l_and_swe","text":"energy_from_q_l_and_swe(S::FT, q_l::FT, parameters) where {FT}\n\nA helper function for compute the snow energy per unit area, given snow water equivalent S, liquid fraction q_l, and snow model parameters.\n\nThis assumes that the snow is at the freezing point.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.energy_from_T_and_swe","page":"Snow Model","title":"ClimaLand.Snow.energy_from_T_and_swe","text":"energy_from_T_and_swe(S::FT, T::FT, parameters) where {FT}\n\nA helper function for compute the snow energy per unit area, given snow water equivalent S, bulk temperature T, and snow model parameters.\n\nThe liquid mass fraction is assumed to be zero if T<=T_freeze, and 1 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.energy_flux_falling_rain","page":"Snow Model","title":"ClimaLand.Snow.energy_flux_falling_rain","text":"energy_flux_falling_rain(atmos, p, parameters)\n\nReturns the energy flux of falling rain for a PrescribedAtmosphere, approximated as ρl el(Tatmos) * Pliq. The energy is per unit volume of liquid water, and P_liq is expressed as the volume flux of liquid water resulting from the rain.\n\nThis method can be extended to coupled simulations, where atmos is of type CoupledAtmosphere, and the energy flux of the falling rain is passed in the cache p.  In that case, this should specify atmos::PrescribedAtmosphere.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.energy_flux_falling_snow","page":"Snow Model","title":"ClimaLand.Snow.energy_flux_falling_snow","text":"energy_flux_falling_snow(atmos, p, parameters)\n\nReturns the energy flux of falling snow for a PrescribedAtmosphere, approximated as ρesnow * Psnow, where ρesnow = -LHf0 * ρliq. This is a negative internal energy, due the to negative contribution of the latent heat of melting to the energy of the snow,  and it neglects the sensible heat portion of the snow. The energy  is per unit volume of liquid water, and P_snow is expressed as the volume flux of liquid water resulting from the snow.\n\nThis method can be extended to coupled simulations, where atmos is of type CoupledAtmosphere, and the energy flux of the falling snow is passed in the cache p. In that case, this should specify atmos::PrescribedAtmosphere.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.update_snow_cover_fraction!","page":"Snow Model","title":"ClimaLand.Snow.update_snow_cover_fraction!","text":"update_snow_cover_fraction!(x::FT; z0 = FT(1e-1), β_scf = FT(2))::FT where {FT}\n\nReturns the snow cover fraction from snow depth z, from Wu, Tongwen, and Guoxiong Wu. \"An empirical formula to compute snow cover fraction in GCMs.\" Advances in Atmospheric Sciences 21 (2004): 529-535.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.update_snow_albedo!","page":"Snow Model","title":"ClimaLand.Snow.update_snow_albedo!","text":"update_snow_albedo!(α, m::ConstantAlbedoModel, Y, p, t, earth_param_set)\n\nUpdates the snow albedo α in place with the current albedo, according to the ConstantAlbedoModel.\n\n\n\n\n\nupdate_snow_albedo!(α, m::ZenithAngleAlbedoModel, Y, p, t, earth_param_set)\n\nUpdates the snow albedo α in place with the current albedo, according to the ZenithAngleAlbedoModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_boundary_fluxes!","page":"Snow Model","title":"ClimaLand.Snow.snow_boundary_fluxes!","text":"snow_boundary_fluxes!(bc::AtmosDrivenSnowBC, model::SnowModel, Y, p, t)\n\nUpdates in place various volumetric water flux (m/s) and energy flux (W/m^2) terms for the snow model:\n\np.snow.turbulent fluxes (latent, sensible, and evaporative fluxes)\np.snow.R_n (radiative fluxes)\np.snow.total_water_flux\np.snow.total_energy_flux\n\nThe two latter fluxes also include contributions from fluxes due to melt and precipitation, but note that precipitation and melt flux are not computed or updated in snow_boundary_fluxes currently. Instead, they are updated in update_aux!, which happens prior to the snow_boundary_fluxes! call, and used in the snow_boundary_fluxes! call.\n\nThis function calls the turbulent_fluxes! and net_radiation! functions, which use the snow surface conditions as well as the atmos and radiation conditions in order to compute the surface fluxes using Monin Obukhov Surface Theory. It also accounts for the presence of other components, if run as part of an integrated land model, and their effect on boundary conditions.\n\n\n\n\n\nsnow_boundary_fluxes!(\n    bc::AtmosDrivenSnowBC,\n    prognostic_land_components::Val{(:snow,)},\n    model::SnowModel{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nComputes the boundary fluxes for the snow model in standalone mode.\n\nThe ground heat flux is assumed to be zero, and the snow surface is assumed to be bare (no vegetation).\n\n\n\n\n\nsnow_boundary_fluxes!(\n    bc::AtmosDrivenSnowBC,\n    prognostic_land_components::Val{(:snow, :soil)},\n    model::SnowModel{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nA method of snow_boundary_fluxes! which computes the boundary fluxes for the snow model accounting for a heat flux between the soil and snow.\n\nThe snow surface is assumed to be bare (no vegetation).\n\nCurrently this is almost identical to the method for snow alone, except for the inclusion of the ground heat flux (precomputed by the integrated land model). However, this will change more if e.g. we allow for transmission of radiation through the snowpack.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.phase_change_flux","page":"Snow Model","title":"ClimaLand.Snow.phase_change_flux","text":" phase_change_flux(U::FT, S::FT, q_l::FT, energy_flux::FT, parameters) where {FT}\n\nComputes the volume flux of liquid water undergoing phase change, given the applied energy flux and current state of U,S,q_l.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.AtmosDrivenSnowBC","page":"Snow Model","title":"ClimaLand.Snow.AtmosDrivenSnowBC","text":"AtmosDrivenSnowBC{\n    A <: AbstractAtmosphericDrivers,\n    B <: AbstractRadiativeDrivers,\n    C::Tuple\n} <: AbstractSnowBC\n\nA struct used to specify the snow fluxes, referred to as \"boundary conditions\", at the surface and bottom of the snowpack, for water and energy.\n\nThese fluxes include turbulent surface fluxes computed with Monin-Obukhov theory, and radiative fluxes.\n\natmos: The atmospheric conditions driving the model\nradiation: The radiative fluxes driving the model\nprognostic_land_components: Prognostic land components present\n\n\n\n\n\n","category":"type"},{"location":"APIs/Snow/#ClimaLand.Snow.WuWuSnowCoverFractionModel","page":"Snow Model","title":"ClimaLand.Snow.WuWuSnowCoverFractionModel","text":"WuWuSnowCoverFractionModel{FT <: AbstractFloat} <: AbstractSnowCoverFractionModel{FT}\n\nEstablishes the snow cover parameterization of Wu, Tongwen, and Guoxiong Wu. \"An empirical formula to compute snow cover fraction in GCMs.\" Advances in Atmospheric Sciences 21 (2004): 529-535,     scf = min(β_scf * z̃ / (z̃ + 1), 1),\n\nwhere z̃ = snow depth per ground area / 0.106 m, and β_scf is computed using a resolution dependent formula: β_scf = max(β0 - γ(horz_degree_res - 1.5), β_min), where horz_degree_res is the horizontal resolution of the simulation, in degrees, and β0, β_min and γ are unitless. It is correct to think of β0, β_min, γ, and z0 as the free parameters, while horz_degree_res is provided and β_scf is determined.\n\nβ0, β_min, γ, and β_scf must be > 0.\n\nFrom Wu and Wu et al, β0 ∼ 1.77 and γ ∼ 0.08, over a range of 1.5-4.5∘\n\n\n\n\n\n","category":"type"},{"location":"APIs/Snow/#ClimaLand.Snow.ZenithAngleAlbedoModel","page":"Snow Model","title":"ClimaLand.Snow.ZenithAngleAlbedoModel","text":"ZenithAngleAlbedoModel{FT <: AbstractFloat} <: AbstractAlbedoModel{FT}\n\nEstablishes the albedo parameterization where albedo depends on the cosine of the zenith angle of the sun, as\n\nalpha = f(x) alpha_0 + Deltaalpha cdot textexp(-kcos(theta s))\n\nwhere cos θs is the cosine of the zenith angle, α_0, Δα, and k are free parameters. The factor out front is a function of x = ρ_snow/ρ_liq, of the form f(x) = min(1 - β(x-x0), 1). The parameters x0 ∈ [0,1] and β ∈ [0,1] are free. Choose β = 0 to remove this dependence on snow density.\n\nNote: If this choice is used, the field cosθs must appear in the cache p.drivers. This is available through the PrescribedRadiativeFluxes object.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Snow/#ClimaLand.Snow.ConstantAlbedoModel","page":"Snow Model","title":"ClimaLand.Snow.ConstantAlbedoModel","text":"ConstantAlbedoModel{FT <: AbstractFloat} <: AbstractAlbedoModel{FT}\n\nEstablishes the albedo parameterization where albedo is treated as a constant spatially and temporally.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#Soil-Sources-and-Boundary-Conditions","page":"Soil Sources and Boundary Conditions","title":"Soil Sources and Boundary Conditions","text":"","category":"section"},{"location":"APIs/soil/SoilSourcesandBCs/#Soil-Runoff-Types-and-Methods","page":"Soil Sources and Boundary Conditions","title":"Soil Runoff Types and Methods","text":"","category":"section"},{"location":"APIs/soil/SoilSourcesandBCs/#Soil-BC-Types-and-Methods","page":"Soil Sources and Boundary Conditions","title":"Soil BC Types and Methods","text":"","category":"section"},{"location":"APIs/soil/SoilSourcesandBCs/#Soil-Source-Types","page":"Soil Sources and Boundary Conditions","title":"Soil Source Types","text":"","category":"section"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.Runoff.AbstractRunoffModel","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.Runoff.AbstractRunoffModel","text":"AbstractRunoffModel\n\nThe soil runoff models are only to be used with the following boundary condition types:\n\nClimaLand.Soil.AtmosDrivenFluxBC\nClimaLand.Soil.RichardsAtmosDrivenFluxBC.\n\nIt must have methods for\n\nsubsurface_runoff_source (defined in this module)\nupdate_infiltration_water_flux! (defined in this module)\nClimaLand.source!.\n\nPlease see the documentation for these for more details.\n\nYour runoff model must specify the subsurface runoff sink term as well as the surface runoff implementation.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.Runoff.NoRunoff","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.Runoff.NoRunoff","text":"NoRunoff <: AbstractRunoffModel\n\nA concrete type of soil runoff model; the default choice, which does not include any runoff.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.Runoff.SurfaceRunoff","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.Runoff.SurfaceRunoff","text":"SurfaceRunoff <: AbstractRunoffModel\n\nA simple model for runoff appropriate for single column runs.\n\nOnly surface runoff is computed, using a combination of Dunne and Hortonian runoff.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.Runoff.TOPMODELRunoff","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.Runoff.TOPMODELRunoff","text":"TOPMODELRunoff{FT <: AbstractFloat, F <: ClimaCore.Fields.Field} <: AbstractRunoffModel\n\nThe TOPMODEL surface runoff parameterization, which is affects the surface boundary condition of the soil model.\n\nThe runoff flux is given by Equation 8 of with fsat given by Equation (11), of Niu et al. (2005), \"A simple TOPMODEL-based runoff parameterization (SIMTOP) for use in global climate models\".\n\nf_over: A calibrated parameter defining how subsurface runoff decays with depth to water table (1/m ; calibrated)\nf_max: The maximum saturated fraction of a grid cell, computed from the topographic index CDF per grid cell.\nsubsurface_source: The subsurface source term corresponding to this implementation of TOPMODEL.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.Runoff.TOPMODELSubsurfaceRunoff","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.Runoff.TOPMODELSubsurfaceRunoff","text":"TOPMODELSubsurfaceRunoff{FT} <: AbstractSoilSource{FT}\n\nThe TOPMODEL subsurface runoff parameterization, which is implemented as a sink term in the soil equations.\n\nThe runoff flux is given by Equation 12 of Niu et al. (2005), \"A simple TOPMODEL-based runoff parameterization (SIMTOP) for use in global climate models\".\n\nThis is currently treated implicitly (evaluated at the next value of ϑ_l) but not included in the Jacobian approximation. This is because update_infiltration_water_flux is called as part of the implicit tendency.\n\nR_sb: The subsurface runoff flux (m/s) when the depth to the water table = 1/f_over; calibrated\nf_over: A calibrated parameter defining how subsurface runoff decays with depth to water table (1/m ; calibrated)\nexplicit: Explicit vs implicit stepping\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.Runoff.subsurface_runoff_source","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.Runoff.subsurface_runoff_source","text":"subsurface_runoff_source(runoff::AbstractRunoffModel)\n\nA helper function which returns the subsurface source of the runoff model runoff.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.Runoff.update_infiltration_water_flux!","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.Runoff.update_infiltration_water_flux!","text":"update_infiltration_water_flux!(p, runoff::NoRunoff, input, _...)\n\nUpdates the runoff variables in the cache p.soil in place in the case of NoRunoff: sets infiltration = precipitation.\n\n\n\n\n\nupdate_infiltration_water_flux!(\n    p,\n    runoff::SurfaceRunoff,\n    input,\n    Y,\n    t,\n    model::AbstractSoilModel,\n\n)\n\nThe updateinfiltrationwater_flux! function for the SurfaceRunoff model.\n\nUpdates the runoff model variables in place in p.soil for the SurfaceRunoff parameterization: p.soil.Rs p.soil.issaturated p.soil.infiltration\n\n\n\n\n\nupdate_infiltration_water_flux!(p, runoff::TOPMODELRunoff, input, Y,t, model::AbstractSoilModel)\n\nUpdates the runoff model variables in place in p.soil for the TOPMODELRunoff parameterization: p.soil.Rs p.soil.Rss p.soil.h∇ p.soil.infiltration\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.MoistureStateBC","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.MoistureStateBC","text":"MoistureStateBC <: AbstractWaterBC\n\nA simple concrete type of boundary condition, which enforces a state boundary condition ϑ_l = f(p,t) at either the top or bottom of the domain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.HeatFluxBC","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.HeatFluxBC","text":"HeatFluxBC <: AbstractHeatBC\n\nA simple concrete type of boundary condition, which enforces a normal flux boundary condition f(p,t) at either the top or bottom of the domain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.WaterFluxBC","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.WaterFluxBC","text":"WaterFluxBC <: AbstractWaterBC\n\nA simple concrete type of boundary condition, which enforces a normal flux boundary condition f(p,t) at either the top or bottom of the domain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.TemperatureStateBC","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.TemperatureStateBC","text":"TemperatureStateBC <: AbstractHeatBC\n\nA simple concrete type of boundary condition, which enforces a state boundary condition T = f(p,t) at either the top or bottom of the domain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.FreeDrainage","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.FreeDrainage","text":"FreeDrainage <: AbstractWaterBC\n\nA concrete type of soil boundary condition, for use at the BottomBoundary only, where the flux is set to be F = -K∇h = -K.\n\nThis is not tied to any boundary condition for the heat equation. To account for the energy flux resulting from free drainage of liquid water, please see EnergyWaterFreeDrainage.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.EnergyWaterFreeDrainage","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.EnergyWaterFreeDrainage","text":"EnergyWaterFreeDrainage <: AbstractEnergyHydrologyBC\n\nA concrete type of soil boundary condition, for use at the BottomBoundary only, where the fluxes are set to be F_liq = -K∇h = -K, F_energy = -K ρe_liq.\n\nThat is, this enforces that the free drainage boundary condition for liquid water is paired the the corresponding loss of energy that that entails.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.RichardsAtmosDrivenFluxBC","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.RichardsAtmosDrivenFluxBC","text":"RichardsAtmosDrivenFluxBC{F <: PrescribedPrecipitation, R <: AbstractRunoffModel} <: AbstractWaterBC\n\nA concrete type of boundary condition intended only for use with the RichardsModel, which uses a prescribed precipitation rate (m/s) to compute the infiltration into the soil.\n\nA runoff model is used to simulate surface and subsurface runoff and this is accounted for when setting boundary conditions. In order to run the simulation without runoff, choose runoff = NoRunoff() - this is also the default.\n\nIf you wish to simulate precipitation and runoff in the full EnergyHydrology model, you must use the AtmosDrivenFluxBC type.\n\nprecip: The prescribed liquid water precipitation rate f(t) (m/s); Negative by convention.\nrunoff: The runoff model. The default is no runoff.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.AtmosDrivenFluxBC","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.AtmosDrivenFluxBC","text":"AtmosDrivenFluxBC{\n    A <: AbstractAtmosphericDrivers,\n    B <: AbstractRadiativeDrivers,\n    R <: AbstractRunoffModel,\n    C::Tuple\n} <: AbstractEnergyHydrologyBC\n\nA concrete type of soil boundary condition for use at the top of the domain. This holds the conditions for the atmosphere AbstractAtmosphericDrivers, for the radiation state AbstractRadiativeDrivers. This is only supported for the EnergyHydrology model.\n\nThis choice indicates the Monin-Obukhov Surface Theory will be used to compute the sensible and latent heat fluxes, as well as evaporation,  and that the net radiation and precipitation will also be computed. The net energy and water fluxes are used as boundary conditions.\n\nA runoff model is used to simulate surface and subsurface runoff and this is accounted for when setting boundary conditions. The default is to have no runoff accounted for.\n\nFinally, because this same boundary condition type is used for the soil in integrated land surface models, we also provide a tuple of symbols indicating the prognostic land components present, as these affect how the boundary conditions are computed. The default is a tuple containing only (:soil,), indicating a standalone soil run.\n\nFor more information on the allowed values, please see the documentation\n\natmos: The atmospheric conditions driving the model\nradiation: The radiative fluxes driving the model\nrunoff: The runoff model. The default is no runoff.\nprognostic_land_components: Prognostic land components present\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.WaterHeatBC","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.WaterHeatBC","text":"WaterHeatBC{W <: AbstractWaterBC, H <: AbstractHeatBC} <:\n   AbstractEnergyHydrologyBC\n\nA general struct used to store the boundary conditions for Richards and the soil heat equations separately; useful when the boundary conditions for each component are independent of each other.\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.soil_boundary_fluxes!","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.soil_boundary_fluxes!","text":"soil_boundary_fluxes!(bc::WaterHeatBC, boundary::AbstractBoundary, model, Δz, Y, p, t)\n\nupdates the boundary fluxes for ϑl and ρeint.\n\n\n\n\n\nsoil_boundary_fluxes!(\n    bc::AtmosDrivenFluxBC,\n    boundary::ClimaLand.TopBoundary,\n    model::EnergyHydrology,\n    Δz,\n    Y,\n    p,\n    t,\n)\n\nReturns the net volumetric water flux (m/s) and net energy flux (W/m^2) for the soil EnergyHydrology model at the top of the soil domain.\n\nThis function calls the turbulent_fluxes! and net_radiation! functions, which use the soil surface conditions as well as the atmos and radiation conditions in order to compute the surface fluxes using Monin Obukhov Surface Theory. It also accounts for the presence of other components, if run as part of an integrated land model, and their effect on boundary conditions.\n\n\n\n\n\nsoil_boundary_fluxes!(\n    bc::AtmosDrivenFluxBC,\n    prognostic_land_components::Val{(:soil,)},\n    model::EnergyHydrology,\n    Y,\n    p,\n    t,\n)\n\nReturns the net volumetric water flux (m/s) and net energy flux (W/m^2) for the soil EnergyHydrology model at the top of the soil domain.\n\nHere, the soil boundary fluxes are computed as if the soil is run in standalone mode, indicated by the value of prognostic_land_components.\n\n\n\n\n\nsoil_boundary_fluxes!(\n    bc::AtmosDrivenFluxBC{<:PrescribedAtmosphere, <:PrescribedRadiativeFluxes},\n    prognostic_land_components::Val{(:canopy, :soil,:soilco2,)},\n    soil::EnergyHydrology,\n    Y,\n    p,\n    t,\n)\n\nA method of ClimaLand.Soil.soil_boundary_fluxes! which is used for integrated land surface models; this computes and returns the net energy and water flux at the surface of the soil for use as boundary conditions when a canopy and Soil CO2  model is also included, though only the presence of the canopy modifies the soil BC.\n\n\n\n\n\nsoil_boundary_fluxes!(\n    bc::AtmosDrivenFluxBC{<:PrescribedAtmosphere, <:PrescribedRadiativeFluxes},\n     prognostic_land_components::Val{(:snow, :soil)},\n    soil::EnergyHydrology,\n    Y,\n    p,\n    t,\n)\n\nA method of ClimaLand.Soil.soil_boundary_fluxes! which is used for integrated land surface models; this computes and returns the net energy and water flux at the surface of the soil for use as boundary conditions, taking into account the presence of snow on the surface.\n\n\n\n\n\nsoil_boundary_fluxes!(\n    bc::AtmosDrivenFluxBC{<:PrescribedAtmosphere, <:PrescribedRadiativeFluxes},\n    prognostic_land_components::Val{(:canopy, :snow, :soil,:soilco2,)},\n    soil::EnergyHydrology{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nA method of ClimaLand.Soil.soil_boundary_fluxes! which is used for integrated land surface models; this computes and returns the net energy and water flux at the surface of the soil for use as boundary conditions when a canopy and Soil CO2  model is also included, though only the presence of the canopy modifies the soil BC.\n\n\n\n\n\n","category":"function"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.AbstractSoilSource","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.AbstractSoilSource","text":"AbstractSoilSource{FT} <:  ClimaLand.AbstractSource{FT}\n\nAn abstract type for types of source terms for the soil equations.\n\nIn standalone mode, the only supported source type is freezing and thawing. ClimaLand.jl creates additional sources to include as necessary e.g. root extraction (not available in stand alone mode).\n\n\n\n\n\n","category":"type"},{"location":"APIs/soil/SoilSourcesandBCs/#ClimaLand.Soil.PhaseChange","page":"Soil Sources and Boundary Conditions","title":"ClimaLand.Soil.PhaseChange","text":"PhaseChange{FT} <: AbstractSoilSource{FT}\n\nPhaseChange source type; treated explicitly in all prognostic variables.\n\n\n\n\n\n","category":"type"},{"location":"generated/integrated/changing_snowy_land_parameterizations/#Changing-LandModel-Parameterizations","page":"Changing LandModel parameterizations","title":"Changing LandModel Parameterizations","text":"In the Canopy, soil, and snow tutorial, we ran the integrated LandModel at a Fluxnet site using all of the default parameterizations and parameters.\n\nIn two other tutorials (Changing soil parameterizations and Changing canopy parameterizations) we explored how to change the parameterizations of the standalone soil and canopy models, respectively.\n\nThis tutorial will combine these two streams of work to set up a LandModel with non-default parameterizations within the soil and canopy components.\n\nThis time, we'll use non-default parameterizations for one canopy component:\n\nradiative transfer: change from the default TwoStreamModel to BeerLambertModel\n\nand one snow component:\n\nsnow albedo: change from the default ConstantAlbedo to ZenithAngleAlbedoModel","category":"section"},{"location":"generated/integrated/changing_snowy_land_parameterizations/#Fluxnet-simulations-with-the-full-land-model:-snow,-soil,-canopy","page":"Changing LandModel parameterizations","title":"Fluxnet simulations with the full land model: snow, soil, canopy","text":"As in the previous LandModel tutorial, we'll run at the Niwot Ridge site using data from Blanken et al. [23].","category":"section"},{"location":"generated/integrated/changing_snowy_land_parameterizations/#Preliminary-Setup","page":"Changing LandModel parameterizations","title":"Preliminary Setup","text":"using Dates\nimport ClimaParams as CP\nusing ClimaDiagnostics\nusing ClimaLand\nusing ClimaLand.Domains: Column, obtain_surface_domain\nusing ClimaLand.Simulations\nusing ClimaLand.Snow\nusing ClimaLand.Canopy\nimport ClimaLand.Parameters as LP\nusing DelimitedFiles\nimport ClimaLand.FluxnetSimulations as FluxnetSimulations\nusing CairoMakie, ClimaAnalysis, GeoMakie, Printf, StatsBase\nimport ClimaLand.LandSimVis as LandSimVis;\n\nDefine the floating point precision desired (64 or 32 bit), and get the parameter set holding constants used across CliMA Models.\n\nconst FT = Float32;\ntoml_dict = LP.create_toml_dict(FT);\n\nWe will use prescribed atmospheric and radiative forcing from the US-NR1 tower.  We also read in the MODIS LAI and let that vary in time in a prescribed manner.\n\nsite_ID = \"US-NR1\";\nsite_ID_val = FluxnetSimulations.replace_hyphen(site_ID);\n\nGet the latitude and longitude in degrees, as well as the time offset in hours of local time from UTC\n\n(; time_offset, lat, long) =\n    FluxnetSimulations.get_location(FT, Val(site_ID_val));\n\nGet the height of the sensors in m\n\n(; atmos_h) = FluxnetSimulations.get_fluxtower_height(FT, Val(site_ID_val));\n\nSet a start and stop date of the simulation in UTC, as well as a timestep in seconds\n\n(start_date, stop_date) =\n    FluxnetSimulations.get_data_dates(site_ID, time_offset);\nΔt = 450.0;\n\nSetup the domain for the model. This corresponds to a column of 2m in depth, with 10 equally spaced layers. The lat and long are provided so that we can look up default parameters for this location using the default ClimaLand parameter maps.\n\nzmin = FT(-2) # in m\nzmax = FT(0) # in m\ndomain = Column(; zlim = (zmin, zmax), nelements = 10, longlat = (long, lat));\n\nForcing data for the site - this uses our interface for working with Fluxnet data\n\nforcing = FluxnetSimulations.prescribed_forcing_fluxnet(\n    site_ID,\n    lat,\n    long,\n    time_offset,\n    atmos_h,\n    start_date,\n    toml_dict,\n    FT,\n);\n\nLAI for the site - this uses our interface for working with MODIS data.\n\nLAI = ClimaLand.Canopy.prescribed_lai_modis(\n    domain.space.surface,\n    start_date,\n    stop_date,\n);","category":"section"},{"location":"generated/integrated/changing_snowy_land_parameterizations/#Setup-the-integrated-model","page":"Changing LandModel parameterizations","title":"Setup the integrated model","text":"First, we need to set up the component models we won't be using the defaults for. Since we are constructing these outside of the LandModel constructor, we need to provide some additional inputs that were omitted in the previous LandModel tutorial:\n\nsurface_domain: the surface of this simulation domain, which the snow and canopy models will use\nprognostic_land_components: the prognostic land components, which must be consistent across all components\nground: the canopy ground conditions, which are prognostic since we're running with the soil\n\nsurface_domain = obtain_surface_domain(domain);\nprognostic_land_components = (:canopy, :snow, :soil, :soilco2);\nground = ClimaLand.PrognosticGroundConditions{FT}();\n\nFirst, we will set up the snow model. We will use the ZenithAngleAlbedoModel for the snow albedo parameterization. This parameterization uses the zenith angle of the sun to determine the albedo, as opposed to the default ConstantAlbedoModel which uses a temporally and spatially constant snow albedo.\n\nα_0 = FT(0.6) # parameter controlling the minimum snow albedo\nΔα = FT(0.06) # parameter controlling the snow albedo when θs = 90∘\nk = FT(2) # rate at which albedo drops to its minimum value with zenith angle\nα_snow = Snow.ZenithAngleAlbedoModel(α_0, Δα, k);\n\nNow we can create the SnowModel model with the specified snow albedo parameterization.\n\nsnow = Snow.SnowModel(\n    FT,\n    surface_domain,\n    forcing,\n    toml_dict,\n    Δt;\n    prognostic_land_components,\n    α_snow,\n);\n\nNext, let's set up the canopy model using the BeerLambertModel radiative transfer parameterization with custom parameters. We already did this in the Changing canopy parameterizations tutorial, so it should be familiar. In that example we showed three different ways to construct the BeerLambertModel. Here, we will use the third method, which takes the parameters object directly.\n\nG_Function = Canopy.ConstantGFunction(FT(0.5)); # leaf angle distribution value 0.5\nα_PAR_leaf = 0.2; # albedo in the PAR band\nα_NIR_leaf = 0.3; # albedo in the NIR band\nΩ = 1; # clumping index\nradiative_transfer_parameters = Canopy.BeerLambertParameters(\n    toml_dict;\n    G_Function,\n    α_PAR_leaf,\n    α_NIR_leaf,\n    Ω,\n);\nradiative_transfer = Canopy.BeerLambertModel(radiative_transfer_parameters);\n\nNow we can create the CanopyModel model with the specified radiative transfer parameterizations passed as keyword arguments.\n\n(; atmos, radiation) = forcing;\ncanopy = Canopy.CanopyModel{FT}(\n    surface_domain,\n    (; atmos, radiation, ground),\n    LAI,\n    toml_dict;\n    prognostic_land_components,\n    radiative_transfer,\n);\n\nNow we can construct the integrated LandModel. Since we want to use the defaults for the soil model, we don't need to provide anything for it. For the canopy and snow models, we'll provide the models we just set up.\n\nland_model = LandModel{FT}(\n    forcing,\n    LAI,\n    toml_dict,\n    domain,\n    Δt;\n    prognostic_land_components,\n    snow,\n    canopy,\n);\nset_ic! = FluxnetSimulations.make_set_fluxnet_initial_conditions(\n    site_ID,\n    start_date,\n    time_offset,\n    land_model,\n);\noutput_vars = [\"swu\", \"lwu\", \"shf\", \"lhf\", \"swe\", \"swc\", \"si\"]\ndiagnostics = ClimaLand.default_diagnostics(\n    land_model,\n    start_date;\n    output_writer = ClimaDiagnostics.Writers.DictWriter(),\n    output_vars,\n    reduction_period = :hourly,\n);\n\nChoose how often we want to update the forcing.\n\ndata_dt = Second(FluxnetSimulations.get_data_dt(site_ID));\n\nNow we can construct the simulation object and solve it.\n\nsimulation = Simulations.LandSimulation(\n    start_date,\n    stop_date,\n    Δt, # seconds\n    land_model;\n    set_ic!,\n    updateat = Second(data_dt),\n    user_callbacks = (),\n    diagnostics,\n);\nsolve!(simulation);","category":"section"},{"location":"generated/integrated/changing_snowy_land_parameterizations/#Plotting-results","page":"Changing LandModel parameterizations","title":"Plotting results","text":"LandSimVis.make_diurnal_timeseries(\n    simulation;\n    short_names = [\"shf\", \"lhf\", \"swu\", \"lwu\"],\n    spinup_date = start_date + Day(20),\n    plot_stem_name = \"US_NR1_diurnal_timeseries_parameterizations\",\n);\n\n(Image: ) (Image: ) (Image: ) (Image: )\n\nLandSimVis.make_timeseries(\n    simulation;\n    short_names = [\"swc\", \"si\", \"swe\"],\n    spinup_date = start_date + Day(20),\n    plot_stem_name = \"US_NR1_timeseries_parameterizations\",\n);\n\n(Image: ) (Image: ) (Image: )\n\nNow you can compare these plots to those generated in the default LandModel Fluxnet tutorial. How are the results different? How are they the same?\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"standalone/pages/vegetation/turbulent_fluxes/turbulent_fluxes/#Canopy-Turbulent-Fluxes","page":"Physics","title":"Canopy Turbulent Fluxes","text":"This page documents how turbulent fluxes are computed in the ClimaLand Canopy Model.\n\n","category":"section"},{"location":"standalone/pages/vegetation/turbulent_fluxes/turbulent_fluxes/#Leaf-properties","page":"Physics","title":"Leaf properties","text":"The leaf temperature is modelled in the Canopy Energy component. The leaf specific humidity is determined as the saturated value at that temperature. The stomatal conductance at the canopy level is computed by the Canopy Stomatal Conductance component. The problem is then to parameterize the air temperature and specific humidity at the top of the canopy. –-","category":"section"},{"location":"standalone/pages/vegetation/turbulent_fluxes/turbulent_fluxes/#Canopy-top-properties","page":"Physics","title":"Canopy top properties","text":"We assume a flux balance between the sensible and vapor fluxes between the atmosphere and the canopy top, and between the canopy top and the canopy leaves. For example,\n\nH  = -rho_rmatmos fracT_rmatmos- T_rmcanopy airr_ae = -rho_rmatmos fracT_rmcanopy air - T_rmleavesr_rmcanopy\n\nand\n\nT  = -rho_rmatmos fracq_rmatmos- q_rmcanopy airr_ae = -rho_rmatmos fracq_rmcanopy air - q_rmleavesr_rmcanopy+ r_rmstomata\n\nWe can then solve for the canopy air properties:\n\nT_rmcanopy air = fracr_aeT_rmleaves + r_rmcanopy T_rmatmosr_ae + r_rmcanopy\n\nand\n\nq_rmcanopy air =  fracr_aeq_rmleaves + (r_rmcanopy+ r_rmstomata) q_rmatmosr_ae + r_rmcanopy+r_rmstomata\n\n","category":"section"},{"location":"standalone/pages/vegetation/turbulent_fluxes/turbulent_fluxes/#Canopy-Fluxes","page":"Physics","title":"Canopy Fluxes","text":"Plugging the canopy air properties into the flux equations allows us to write the fluxes between the canopy and the atmosphere as:\n\nH  = -rho_rmatmos fracT_rmatmos - T_rmleavesr_ae+ r_rmcanopy\n\nand\n\nT  = -rho_rmatmos fracq_rmatmos - q_rmleavesr_ae + r_rmcanopy+ r_rmstomata","category":"section"},{"location":"standalone/pages/vegetation/turbulent_fluxes/turbulent_fluxes/#Roughness-lengths-and-displacement-height","page":"Physics","title":"Roughness lengths and displacement height","text":"The roughness lengths and displacement height are currently computed as linear in the canopy height, with adjustable slope and intercept.\n\n","category":"section"},{"location":"standalone/pages/vegetation/turbulent_fluxes/turbulent_fluxes/#Specifying-canopy-resistance","page":"Physics","title":"Specifying canopy resistance","text":"The leaf level resistance is currently computed as the inverse of an adjustable constant drag coefficient multiplied by the friction velocity.\n\n","category":"section"},{"location":"standalone/pages/vegetation/turbulent_fluxes/turbulent_fluxes/#Changing-parameterizations","page":"Physics","title":"Changing parameterizations","text":"Adding a new parameterization for roughness length or displacement heights should be straightforward if they are constant in time; a new method for constructing MoninObukhovCanopyFluxes is all that is required. –-","category":"section"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/#Stomatal-conductance","page":"Medlyn model","title":"Stomatal conductance","text":"Stomata play an important role in uptaking CO2 for photosynthesis while limiting water loss during transpiration. Consequently, an accurate depiction of stomatal conductance is required to study leaf energy fluxes, transpiration, and photosynthesis.\n\nThis section describes multiple models of stomatal conductance implemented in ClimaLand.","category":"section"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/#Medlyn-Model","page":"Medlyn model","title":"Medlyn Model","text":"The Medlyn model is a semiempirical model that relates stomatal conductance and photosynthesis and is derived from water-use efficiency optimization theory.\n\nTranspiration is computed using the stomatal conductance and Monin-Obukhov theory.\n\nbeginequation\nT = -rho_a g_mathrmeff leftq_a- q_v(T_mathrmleaf rho_mathrmsfc) right\nendequation\n\nwhere T is the transpiration (mass flux of water vapor), q_a is the specific humidity at the lowest level of the atmosphere, q_v(T_mathrmT_leaf rho_mathrmsfc) is the saturated specific humidity over liquid water, given the temperature of the leave T_leaf and air density at the surface rho_sfc. We will approximate T_leaf = T_a and rho_mathrmsfc = rho_a.\n\nWe also need the effective conductivity, given by\n\nbeginequation\n    g_mathrmeff = frac1g_mathrmae^-1+g_mathrms^-1\nendequation\n\nwhere g_ae is the aerodynamic conductance, computed by the MOST solve, and g_s is the stomatal conductance to water vapor per unit ground area. The units of all conductances are ms.\n\nThe stomatal conductance is calculated using the Medlyn stomatal conductance model (Medlyn, 2011), while omitting cuticular and epidermal losses by assuming zero minimum stomatal conductance:\n\nbeginalign\ng_sm(PAR T VPD c_a) = g_0m + D_rel times m fracA_n(PAR T VPD c_a)c_anonumber \ng_s = fracg_smrho_m\nendalign\n\nwhere D_rel =16 (unitless) is the relative diffusivity of water vapor with respect to CO_2, rho_m is the molar density of water, and m is the Medlyn factor,\n\nbeginequation\n    m = left( 1 + fracg_1sqrtVPD right)\nendequation\n\nwhere g1 is the slope parameter, inversely proportional to the square root of marginal water use efficiency (Medlyn, 2011). We also have A_n as the biochemical demand for CO_2 calculated using the photosynthesis model (Farquhar, 1980; Equation \\eqref{eq:an}; units of molar flux). The resulting units are ms. g${0,m}$ is a minimum molar conductivity. (subscript m indicates molar).\n\nThe model has the following parameters:\n\nConstants Symbol Unit Value\nRelative diffusivity of water vapor D_rel - 1.6\nMinimum stomatal conductance g_0 mol/m^2/s 1e-4\nSlope parameter g_1 sqrtPa 790","category":"section"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand-Auxiliary-Variables-Cache-Constructors-and-Update-Methods","page":"Auxiliary Variables Cache","title":"ClimaLand Auxiliary Variables Cache Constructors and Update Methods","text":"","category":"section"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.initialize_auxiliary","page":"Auxiliary Variables Cache","title":"ClimaLand.initialize_auxiliary","text":"initialize_auxiliary(model::AbstractModel, state::NamedTuple)\n\nReturns a NamedTuple of auxiliary variables for model with the required structure, with values equal to similar(state). This assumes that all  auxiliary variables are defined over the entire domain, and that all auxiliary variables have the same dimension and type. The auxiliary variables NamedTuple can also hold preallocated objects which are not Fields.\n\nIf a model has no auxiliary variables, the returned NamedTuple contains only an empty array.\n\nThe input state is an array-like object, usually a ClimaCore Field or a Vector{FT}.\n\nAdjustments to this - for example because different auxiliary variables have different dimensions - require defining a new method.\n\n\n\n\n\ninitialize_auxiliary(\n    component::AbstractCanopyComponent,\n    state,\n)\n\nCreates and returns a ClimaCore.Fields.FieldVector with the auxiliary variables of the canopy component  component, stored using the name of the component.\n\nThe input state is usually a ClimaCore Field object.\n\n\n\n\n\ninitialize_auxiliary(\n    model::CanopyModel{FT},\n    coords,\n) where {FT}\n\nCreates the auxiliary state vector of the CanopyModel and returns  it as a ClimaCore.Fields.FieldVector.\n\nThe input coords is usually a ClimaCore Field object.\n\nThis function loops over the components of the CanopyModel and appends each component models auxiliary state vector into a single state vector, structured by component name.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.make_set_initial_cache","page":"Auxiliary Variables Cache","title":"ClimaLand.make_set_initial_cache","text":"make_set_initial_cache(model::AbstractModel)\n\nReturns the set_initial_cache! function, which updates the auxiliary state p in place with the initial values corresponding to Y(t=t0) = Y0.\n\nIn principle, this function is not needed, because in the very first evaluation of either explicit_tendency or implicit_tendency, at t=t0, the auxiliary state is updated using the initial conditions for Y=Y0. However, without setting the initial p state prior to running the simulation, the value of p in the saved output at t=t0 will be unset.\n\nFurthermore, specific methods of this function may be useful for models which store time indepedent spatially varying parameter fields in the auxiliary state. In this case, update_aux! does not need to do anything, but they do need to be set with the initial (constant) values before the simulation can be carried out.\n\n\n\n\n\nmake_set_initial_cache(model::Union{LandModel, SoilCanopyModel})\n\nCreates the function with arguments (p,Y0,t0) that updates the cache p with initial values corresponding to Y0 and t0.\n\nWe require a different method from the default for a model with a canopy, so this method is for any model with type ∈ Union{LandModel, SoilCanopyModel}. This is a close copy of the method for the CanopyModel, except unpacking model.canopy rather than using model directly.\n\n\n\n\n\nClimaLand.make_set_initial_cache(model::CanopyModel)\n\nSet the initial cache p for the canopy model. Note that if the photosynthesis model is the P-model, then set_initial_cache! will also run set_historical_cache! which sets the (t-1) values for Vcmax25opt, Jmax25opt, and ξ_opt.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.make_update_aux","page":"Auxiliary Variables Cache","title":"ClimaLand.make_update_aux","text":"make_update_aux(model::RichardsModel)\n\nAn extension of the function make_update_aux, for the Richardson- Richards equation.\n\nThis function creates and returns a function which updates the auxiliary variables p.soil.variable in place.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_update_aux(model::EnergyHydrology)\n\nAn extension of the function make_update_aux, for the integrated soil hydrology and energy model.\n\nThis function creates and returns a function which updates the auxiliary variables p.soil.variable in place.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_update_aux(model::BucketModel{FT}) where {FT}\n\nCreates the update_aux! function for the BucketModel.\n\n\n\n\n\nmake_update_aux(model::AbstractModel)\n\nReturn an update_aux! function that updates auxiliary parameters p.\n\n\n\n\n\n ClimaLand.make_update_aux(canopy::CanopyModel)\n\nCreates the update_aux! function for the CanopyModel\n\nPlease note that the plant hydraulics model has auxiliary variables that are updated in its prognostic compute_exp_tendency! function. While confusing, this is better for performance as it saves looping over the state vector multiple times.\n\nThe other sub-components rely heavily on each other, so the version of the CanopyModel with these subcomponents has a single update_aux! function, given here.\n\n\n\n\n\nmake_update_aux(model::SoilCO2Model)\n\nAn extension of the function make_update_aux, for the soilco2 equation. This function creates and returns a function which updates the auxiliary variables p.soil.variable in place. This has been written so as to work with Differential Equations.jl.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.auxiliary_vars","page":"Auxiliary Variables Cache","title":"ClimaLand.auxiliary_vars","text":"auxiliary_vars(soil::RichardsModel)\n\nA function which returns the names of the auxiliary variables of RichardsModel.\n\n\n\n\n\nauxiliary_vars(soil::EnergyHydrology)\n\nA function which returns the names of the auxiliary variables of EnergyHydrology.\n\n\n\n\n\nauxiliary_vars(::SnowModel)\n\nReturns the auxiliary variable names for the snow model. These include\n\nthe specific humidity at the surface of the snow (q_sfc, unitless),\nthe mass fraction in liquid water (q_l, unitless),\nthe thermal conductivity (κ, W/m/K),\nthe bulk temperature (T, K),\nthe surface temperature (T_sfc, K),\nthe snow depth (z_snow, m),\nthe bulk snow density (ρ_snow, kg/m^3)\nthe SHF, LHF, and vapor flux (turbulent_fluxes.shf, etc),\nthe net radiation (R_n, J/m^2/s),\nthe energy flux in liquid water runoff (energy_runoff, J/m^2/s),\nthe water volume in runoff (water_runoff, m/s),\n\nand the total energy and water fluxes applied to the snowpack.\n\nSince the snow can melt completely in one timestep, we clip the water and energy fluxes such that SWE cannot become negative and U cannot become unphysical. The clipped values are what are actually applied as boundary fluxes, and are stored in applied_ fluxes.\n\n\n\n\n\nauxiliary_vars(m::AbstractModel)\n\nReturns the auxiliary variable symbols for the model in the form of a tuple.\n\n\n\n\n\nClimaLand.auxiliary_vars(::AbstractCanopyComponent)\n\nReturns the auxiliary types of the canopy component passed in as an argument.\n\n\n\n\n\nClimaLand.auxiliary_vars(model::PModel)\nClimaLand.auxiliary_types(model::PModel)\nClimaLand.auxiliary_domain_names(model::PModel)\n\nDefines the auxiliary vars of the Pmode: canopy level net photosynthesis,  canopy-level gross photosynthesis (GPP), and dark respiration at the canopy level (Rd), and\n\nOptVars: a NamedTuple with keys :ξ_opt, :Vcmax25_opt, and :Jmax25_opt   containing the acclimated optimal values of ξ, Vcmax25, and Jmax25, respectively. These are updated   using an exponential moving average (EMA) at local noon.\n\n\n\n\n\nauxiliary_vars(canopy::CanopyModel)\n\nReturns the auxiliary variables for the canopy model by looping over each sub-component name in canopy_components.\n\nThis relies on the propertynames of CanopyModel being the same as those returned by canopy_components.\n\n\n\n\n\nauxiliary_vars(model::PlantHydraulicsModel)\n\nA function which returns the names of the auxiliary variables of the PlantHydraulicsModel, the water potential ψ (m), the volume flux*\\cross section fa (1/s), and the volume flux*root cross section in the roots fa_roots (1/s), where the cross section can be represented by an area index.\n\nThe water potential ψ is of length n, where n is the number of compartments, and fa is of length n-1. If n=1, fa is not included. fa_roots is a scalar, the bottom boundary flux.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.auxiliary_types","page":"Auxiliary Variables Cache","title":"ClimaLand.auxiliary_types","text":"auxiliary_types(soil::RichardsModel)\n\nA function which returns the names of the auxiliary types of RichardsModel.\n\n\n\n\n\nauxiliary_types(soil::EnergyHydrology{FT}) where {FT}\n\nA function which returns the types of the auxiliary variables of EnergyHydrology.\n\n\n\n\n\nauxiliary_types(m::AbstractModel{FT}) where {FT}\n\nReturns the auxiliary variable types for the model in the form of a tuple.\n\nTypes provided must have ClimaCore.RecursiveApply.rzero(T::DataType) defined. Common examples include\n\nFloat64, Float32 for scalar variables (a scalar value at each\n\ncoordinate point)\n\nSVector{k,Float64} for a mutable but statically sized array of\n\nlength k at each coordinate point.\n\nNote that Arrays, MVectors are not isbits and cannot be used.\n\nHere, the coordinate points are those returned by coordinates(model).\n\n\n\n\n\nClimaLand.auxiliary_types(::AbstractCanopyComponent)\n\nReturns the auxiliary types of the canopy component passed in as an argument.\n\n\n\n\n\nauxiliary_types(canopy::CanopyModel)\n\nReturns the auxiliary types for the canopy model by looping over each sub-component name in canopy_components.\n\nThis relies on the propertynames of CanopyModel being the same as those returned by canopy_components.\n\n\n\n\n\nClimaLand.auxiliary_types(model::PlantHydraulicsModel{FT}) where {FT}\n\nDefines the auxiliary types for the PlantHydraulicsModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.auxiliary_domain_names","page":"Auxiliary Variables Cache","title":"ClimaLand.auxiliary_domain_names","text":"auxiliary_domain_names(soil::RichardsModel)\n\nA function which returns the names of the auxiliary domain names of RichardsModel.\n\n\n\n\n\nauxiliary_domain_names(m::AbstractModel)\n\nReturns the domain names for the auxiliary variables in the form of a tuple.\n\nExamples: (:surface, :surface, :subsurface).\n\n\n\n\n\nauxiliary_domain_names(m::AbstractCanopyComponent)\n\nReturns the domain names for the auxiliary variables in the form of a tuple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.make_update_cache","page":"Auxiliary Variables Cache","title":"ClimaLand.make_update_cache","text":" make_update_cache(model::AbstractModel)\n\nA helper function which updates all cache variables of a model; currently only used in set_initial_cache since not all cache variables are updated at the same time.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.diffusive_flux","page":"Auxiliary Variables Cache","title":"ClimaLand.diffusive_flux","text":"diffusive_flux(K, x_2, x_1, Δz)\n\nCalculates the diffusive flux of a quantity x (water content, temp, etc). Here, x2 = x(z + Δz) and x1 = x(z), so x_2 is at a larger z by convention.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.boundary_flux!","page":"Auxiliary Variables Cache","title":"ClimaLand.boundary_flux!","text":"boundary_flux!(bc_field, bc::WaterFluxBC,  _...)\n\nA method of boundary fluxes which updates the desired flux.\n\n\n\n\n\nboundary_flux!(bc_field, bc::RichardsAtmosDrivenFluxBC,\n                       boundary::ClimaLand.AbstractBoundary,\n                       model::RichardsModel{FT},\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       ) where {FT}\n\nA method of boundary fluxes which returns the desired water volume flux for the RichardsModel, at the top of the domain, in the case of a prescribed precipitation flux.\n\nIf model.runoff is not of type NoRunoff, surface runoff is accounted for when computing the infiltration.\n\n\n\n\n\nboundary_flux!(bc_field, rre_bc::MoistureStateBC,\n                       ::ClimaLand.TopBoundary,\n                       model::AbstractSoilModel,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       )\n\nA method of boundary fluxes which converts a state boundary condition on θ_l at the top of the domain into a flux of liquid water.\n\n\n\n\n\nboundary_flux!(bc_field, rre_bc::MoistureStateBC,\n                       ::ClimaLand.BottomBoundary,\n                       model::AbstractSoilModel,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       )\n\nA method of boundary fluxes which converts a state boundary condition on θ_l at the bottom of the domain into a flux of liquid water.\n\n\n\n\n\nboundary_flux!(bc_field, bc::FreeDrainage,\n                       boundary::ClimaLand.BottomBoundary,\n                       model::AbstractSoilModel,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       )\n\nA method of boundary fluxes which enforces free drainage at the bottom of the domain.\n\n\n\n\n\nboundary_flux!(bc_field, bc::HeatFluxBC,  _...)\n\nA method of boundary fluxes which updates the desired flux.\n\n\n\n\n\nboundary_flux!(bc_field, heat_bc::TemperatureStateBC,\n                       ::ClimaLand.TopBoundary,\n                       model::EnergyHydrology,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       ):\n\nA method of boundary fluxes which converts a state boundary condition on temperature at the top of the domain into a flux of energy.\n\n\n\n\n\nboundary_flux!(bc_field, heat_bc::TemperatureStateBC,\n                       ::ClimaLand.BottomBoundary,\n                       model::EnergyHydrology,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       )\n\nA method of boundary fluxes which converts a state boundary condition on temperature at the bottom of the domain into a flux of energy.\n\n\n\n\n\nboundary_flux!(bc_field, bc::AbstractBC, bound_type::AbstractBoundary, Δz, _...)\n\nA function which updates bc_field with the correct boundary flux  given any boundary condition (BC). \n\n\n\n\n\nfunction ClimaLand.boundary_flux!(bc_field,\n    bc::RunoffBC,\n    ::TopBoundary,\n    model::Soil.RichardsModel,\n    Δz::FT,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n    params,\n)\n\nExtension of the ClimaLand.boundary_flux function, which returns the water volume boundary flux for the soil. At the top boundary, return the soil infiltration (computed each step and stored in p.soil_infiltration).\n\n\n\n\n\nClimaLand.boundary_flux!(bc_field,\n    bc::SoilCO2FluxBC,\n    boundary::ClimaLand.AbstractBoundary,\n    Δz::ClimaCore.Fields.Field,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nA method of ClimaLand.boundary_flux which updates the soilco2 flux (kg CO2 /m^2/s) in the case of a prescribed flux BC at either the top or bottom of the domain.\n\n\n\n\n\nClimaLand.boundary_flux!(bc_field,\nbc::SoilCO2StateBC,\nboundary::ClimaLand.TopBoundary,\nΔz::ClimaCore.Fields.Field,\nY::ClimaCore.Fields.FieldVector,\np::NamedTuple,\nt,\n)\n\nA method of ClimaLand.boundary_flux which returns the soilco2 flux in the case of a prescribed state BC at  top of the domain.\n\n\n\n\n\nClimaLand.boundary_flux!(bc_field,\n    bc::SoilCO2StateBC,\n    boundary::ClimaLand.BottomBoundary,\n    Δz::ClimaCore.Fields.Field,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nA method of ClimaLand.boundary_flux which returns the soilco2 flux in the case of a prescribed state BC at bottom of the domain.\n\n\n\n\n\nClimaLand.boundary_flux!(bc_field,\nbc::AtmosCO2StateBC,\nboundary::ClimaLand.TopBoundary,\nΔz::ClimaCore.Fields.Field,\nY::ClimaCore.Fields.FieldVector,\np::NamedTuple,\nt,\n)\n\nA method of ClimaLand.boundary_flux which returns the soilco2 flux in the case when the atmospheric CO2 is ued at top of the domain.\n\n\n\n\n\nClimaLand.boundary_flux!(bc_field,\nbc::AtmosO2StateBC,\nboundary::ClimaLand.TopBoundary,\nΔz::ClimaCore.Fields.Field,\nY::ClimaCore.Fields.FieldVector,\np::NamedTuple,\nt,\n)\n\nA method of ClimaLand.boundary_flux which returns the O2 diffusive flux in the case when the atmospheric O2 (0.21 volumetric fraction) is used at top of the domain.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.set_dfluxBCdY!","page":"Auxiliary Variables Cache","title":"ClimaLand.set_dfluxBCdY!","text":"ClimaLand.set_dfluxBCdY!(\n    model::RichardsModel,\n    ::MoistureStateBC,\n    boundary::ClimaLand.TopBoundary,\n    Δz,\n    Y,\n    p,\n    t,\n\n)\n\nComputes the derivative of the flux in the top layer (due to the boundary condition), with respect to the state variable in the top layer. This value is then updated in-place in the cache.\n\nFor Richards equation (a diffusion equation with a single state variable), this is given by ∂F_bc/∂Y_N= -K_N (∂ψ_bc/∂ϑ_N) / Δz, where N indicates the top layer cell index and ψ_bc is the pressure head at the boundary condition.\n\n\n\n\n\nset_dfluxBCdY!(::AbstractModel,\n              ::AbstractBC,\n              ::AbstractBoundary,\n              _...)::Union{ClimaCore.Fields.FieldVector, Nothing}\n\nA function stub which returns the derivative of the implicit tendency term of the model arising from the boundary condition, with respect to the state Y.\n\n\n\n\n\n","category":"function"},{"location":"APIs/AuxiliaryVariablesCache/#ClimaLand.make_update_boundary_fluxes","page":"Auxiliary Variables Cache","title":"ClimaLand.make_update_boundary_fluxes","text":"make_update_boundary_fluxes(model::AbstractModel)\n\nReturn an update_boundary_fluxes! function that updates the auxiliary parameters in p corresponding to boundary fluxes or interactions between componets..\n\n\n\n\n\nmake_update_boundary_fluxes(\n    land::LandHydrology{FT, SM, SW},\n) where {FT, SM <: Soil.RichardsModel{FT}, SW <: Pond.PondModel{FT}}\n\nA method which makes a function; the returned function updates the auxiliary variable p.soil_infiltration, which is needed for both the boundary condition for the soil model and the source term (runoff) for the surface water model.\n\nThis function is called each ode function evaluation.\n\n\n\n\n\nmake_update_boundary_fluxes(\n    land::SoilCanopyModel{FT, MM, SM, RM},\n) where {\n    FT,\n    MM <: Soil.Biogeochemistry.SoilCO2Model{FT},\n    SM <: Soil.RichardsModel{FT},\n    RM <: Canopy.CanopyModel{FT}\n    }\n\nA method which makes a function; the returned function updates the additional auxiliary variables for the integrated model, as well as updates the boundary auxiliary variables for all component models.\n\nThis function is called each ode function evaluation, prior to the tendency function evaluation.\n\n\n\n\n\nmake_update_boundary_fluxes(\n    land::SoilSnowModel{FT, SnM, SoM},\n) where {\n    FT,\n    SnM <: Snow.SnowModel{FT},\n    SoM <: Soil.EnergyHydrology{FT},\n    }\n\nA method which makes a function; the returned function updates the additional auxiliary variables for the integrated model, as well as updates the boundary auxiliary variables for all component models.\n\nThis function is called each ode function evaluation, prior to the tendency function evaluation.\n\nIn this method, we\n\nCompute the ground heat flux between soil and snow. This is required to update the snow and soil boundary fluxes\nUpdate the snow boundary fluxes, which also computes any excess flux of energy or water which occurs when the snow\n\ncompletely melts in a step. In this case, that excess must go to the soil for conservation\n\nUpdate the soil boundary fluxes use precomputed ground heat flux and excess fluxes from snow.\nCompute the net flux for the atmosphere, which is useful for assessing conservation.\n\n\n\n\n\nmake_update_boundary_fluxes(\n    land::LandModel{FT, MM, SM, RM, SnM},\n) where {\n    FT,\n    MM <: Soil.Biogeochemistry.SoilCO2Model{FT},\n    SM <: Soil.RichardsModel{FT},\n    RM <: Canopy.CanopyModel{FT}\n    SnM <: Snow.SnowModel{FT}\n    }\n\nA method which makes a function; the returned function updates the additional auxiliary variables for the integrated model, as well as updates the boundary auxiliary variables for all component models.\n\nThis function is called each ode function evaluation, prior to the tendency function evaluation.\n\n\n\n\n\n","category":"function"},{"location":"generated/integrated/handling_soil_fluxes/#Background","page":"Adjusting boundary conditions for the soil","title":"Background","text":"When solving the partial differential equations describing the storage of water, ice, and energy in soil, boundary conditions must be set for the soil liquid water and energy. The tutorial on boundary conditions for the soil model describes the various boundary condition options we currently support. Many of these are suitable for use when replicating laboratory experiments or other standalone soil settings - for example, a particular experiment may fix the temperature or water content at the top of a soil column. However, when we wish to model the soil interacting with the atmosphere, in standalone or integrated models, the particular boundary condition we use is one that computes the sensible, latent, and radiative fluxes in addition to evaporation and sublimation; this option is called the AtmosDrivenFluxBC. This boundary condition type includes the atmospheric and radiative forcings, the runoff parameterization, and finally, a Tuple which indicates which components of the land are present. The last argument is what we will describe here. For more information on how to supply the prescribed forcing data, please see the tutorial linked here.","category":"section"},{"location":"generated/integrated/handling_soil_fluxes/#Adjusting-the-boundary-conditions-for-the-soil-model-when-run-as-part-of-an-integrated-land-model","page":"Adjusting boundary conditions for the soil","title":"Adjusting the boundary conditions for the soil model when run as part of an integrated land model","text":"The presence of other land components (a canopy, snow) affects the boundary conditions of the soil and changes them relative to what they would be if only bare soil was interacting with the atmosphere. For example, the canopy and snow absorb radiation that might otherwise be absorbed by the soil, the canopy intercepts precipitation, and the snow can melt and contribute to soil infiltration. Because of this, we need a way to indicate to the soil model that the boundary conditions must be computed in a different way. In all cases, the same AtmosDrivenFluxBC is used with the exception of the field prognostic_land_components, which is a Tuple of the symbols associated with each component in the land model. For example, if you are simulating the soil model in standalone mode, you would set\n\nprognostic_land_components = (:soil,)\n\ntop_soil_boundary_condition = ClimaLand.Soil.AtmosDrivenFluxBC(atmos_forcing, radiative_forcing, runoff_parameterization, prognostic_land_components)\n\nwhile, if you are simulating both a prognostic canopy and soil model, you would set\n\nprognostic_land_components = (:canopy, :soil)\n\ntop_soil_boundary_condition = ClimaLand.Soil.AtmosDrivenFluxBC(atmos_forcing, radiative_forcing, runoff_parameterization, prognostic_land_components)\n\nNote that the land components are always in alphabetical order, and the symbols associated with each land model component are always the same as the name of that component, i.e.,\n\nClimaLand.name(snow_model) = :snow\n\nClimaLand.name(canopy_model) = :canopy\n\nClimaLand.name(soilco2_model) = :soilco2\n\nClimaLand.name(soil_model) = :soil\n\nCurrently, the only supported options are: (:soil,), (:canopy, :soil, :soilco2), (:snow, :soil).","category":"section"},{"location":"generated/integrated/handling_soil_fluxes/#How-it-works","page":"Adjusting boundary conditions for the soil","title":"How it works","text":"When the soil model updates the boundary conditions, it calls the function soil_boundary_fluxes!(bc, ClimaLand.TopBoundary(), soil_model, Δz_top, Y, p, t), where bc is the boundary condition being used at the top of the domain. This function has multiple methods depending on the boundary condition type typeof(bc). When that type is AtmosDrivenFluxBC, the function then calls soil_boundary_fluxes!(bc, Val(bc.prognostic_land_components), soil, Y, p, t). Again multiple dispatch is used, this time to compute the fluxes correctly according to the value of the prognostic_land_components, i.e., based on which components are present.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"shared_utilities/#ClimaLand-Shared-Utilities","page":"Shared utilities","title":"ClimaLand Shared Utilities","text":"","category":"section"},{"location":"shared_utilities/#State-NaN-Counter-count_nans_state","page":"Shared utilities","title":"State NaN Counter - count_nans_state","text":"We have implemented a function count_nans_state which recursively goes through the entire state and displays the number of NaNs found for each state variable. This function is intended to be used to debug simulations to determine quantitatively if a simulation is stable.\n\nIf NaNs are found for a particular variable, this will be displayed via a warning printed to the console. The verbose argument toggles whether the function prints output when no NaNs are found.\n\nIf a ClimaCore Field is provided as mask, the function will only count NaNs in the state variables where the mask is 1. This is intended to be used with the land/sea mask, to avoid counting NaNs over the ocean. Note this assumes the mask is 1 over land and 0 over ocean.\n\nThis function does not distinguish between surface or subsurface variables, so a variable defined on the subsurface will display more NaNs than one defined on the surface, even if they are NaN at the same spatial locations in the horizontal.","category":"section"},{"location":"shared_utilities/#Usage-examples","page":"Shared utilities","title":"Usage examples","text":"This function can be used to inspect the state after a simulation finishes running by calling count_nans_state(sol.u[end]).\n\nThis function can be used throughout the duration of a simulation by triggering it via a callback. The NaNCheckCallback is designed for this purpose, and can be set up as follows:\n\nnancheck_interval = Dates.Month(1)\nnancheck_cb = ClimaLand.NaNCheckCallback(nancheck_interval, start_date; dt = Δt)\n\nand then included along with any other callbacks in a SciMLBase.CallbackSet.\n\nPlease see our longrun experiments to see examples of this callback in action!","category":"section"},{"location":"APIs/canopy/PlantFunctionalTypes/#Plant-Functional-Type-(PFT)-Module","page":"Plant Functional Type (PFT) Module","title":"Plant Functional Type (PFT) Module","text":"","category":"section"},{"location":"APIs/canopy/PlantFunctionalTypes/#Types","page":"Plant Functional Type (PFT) Module","title":"Types","text":"","category":"section"},{"location":"APIs/canopy/PlantFunctionalTypes/#Methods","page":"Plant Functional Type (PFT) Module","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/PlantFunctionalTypes/#ClimaLand.Canopy.Pft","page":"Plant Functional Type (PFT) Module","title":"ClimaLand.Canopy.Pft","text":"Define a PFT type that can be used to store the parameters for each PFT. Each PFT has a name and a list of parameters. The parameters are stored as NamedTuples mapping parameter names to values. The inner constructor checks to ensure all required parameters are defined for the PFT.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantFunctionalTypes/#ClimaLand.Canopy.default_pfts","page":"Plant Functional Type (PFT) Module","title":"ClimaLand.Canopy.default_pfts","text":"default_pfts\n\nLists of defaults to pass to params_from_pfts.\n\n\n\n\n\n","category":"constant"},{"location":"APIs/canopy/PlantFunctionalTypes/#ClimaLand.Canopy.params_from_pfts","page":"Plant Functional Type (PFT) Module","title":"ClimaLand.Canopy.params_from_pfts","text":"params_from_pfts(pft_cover::Vector{Float64},\n                 pfts::Vector{Pft} = default_pfts\n                )\n\nTakes in a vector of PFT cover percentages and returns the correct parameter set corresponding to the most dominant PFT by cover percentage.\n\nMay optionally take in a vector of PFTs to use instead of the default PFTs. In this case, the pfts_cover vector must be the same length and in the corresponding order to the PFTs in the pfts vector. This allows a user to define their own PFT scheme and plug it into the model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantFunctionalTypes/#ClimaLand.Canopy.pft_param_list","page":"Plant Functional Type (PFT) Module","title":"ClimaLand.Canopy.pft_param_list","text":"pft_param_list\n\nList of parameters that PFTs need to define in order to be valid.\n\n\n\n\n\n","category":"constant"},{"location":"generated/integrated/handling_snow_fluxes/#Background","page":"Adjusting boundary conditions for the snow","title":"Background","text":"When solving the system of equations describing the storage of water and energy in snow, \"boundary conditions\" must be set. These are only true boundary conditions if one considers the equations for water and energy in snow to be discretized PDEs, but they do represent the fluxes at upper boundary (the snow/atmosphere interface) and at the lower boundary (the snow/soil interface), so we refer to them as boundary conditions in order to use a consistent notation with the soil model.\n\nAt present, the only type of boundary condition the snow model supports is AtmosDrivenSnowBC, which is an attempt at a compact way of indicating that with this choice, the snow model exchanges water and energy with the atmosphere via sensible, latent, and radiative heat fluxes, and by precipitation and sublimation/evaporation. With this choice, the snow model also has exchange fluxes with the soil (melt water, and a conductive ground heat flux). This boundary condition type includes the atmospheric and radiative forcings, and, importantly, a Tuple which indicates which components of the land are present. The last argument is what we will describe here. For more information on how to supply the prescribed forcing data, please see the tutorial linked here. For an explanation of the same design implementation for the Soil model, please see here.","category":"section"},{"location":"generated/integrated/handling_snow_fluxes/#Adjusting-the-boundary-conditions-for-the-snow-model-when-run-as-part-of-an-integrated-land-model","page":"Adjusting boundary conditions for the snow","title":"Adjusting the boundary conditions for the snow model when run as part of an integrated land model","text":"The presence of other land components (a canopy, the soil) affects the boundary conditions of the snow and changes them relative to what they would be if only bare snow was interacting with the atmosphere. For example, the canopy absorbs radiation that might otherwise be absorbed by the snow, the canopy intercepts precipitation, and the soil and snow interact thermally at the interface between them. Because of this, we need a way to indicate to the snow model that the boundary conditions must be computed in a different way depending on the components. We do this via the field in the boundary condition of type AtmosDrivenSnowBC via a field prognostic_land_components, which is a Tuple of the symbols associated with each component in the land model. For example, if you are simulating the snow model in standalone mode, you would set\n\nprognostic_land_components = (:snow,)\n\nboundary_condition = ClimaLand.Snow.AtmosDrivenSnowBC(atmos_forcing, radiative_forcing, prognostic_land_components)\n\nwhile, if you are simulating both a prognostic snow and soil model, you would set\n\nprognostic_land_components = (:snow, :soil)\n\nboundary_condition = ClimaLand.Snow.AtmosDrivenSnowBC(atmos_forcing, radiative_forcing, prognostic_land_components)\n\nNote that the land components are always in alphabetical order, and the symbols associated with each land model component are always the same as the name of that component, i.e.,\n\nClimaLand.name(snow_model) = :snow\n\nClimaLand.name(canopy_model) = :canopy\n\nClimaLand.name(soilco2_model) = :soilco2\n\nClimaLand.name(soil_model) = :soil\n\nCurrently, the only supported options are: (:snow,), and (:snow, :soil).","category":"section"},{"location":"generated/integrated/handling_snow_fluxes/#How-it-works","page":"Adjusting boundary conditions for the snow","title":"How it works","text":"When the snow model computes its boundary fluxes, it calls the function snow_boundary_fluxes!(bc, snow_model, Y, p, t), where bc is the boundary condition of type AtmosDrivenSnowBC. This function then calls snow_boundary_fluxes!(bc, Val(bc.prognostic_land_components), snow, Y, p, t). Here multiple dispatch is used to compute the fluxes correctly according to the value of the prognostic_land_components, i.e., based on which components are present.","category":"section"},{"location":"generated/integrated/handling_snow_fluxes/#Some-important-notes","page":"Adjusting boundary conditions for the snow","title":"Some important notes","text":"When the snow model is run in standalone mode (prognostic_land_components = (:snow,)), the ground heat flux is approximate as zero. When the soil and snow model are run together, this flux is computed and affects both the snow and soil.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"standalone/README/#DynamicDocs","page":"DynamicDocs","title":"DynamicDocs","text":"","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Soil-Biogeochemistry:-CO-Production-and-O-Consumption","page":"DAMM model","title":"Soil Biogeochemistry: CO₂ Production and O₂ Consumption","text":"This section describes the coupled soil biogeochemistry model implemented in ClimaLand, which simulates the production and diffusion of CO₂, consumption of O₂, and decomposition of soil organic carbon (SOC) through microbial respiration. The model combines the Dual Arrhenius and Michaelis-Menten (DAMM) kinetics framework for microbial respiration with gas diffusion equations that account for soil structure, temperature, and moisture dependencies.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Model-Overview","page":"DAMM model","title":"Model Overview","text":"The biogeochemistry model tracks three prognostic variables that evolve in space (with soil depth) and time:\n\nCO₂ concentration in soil air (ρ_CO_2, kg C m⁻³)\nVolumetric O₂ fraction in soil air (O_2f, dimensionless)\nSoil organic carbon (C_som, kg C m⁻³)\n\nThe model captures the fundamental processes of aerobic decomposition: microbes consume soil organic carbon and oxygen to produce carbon dioxide. These gases diffuse through the soil pore space, with diffusion rates controlled by soil structure (porosity, tortuosity), moisture content, and temperature.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Governing-Equations","page":"DAMM model","title":"Governing Equations","text":"","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#CO-Transport-and-Production","page":"DAMM model","title":"CO₂ Transport and Production","text":"The evolution of CO₂ concentration in the soil follows a reaction-diffusion equation:\n\nbeginequation\nfracpartial ρ_CO_2partial t = -nabla cdot left-D nabla ρ_CO_2right + S_m\nendequation\n\nwhere ρ_CO_2 is the CO₂ concentration (kg C m⁻³), D is the effective diffusivity of CO₂ in soil (m² s⁻¹), and S_m is the microbial CO₂ production rate (kg C m⁻³ s⁻¹). The diffusive flux is -Dnabla ρ_CO_2, directed from regions of high to low concentration.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#O-Transport-and-Consumption","page":"DAMM model","title":"O₂ Transport and Consumption","text":"Oxygen transport and consumption in soil is described by:\n\nbeginequation\nfracpartial O_2fpartial t = fracR Ttheta_a P M_O_2 nabla cdot leftD_O_2 theta_a nabla rho_O_2right - fracR TM_C theta_a P S_m\nendequation\n\nwhere:\n\nO_2f\nis the volumetric O₂ fraction in air (dimensionless, ~0.21 in atmosphere)\ntheta_a\nis the volumetric air content (m³ air m⁻³ soil)\nrho_O_2\nis the O₂ mass concentration in air (kg O₂ m⁻³ air)\nD_O_2\nis the effective diffusivity of O₂ in soil (m² s⁻¹)\nR\nis the universal gas constant (8.314 J mol⁻¹ K⁻¹)\nT\nis soil temperature (K)\nP\nis atmospheric pressure (Pa)\nM_O_2\nis the molar mass of O₂ (0.032 kg mol⁻¹)\nM_C\nis the molar mass of carbon (0.012 kg mol⁻¹)\n\nThe second term represents O₂ consumption by microbial respiration, following the stoichiometry C + O₂ → CO₂, where each 12 g of carbon respired consumes 32 g of oxygen.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Soil-Organic-Carbon-Dynamics","page":"DAMM model","title":"Soil Organic Carbon Dynamics","text":"The soil organic carbon pool is depleted by microbial decomposition:\n\nbeginequation\nfracpartial C_sompartial t = -S_m\nendequation\n\nwhere C_som is the soil organic carbon content (kg C m⁻³). This equation enforces carbon mass conservation: the rate of SOC consumption equals the rate of CO₂ production.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Microbial-Respiration:-DAMM-Model","page":"DAMM model","title":"Microbial Respiration: DAMM Model","text":"The microbial source term S_m represents heterotrophic respiration and is computed using the Dual Arrhenius and Michaelis-Menten (DAMM) kinetics model Davidson et al. [31]:\n\nbeginequation\nS_m = V_max cdot MM_sx cdot MM_O_2\nendequation\n\nwhere V_max is the maximum potential rate of respiration (temperature-dependent), MM_sx represents substrate availability (0-1, dimensionless), and MM_O_2 is the oxygen limitation factor (0-1, dimensionless).","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Maximum-Respiration-Rate","page":"DAMM model","title":"Maximum Respiration Rate","text":"The maximum potential respiration rate follows Arrhenius kinetics:\n\nbeginequation\nV_max = alpha_sx expleft(frac-Ea_sxRTright)\nendequation\n\nwhere alpha_sx is the pre-exponential factor (kg C m⁻³ s⁻¹), Ea_sx is the activation energy (J mol⁻¹), R is the gas constant, and T is soil temperature (K). This formulation captures the exponential increase in microbial activity with temperature.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Substrate-Availability","page":"DAMM model","title":"Substrate Availability","text":"The concentration of soluble carbon substrates available to microbes depends on diffusion through soil water films:\n\nbeginequation\nS_x = p_sx cdot C_som cdot D_liq cdot theta_l^3\nendequation\n\nwhere:\n\nS_x\nis the concentration of soluble substrate (kg C m⁻³)\np_sx\nis the fraction of SOC that is soluble (dimensionless)\nC_som\nis the total soil organic carbon (kg C m⁻³)\nD_liq\nis the diffusion coefficient of soluble carbon (dimensionless)\ntheta_l\nis the volumetric liquid water content (m³ m⁻³)\n\nThe cubic dependence on moisture (theta_l^3) reflects the strong constraint that water films place on substrate diffusion to microbes.\n\nThe substrate limitation factor follows Michaelis-Menten kinetics:\n\nbeginequation\nMM_sx = fracS_xkM_sx + S_x\nendequation\n\nwhere kM_sx is the Michaelis constant for substrate (kg C m⁻³).","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Oxygen-Availability","page":"DAMM model","title":"Oxygen Availability","text":"The oxygen availability for microbial respiration accounts for diffusion limitations in porous media using a tortuosity model:\n\nbeginequation\nO_2avail = D_oa cdot O_2f cdot theta_a^43\nendequation\n\nwhere:\n\nO_2avail\nis the dimensionless O₂ availability metric\nD_oa\nis the oxygen diffusion coefficient in air (dimensionless)\nO_2f\nis the volumetric O₂ fraction in air\ntheta_a^43\nis the Millington-Quirk tortuosity factor\n\nThe exponent 4/3 captures how tortuous diffusion pathways limit gas transport in partially saturated porous media.\n\nThe oxygen limitation factor follows Michaelis-Menten kinetics:\n\nbeginequation\nMM_O_2 = fracO_2availkM_O_2 + O_2avail\nendequation\n\nwhere kM_O_2 is the Michaelis constant for oxygen (dimensionless).","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Gas-Diffusivity-in-Soil","page":"DAMM model","title":"Gas Diffusivity in Soil","text":"","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#CO-and-O-Diffusivity","page":"DAMM model","title":"CO₂ and O₂ Diffusivity","text":"Both CO₂ and O₂ diffusivity in soil are computed using the same parameterization Ryan et al. [32], which accounts for temperature, pressure, and soil moisture effects:\n\nbeginequation\nD = D_0 cdot (2theta_a100^3 + 004theta_a100) cdot left(fractheta_atheta_a100right)^2 + 3b\nendequation\n\nwhere:\n\nD\nis the effective diffusivity in soil (m² s⁻¹)\ntheta_a\nis the volumetric air content (m³ m⁻³)\ntheta_a100\nis the air-filled porosity at soil water potential of -100 cm H₂O (dimensionless)\nb\nis the pore size distribution parameter (dimensionless)\n\nThe reference diffusivity D_0 depends on temperature and pressure:\n\nbeginequation\nD_0 = D_ref left(fracTT_refright)^175 left(fracP_refPright)\nendequation\n\nwhere D_ref is the diffusion coefficient at standard conditions (m² s⁻¹), T_ref = 273 K, P_ref = 101325 Pa, T is soil temperature (K), and P is atmospheric pressure (Pa). The temperature dependence (exponent 1.75) reflects increased molecular kinetic energy, while the pressure dependence accounts for changes in gas density.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Volumetric-Air-Content","page":"DAMM model","title":"Volumetric Air Content","text":"The volumetric air content is computed as:\n\nbeginequation\ntheta_a = max(nu - theta_l 0)\nendequation\n\nwhere nu is the total soil porosity (m³ m⁻³) and theta_l is the volumetric liquid water content (m³ m⁻³). This simple relationship reflects that air fills the pore space not occupied by water.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#O-Concentration-Conversions","page":"DAMM model","title":"O₂ Concentration Conversions","text":"","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#From-Volumetric-Fraction-to-Mass-Concentration","page":"DAMM model","title":"From Volumetric Fraction to Mass Concentration","text":"The O₂ mass concentration in air is computed from the volumetric fraction using the ideal gas law:\n\nbeginequation\nrho_O_2 = O_2f fracP cdot M_O_2R cdot T\nendequation\n\nwhere rho_O_2 is the O₂ mass concentration in air (kg O₂ m⁻³ air), O_2f is the volumetric O₂ fraction, P is pressure (Pa), M_O_2 is the molar mass of O₂ (0.032 kg mol⁻¹), R is the gas constant (8.314 J mol⁻¹ K⁻¹), and T is temperature (K).","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#From-Mass-Concentration-to-Volumetric-Fraction","page":"DAMM model","title":"From Mass Concentration to Volumetric Fraction","text":"The inverse transformation is:\n\nbeginequation\nO_2f = rho_O_2 fracR cdot TP cdot M_O_2\nendequation\n\nThese conversions are necessary because diffusion is most naturally expressed in terms of mass concentration gradients, while the prognostic variable (O_2f) and the microbial kinetics use volumetric fractions.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Boundary-Conditions","page":"DAMM model","title":"Boundary Conditions","text":"","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#CO-Boundary-Conditions","page":"DAMM model","title":"CO₂ Boundary Conditions","text":"At the top boundary (soil-atmosphere interface), the model uses a diffusive flux condition with atmospheric CO₂ concentration:\n\nbeginequation\nF_CO_2top = -D fracρ_CO_2atm - ρ_CO_2topDelta z_top\nendequation\n\nwhere ρ_CO_2atm is the atmospheric CO₂ concentration (kg C m⁻³), ρ_CO_2top is the CO₂ concentration at the top soil layer, and Delta z_top is the distance from the top layer center to the surface.\n\nAt the bottom boundary, a no-flux condition is typically applied: F_CO_2bottom = 0.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#O-Boundary-Conditions","page":"DAMM model","title":"O₂ Boundary Conditions","text":"At the top boundary, atmospheric O₂ (volumetric fraction of 0.21) is used:\n\nbeginequation\nF_O_2top = -D_O_2 theta_atop fracrho_O_2atm - rho_O_2topDelta z_top\nendequation\n\nwhere rho_O_2atm is computed from O_2f = 021 using the ideal gas law.\n\nAt the bottom boundary, a no-flux condition is typically applied: F_O_2bottom = 0.","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Summary-Tables","page":"DAMM model","title":"Summary Tables","text":"","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Model-Outputs","page":"DAMM model","title":"Model Outputs","text":"Output Symbol Unit Description\nCO₂ concentration ρ_CO_2 kg C m⁻³ CO₂ in soil air\nO₂ volumetric fraction O_2f dimensionless O₂ fraction in soil air\nSoil organic carbon C_som kg C m⁻³ Total SOC pool\nMicrobial respiration S_m kg C m⁻³ s⁻¹ CO₂ production rate","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Drivers","page":"DAMM model","title":"Drivers","text":"Driver Symbol Unit Range Description\nSoil temperature T K 250-320 Controls respiration and diffusion\nVolumetric liquid water theta_l m³ m⁻³ 0.0-0.6 Controls substrate diffusion\nAtmospheric pressure P Pa 80000-105000 Affects gas diffusion\nAtmospheric CO₂ ρ_CO_2atm kg C m⁻³ - Top boundary condition","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Parameters","page":"DAMM model","title":"Parameters","text":"Parameter Symbol Unit Typical Range Description\nSoil porosity nu m³ m⁻³ 0.3-0.6 Total pore space\nPre-exponential factor alpha_sx kg C m⁻³ s⁻¹ 100e3-300e3 DAMM kinetics\nActivation energy Ea_sx J mol⁻¹ 50e3-70e3 Temperature sensitivity\nSubstrate Michaelis constant kM_sx kg C m⁻³ 1e-10-0.1 Half-saturation for substrate\nO₂ Michaelis constant kM_O_2 dimensionless 1e-10-0.1 Half-saturation for O₂\nSoluble SOC fraction p_sx dimensionless 0.005-0.5 Fraction of SOC available\nPore size distribution b dimensionless 2-12 Soil texture parameter\nAir content at -100 cm H₂O theta_a100 dimensionless 0.05-0.3 Reference air content","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Constants","page":"DAMM model","title":"Constants","text":"Constant Symbol Unit Value Description\nCO₂ diffusion coefficient (STP) D_ref m² s⁻¹ 1.39e-5 Reference diffusivity\nSoil C substrate diffusivity D_liq dimensionless 3.17 Substrate diffusion\nO₂ diffusion coefficient D_oa dimensionless 1.67 O₂ diffusion in air\nUniversal gas constant R J mol⁻¹ K⁻¹ 8.314 Ideal gas law\nMolar mass of O₂ M_O_2 kg mol⁻¹ 0.032 Oxygen molecular weight\nMolar mass of C M_C kg mol⁻¹ 0.012 Carbon atomic weight\nReference temperature T_ref K 273 Standard conditions\nReference pressure P_ref Pa 101325 Standard conditions","category":"section"},{"location":"standalone/pages/vegetation/solar_induced_fluorescence/lee_model/#Solar-Induced-Fluorescence-(SIF)","page":"Lee model","title":"Solar-Induced Fluorescence (SIF)","text":"","category":"section"},{"location":"standalone/pages/vegetation/solar_induced_fluorescence/lee_model/#Lee-2015-model","page":"Lee model","title":"Lee 2015 model","text":"This page documents Lee 2015 model for the solar-induced fluorescence (SIF) module in ClimaLand, implemented in src/standalone/Vegetation/solar_induced_fluorescence.jl. SIF is computed at a single wavelength (755 nm) and represents the emission from the canopy surface. See Lee et al. [26]. The ClimaLand code page for this model can be found here.\n\n","category":"section"},{"location":"standalone/pages/vegetation/solar_induced_fluorescence/lee_model/#Model-formulation","page":"Lee model","title":"Model formulation","text":"SIF at 755 nm is computed following Lee et al. (2015).\n\nFirst, we compute the dark-adapted heat-loss rate coefficient k_d as\n\nk_d = maxleft(k_dp1(T_c - T_freeze) + k_dp2 k_dminright)\n\nHere, k_dp1 and k_dp2 are parameters for heat loss in dark-adapted conditions (Tol et al. 2014, unitless), k_dmin is the minimum allowed value of k_d, T_c is canopy temperature (K), and T_freeze is the freezing temperature threshold (K).\n\nNext, we define\n\nx = 1 - fracJJ_max\n\nwhere J is the electron transport rate (mol m⁻² s⁻¹) and J_max is the maximum electron transport capacity (mol m⁻² s⁻¹).\n\nThe light-adapted heat-loss rate coefficient k_n is then given by\n\nk_n = (k_np1x - k_np2)x\n\nwhere k_np1 and k_np2 are parameters for light-adapted conditions (Lee et al. 2013, unitless).\n\nThe baseline photochemical yield phi_p0 is computed as\n\nphi_p0 = frack_pmax(k_f + k_p + k_n varepsilon(FT))\n\nwhere k_p is the rate coefficient for photochemical quenching, k_f is the rate coefficient for fluorescence, and varepsilon(FT) denotes the machine epsilon for the floating-point type FT.\n\nThe effective photochemical yield is then\n\nphi_p = fracJJ_maxphi_p0\n\nThe fluorescence yield phi_f is computed as\n\nphi_f = frack_fmax(k_f + k_d + k_n varepsilon(FT))(1 - phi_p)\n\nTo convert from leaf-level fluorescence to observed signal, we compute\n\nkappa = kappa_p1 V_cmax25^leaf times 10^6 + kappa_p2\n\nwhere V_cmax25^leaf is the maximum carboxylation rate at 25 °C (leaf level, mol m⁻² s⁻¹, internally converted to μmol), and kappa_p1 kappa_p2 are slope and intercept parameters from Lee et al. (2015).\n\nThe emitted fluorescence flux is\n\nF = APAR_canopy^moles phi_f\n\nwhere APAR_canopy^moles is the absorbed photosynthetically active radiation by the canopy (mol m⁻² s⁻¹).\n\nFinally, the solar-induced fluorescence at 755 nm is\n\nSIF_755 = fracFmax(kappa varepsilon(FT))\n\nwhere F is the emitted flux and kappa is the conversion factor relating leaf-level to observed fluorescence. SIF_755 is expressed in W m⁻².","category":"section"},{"location":"standalone/pages/vegetation/solar_induced_fluorescence/lee_model/#Model-Parameters","page":"Lee model","title":"Model Parameters","text":"Symbol Description Units Value\nkf Rate coefficient for fluorescence unitless 0.05\nkd_p1 Parameter for heat loss in dark-adapted conditions (Tol et al. 2014) unitless 0.03\nkd_p2 Parameter for heat loss in dark-adapted conditions (Tol et al. 2014) unitless 0.0273\nmin_kd Minimum heat-loss coefficient in dark-adapted conditions (Tol et al. 2014) unitless 0.087\nkn_p1 Parameter for heat loss in light-adapted conditions (Lee et al. 2013) unitless 6.2473\nkn_p2 Parameter for heat loss in light-adapted conditions (Lee et al. 2013) unitless 0.5944\nkp Rate coefficient for photochemical quenching unitless 4.0\nkappa_p1 Slope relating leaf-level to observed fluorescence (Lee et al. 2015) μmol⁻¹ m² s 0.045\nkappa_p2 Intercept relating leaf-level to observed fluorescence (Lee et al. 2015) unitless 7.85","category":"section"},{"location":"generated/integrated/fluxnet_data/#Fluxnet-forcing-data:-LAI,-radiation,-and-atmospheric-variables","page":"Data processing","title":"Fluxnet forcing data: LAI, radiation, and atmospheric variables","text":"In this tutorial, we will demonstrate how we read in forcing data at a Fluxnet site using our ClimaLand infrastructure. To see an example running a simulation at a Fluxnet site, please see the corresponding tutorials for the SoilCanopyModel or LandModel To access the forcing data (LAI from MODIS, SW_d, LW_d, T_air, q_air, P_air, and precipitation from fluxtower data), you first need the the fluxtower site ID. Currently, ClimaLand provides an interface for working with four fluxtower sites; adding support for a much larger set of sites is in progress. The sites we support are Vaira Ranch (US_Var), Missouri Ozark (US-MOz), Niwot Ridge (US-NR1), and Harvard Forest (US-Ha1).\n\nusing Dates\nimport ClimaParams as CP\nusing ClimaLand\nusing ClimaLand.Domains: Column\nimport ClimaLand.Parameters as LP\nusing DelimitedFiles\nusing CairoMakie\nimport ClimaLand.FluxnetSimulations as FluxnetSimulations\n\nDefine the floating point precision desired (64 or 32 bit), and get the parameter set holding constants used across CliMA Models.\n\nconst FT = Float32;\ntoml_dict = LP.create_toml_dict(FT)\n\nParamDict{Float32} with 669 parameters\n\nPick a site ID; convert the dash to an underscore:\n\nsite_ID = \"US-NR1\";\nsite_ID_val = FluxnetSimulations.replace_hyphen(site_ID)\n\n:US_NR1\n\nThe functions we use below use multiple dispatch, treating the siteIDval as a Julia type.\n\nFirst, we need the latitude and longitude of the site. These are used to get the zenith angle as a function of time, and to look up default parameters using the global ClimaLand parameter maps. We also need the offset of the local time of the site in hours from UTC. This is because ClimaLand simulations are carried out in UTC, while the fluxtower data is reported in local time.\n\n(; time_offset, lat, long) =\n    FluxnetSimulations.get_location(FT, Val(site_ID_val))\n\n(time_offset = -7, lat = 40.0329f0, long = -105.5464f0)\n\nClimaLand also needs to know the height at which the atmospheric data was recorded.\n\n(; atmos_h) = FluxnetSimulations.get_fluxtower_height(FT, Val(site_ID_val))\n\n(atmos_h = 21.5f0,)\n\nIt is also useful to know the bounds of the data, in UTC, to use as the start and stop date of the simulation.\n\n(start_date, stop_date) =\n    FluxnetSimulations.get_data_dates(site_ID, time_offset)\n\n(Dates.DateTime(\"2010-01-01T07:15:00\"), Dates.DateTime(\"2011-01-01T06:45:00\"))\n\nNow we can construct the forcing objects. Under the hood, this function finds the local path to the fluxtower data (and downloads it if it is not present) and reads the data in. It then creates two objects, one called atmos, of type PrescibedAtmosphere, and one called radiation, of type PrescribedRadiativeFluxes. These encode the data in interpolating functions which allow us to estimate the forcing at any time during the simulation using linear interpolation across gaps in the data.\n\n(; atmos, radiation) = FluxnetSimulations.prescribed_forcing_fluxnet(\n    site_ID,\n    lat,\n    long,\n    time_offset,\n    atmos_h,\n    start_date,\n    toml_dict,\n    FT,\n);\n\nThe atmosphere object holds the air temperature, pressure, specific humidity, wind speed, and liquid and solid precipitation fluxes. Since many fluxtower sites do not measure the snow and rain fluxes separately, we estimate them internally. This is optional, and by providing the kwarg split_precip = false, you can change the behavior to return all measured precip as a liquid water flux (no snow). The radiation object holds the downwelling short and long wave radiative fluxes. The diffuse fraction is estimated internally using an empirical function, and the zenith angle is computed analytically.\n\nThe simulation time is measured in seconds since the start_date. We can get the atmospheric temperature at the start_date as follows:\n\nsim_time = 0.0\nT = [NaN]\nevaluate!(T, atmos.T, sim_time);\n@show T\n\n1-element Vector{Float64}:\n 261.98999999999995\n\nNote that evaluate! updates T in place. This is important: in our simulations, we allocate memory for the forcing, and then update the values at each step. If we did not do this, the dynamic memory allocation would cause the simulation to be incredibly slow. We can plot the interpolated air temperature for the first day:\n\nsim_times = 0.0:1800.0:86400.0 # one day in seconds\nair_temps = [];\nfor sim_time in sim_times\n    evaluate!(T, atmos.T, sim_time)\n    push!(air_temps, T[1])\nend\nfig = CairoMakie.Figure()\nax = CairoMakie.Axis(\n    fig[1, 1],\n    ylabel = \"Temperature (K)\",\n    xlabel = \"Date\",\n    title = \"Near-surface air temperature at Niwot Ridge\",\n)\nlines!(ax, Second.(sim_times) .+ start_date, air_temps)\nCairoMakie.save(\"air_temp.png\", fig);\n\n(Image: )\n\nWe do something very similar with LAI, but now the data is coming from MODIS. In this case, we use nearest-neighbor interpolatation to move from the gridded MODIS data to the LAI at the latitude and longitude of the site. To do spatial interpolation, we need to create a ClimaLand domain.\n\ndomain =\n    Column(; zlim = (FT(-3.0), FT(0.0)), nelements = 10, longlat = (long, lat))\nsurface_space = domain.space.surface;\n\nGet the paths to each year of MODIS data within the start and stop dates.\n\nLAI =\n    ClimaLand.Canopy.prescribed_lai_modis(surface_space, start_date, stop_date);\n\nJust like with the air temperature, the LAI is an object that we can use to linearly interpolate observed LAI to any simulation time.\n\nIt can also be useful to know the maximum LAI at a site. To do so, we can call, for the first year of data:\n\nmaxLAI = FluxnetSimulations.get_maxLAI_at_site(start_date, lat, long)\n\n1.4455398f0","category":"section"},{"location":"generated/integrated/fluxnet_data/#Fluxnet-comparison-data","page":"Data processing","title":"Fluxnet comparison data","text":"To assess performance of the simulation, we need comparison data from the site. This is complicated since different sites provided different data (e.g. soil moisture and temperature and depth). ClimaLand provides a function to get the comparison data for a select number of variables:\n\nVariable Unit ClimaLand short name Fluxnet Column name\nGross primary prod. mol/m^2/s \"gpp\" \"GPP_DT_VUT_REF\"\nLatent heat flux W/m^2/s \"lhf\" \"LE_CORR\"\nSensible heat flux W/m^2/s \"shf\" \"H_CORR\"\nUpwelling SW W/m^2/s \"swu\" \"SW_OUT\"\nUpwelling LW W/m^2/s \"lwu\" \"LW_OUT\"\nSoil water content  \"swc\" \"SWC_F_MDS_1\"\nSoil temperature K \"tsoil\" \"TS_F_MDS_1\"\nTotal precipitation m/s \"precip\" \"P_F\"\n\ncomparison_data = FluxnetSimulations.get_comparison_data(site_ID, time_offset);\n@show propertynames(comparison_data)\n\n(:UTC_datetime, :gpp, :lhf, :shf, :swu, :lwu, :swc, :tsoil, :precip)\n\nIf a column is missing, the column is not returned. Missing values are replaced with the mean of the not missing values.\n\nThe data we use to force the simulations and to compare the results against were obtained from Ameriflux:\n\nUS-Moz: Wood and Gu [22]\n\nUS-NR1: Blanken et al. [23]\n\nUS-Var: Ma et al. [24]\n\nUS-Ha1: Munger [25]\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/canopy/CanopyEnergy/#Canopy-Energy-Model","page":"Energy","title":"Canopy Energy Model","text":"","category":"section"},{"location":"APIs/canopy/CanopyEnergy/#Models-and-Parameters","page":"Energy","title":"Models and Parameters","text":"","category":"section"},{"location":"APIs/canopy/CanopyEnergy/#Methods","page":"Energy","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.PrescribedCanopyTempModel","page":"Energy","title":"ClimaLand.Canopy.PrescribedCanopyTempModel","text":"PrescribedCanopyTempModel{FT} <: AbstractCanopyEnergyModel{FT}\n\nA model for the energy of the canopy which assumes the canopy temperature is the same as the atmosphere temperature prescribed in the PrescribedAtmos struct.\n\nNo equation for the energy of the canopy is solved.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.BigLeafEnergyModel","page":"Energy","title":"ClimaLand.Canopy.BigLeafEnergyModel","text":"BigLeafEnergyModel{FT} <: AbstractCanopyEnergyModel{FT}\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.BigLeafEnergyModel-Union{Tuple{ClimaParams.ParamDict}, Tuple{FT}} where FT<:AbstractFloat","page":"Energy","title":"ClimaLand.Canopy.BigLeafEnergyModel","text":"BigLeafEnergyModel{FT}(toml_dict::CP.ParamDict; ac_canopy = toml_dict[\"ac_canopy\"]) where {FT <: AbstractFloat}\n\nCreates a BigLeafEnergyModel using default parameters of type FT.\n\nac_canopy (J m^-2 K^-1) - canopy specific heat per area\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.BigLeafEnergyParameters","page":"Energy","title":"ClimaLand.Canopy.BigLeafEnergyParameters","text":"BigLeafEnergyParameters{FT <: AbstractFloat}\n\nac_canopy: Specific heat per emitting area [J/m^2/K]\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.BigLeafEnergyParameters-Tuple{Any}","page":"Energy","title":"ClimaLand.Canopy.BigLeafEnergyParameters","text":"BigLeafEnergyParameters{FT}(; ac_canopy = FT(2e3)) where {FT}\n\nConstruct BigLeafEnergyParameters with the default ac_canopy = 2e3.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.AbstractCanopyEnergyModel","page":"Energy","title":"ClimaLand.Canopy.AbstractCanopyEnergyModel","text":"AbstractCanopyEnergyModel{FT}\n\nAn abstract struct for the Canopy Energy Models. Both PrescribedCanopyTempModel and BigLeafEnergyModel are subtypes of this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.canopy_temperature","page":"Energy","title":"ClimaLand.Canopy.canopy_temperature","text":"canopy_temperature(model::PrescribedCanopyTempModel, canopy, Y, p)\n\nReturns the canopy temperature under the PrescribedCanopyTemp model, where the canopy temperature is assumed to be the same as the atmosphere temperature.\n\n\n\n\n\ncanopy_temperature(model::BigLeafEnergyModel, canopy, Y, p)\n\nReturns the canopy temperature under the BigLeafEnergyModel model, where the canopy temperature is modeled prognostically.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.root_energy_flux_per_ground_area!","page":"Energy","title":"ClimaLand.Canopy.root_energy_flux_per_ground_area!","text":"root_energy_flux_per_ground_area!(\n    fa_energy::ClimaCore.Fields.Field,\n    s::PrognosticGroundConditions,\n    model::Canopy.AbstractCanopyEnergyModel,\n    canopy,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nA method computing the energy flux associated with the root-soil water flux, which returns 0 in cases where we do not need to track this quantity: in this case, when the canopy energy is tracked, but we are using a PrescribedSoil model (non-prognostic soil model).\n\nNote that this energy flux is not typically included in land surface models. We account for it when the soil model is prognostic because the soil model includes the energy in the soil water in its energy balance; therefore, in order to conserve energy, the canopy model must account for it as well.\n\n\n\n\n\nroot_energy_flux_per_ground_area!(\n    fa_energy::ClimaCore.Fields.Field,\n    ground::PrescribedGroundConditions{FT},\n    model::AbstractCanopyEnergyModel{FT},\n    canopy,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n) where {FT}\n\nA method which updates the ClimaCore.Fields.Field fa_energy in place with  the energy flux associated with the root-soil water flux for the CanopyModel run in standalone mode, with a PrescribedGroundConditions.This value is ignored and set to zero in this case.\n\nBackground information: This energy flux is not typically included in land surface models. We account for it when the soil model is prognostic because the soil model includes the energy in the soil water in its energy balance; therefore, in order to conserve energy, the canopy model must account for it as well.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.total_energy_per_area!-APIs-canopy-CanopyEnergy","page":"Energy","title":"ClimaLand.total_energy_per_area!","text":"ClimaLand.total_energy_per_area!(\n    surface_field,\n    model::EnergyHydrology,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total energy per unit ground area for the EnergyHydrology.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::SnowModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total energy per unit ground area for the SnowModel.\n\nThis has already accounted for the area fraction of snow in the definition of S.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::BucketModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total energy per unit ground area for the BucketModel.\n\nThe ground of the bucket model has temperature Y.bucket.T, with volumetric specific heat approximated with the parameter ρc_soil. Additional energy is present due to the latent heat of fusion of frozen water, in the form of snow. We also add in this energy (below). We do not model or account for the sensible energy of snow (ρ_snow T_snow), as this is much smaller.\n\n\n\n\n\ntotal_energy_per_area!(cache, model::AbstractModel, Y, p, t)\n\nA function which updates cache in place with the total energy per unit ground area for the model, computed from Y, p, and t.\n\n\n\n\n\ntotal_energy_per_area!(\n    surface_field,\n    land::AbstractLandModel,\n    Y,\n    p,\n    t,\n    sfc_cache,\n)\n\nA function which computes the total energy per unit area and updates surface_field in place, for the land model land, by calling the same function for the component models.\n\nThe sfc_cache field is available as scratch space.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::BigLeafEnergyModel,\n    Y,\n    p,\n    t,\n\n)\n\nA function which updates surface_field in place with the value of the big leaf model's energy.\n\nNote that this assumes that there is at most a single canopy and stem component, and that the area index for them refers to the integrated area index (in height) - not the value per layer.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::AbstractCanopyEnergyModel,\n    Y,\n    p,\n    t,\n\n)\n\nA default function which errors for generic energy models for the canopy.\n\nNote that we only support two models for canopy energy. The BigLeafEnergyModel has a special method for this, and the other has the temperature prescribed and does not conserve energy.\n\n\n\n\n\nClimaLand.total_energy_per_area!(\n    surface_field,\n    model::CanopyModel,\n    Y,\n    p,\n    t,\n)\n\nA function which updates surface_field in place with the value for the total energy per unit ground area for the CanopyModel.\n\nThis acts by calling the method for the energy component of the canopy model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SurfaceWater/#SurfaceWater","page":"Surface Water Models","title":"SurfaceWater","text":"","category":"section"},{"location":"APIs/SurfaceWater/#Models","page":"Surface Water Models","title":"Models","text":"","category":"section"},{"location":"APIs/SurfaceWater/#Methods-and-Types","page":"Surface Water Models","title":"Methods and Types","text":"","category":"section"},{"location":"APIs/SurfaceWater/#ClimaLand.Pond.PondModel","page":"Surface Water Models","title":"ClimaLand.Pond.PondModel","text":"PondModel{FT, D, R} <: AbstractSurfaceWaterModel{FT}\n\nA stand-in model for models like the snow or river model. In standalone mode, a prescribed soil infiltration rate  and precipitation rate control the rate of change of the pond height variable η via an ODE. In integrated LSM mode, the infiltration into the soil will be computed via a different method, and also be applied as a flux boundary condition for the soil model.\n\ndomain: The domain for the pond model\nrunoff: The runoff model for the pond model\n\n\n\n\n\n","category":"type"},{"location":"APIs/SurfaceWater/#ClimaLand.Pond.PrescribedRunoff","page":"Surface Water Models","title":"ClimaLand.Pond.PrescribedRunoff","text":"PrescribedRunoff{F1 <: Function, F2 <: Function} <:  AbstractSurfaceRunoff\n\nThe required input for driving the simple pond model: precipitation, as a function of time, soil effective saturation at a depth Δz below the surface, as a function of time, and soil parameters, which affect infiltration.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SurfaceWater/#ClimaLand.Pond.surface_runoff","page":"Surface Water Models","title":"ClimaLand.Pond.surface_runoff","text":"function Pond.surface_runoff(\n    runoff::PrognosticRunoff,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nExtension of the Pond.surface_runoff function, which computes  the surface runoff, for use in an LSM when the runoff is determined prognostically.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/AutotrophicRespiration/#Autotrophic-Respiration","page":"Autotrophic Respiration","title":"Autotrophic Respiration","text":"","category":"section"},{"location":"APIs/canopy/AutotrophicRespiration/#Models-and-Parameters","page":"Autotrophic Respiration","title":"Models and Parameters","text":"","category":"section"},{"location":"APIs/canopy/AutotrophicRespiration/#Methods","page":"Autotrophic Respiration","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.AutotrophicRespirationModel","page":"Autotrophic Respiration","title":"ClimaLand.Canopy.AutotrophicRespirationModel","text":"AutotrophicRespirationModel{FT, ARP <: AutotrophicRespirationParameters{FT},} <: AbstractAutotrophicRespirationModel{FT}\n\nThe JULES autotrophic respiration model.\n\nClark, D. B., et al. \"The Joint UK Land Environment Simulator (JULES), model description–Part 2: carbon fluxes and vegetation dynamics.\" Geoscientific Model Development 4.3 (2011): 701-722.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.AutotrophicRespirationModel-Union{Tuple{ClimaParams.ParamDict}, Tuple{FT}} where FT<:AbstractFloat","page":"Autotrophic Respiration","title":"ClimaLand.Canopy.AutotrophicRespirationModel","text":"AutotrophicRespirationModel{FT}(toml_dict::CP.ParamDict,\n                               ) where {FT <: AbstractFloat}\n\nCreate a AutotrophicRespirationModel using toml_dict of type FT.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.AutotrophicRespirationParameters","page":"Autotrophic Respiration","title":"ClimaLand.Canopy.AutotrophicRespirationParameters","text":"AutotrophicRespirationParameters{FT<:AbstractFloat}\n\nThe required parameters for the autrophic respiration model, which is based off of the JULES model. Clark, D. B., et al. \"The Joint UK Land Environment Simulator (JULES), model description–Part 2: carbon fluxes and vegetation dynamics.\" Geoscientific Model Development 4.3 (2011): 701-722.\n\nne: Vcmax25 (leaf level) to N factor (mol CO2 m-2 s-1 kg C (kg C)-1)\nηsl: Live stem wood coefficient (kg C m-3)\nσl: Specific leaf density (kg C m-2 [leaf])\nμr: Ratio root nitrogen to top leaf nitrogen (-), typical value 1.0\nμs: Ratio stem nitrogen to top leaf nitrogen (-), typical value 0.1\nRel: Relative contribution or Rgrowth (-)\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.AutotrophicRespirationParameters-Tuple{ClimaParams.ParamDict}","page":"Autotrophic Respiration","title":"ClimaLand.Canopy.AutotrophicRespirationParameters","text":"AutotrophicRespirationParameters(toml_dict::CP.ParamDict; kwargs...)\n\nConstructor for the AutotrophicRespirationParameters struct by passing a TOML dictionary. You can manually override any parameter via keyword arguments:\n\nAutotrophicRespirationParameters(toml_dict; ne = 99999)\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.nitrogen_content","page":"Autotrophic Respiration","title":"ClimaLand.Canopy.nitrogen_content","text":"nitrogen_content(\n                 ne::FT, # Mean leaf nitrogen concentration (kg N (kg C)-1)\n                 Vcmax25::FT, #\n                 LAI::FT, # Leaf area index\n                 SAI::FT,\n                 RAI::FT,\n                 ηsl::FT, # live stem  wood coefficient (kg C m-3)\n                 h::FT, # canopy height (m)\n                 σl::FT # Specific leaf density (kg C m-2 [leaf])\n                 μr::FT, # Ratio root nitrogen to top leaf nitrogen (-), typical value 1.0\n                 μs::FT, # Ratio stem nitrogen to top leaf nitrogen (-), typical value 0.1\n                ) where {FT}\n\nComputes the nitrogen content of leafs (Nl), roots (Nr) and stems (Ns).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.plant_respiration_maintenance","page":"Autotrophic Respiration","title":"ClimaLand.Canopy.plant_respiration_maintenance","text":"plant_respiration_maintenance(\n    Rd::FT, # Dark respiration\n    β::FT, # Soil moisture factor\n    Nl::FT, # Nitrogen content of leafs\n    Nr::FT, # Nitrogen content of roots\n    Ns::FT, # Nitrogen content of stems\n    ) where {FT}\n\nComputes plant maintenance respiration as a function of dark respiration (Rd), the nitrogen content of leafs (Nl), roots (Nr) and stems (Ns), and the soil moisture factor (β).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.plant_respiration_growth","page":"Autotrophic Respiration","title":"ClimaLand.Canopy.plant_respiration_growth","text":"plant_respiration_growth(\n    Rel::FT, # Factor of relative contribution\n    An::FT, # Net photosynthesis\n    Rpm::FT # Plant maintenance respiration\n    ) where {FT}\n\nComputes plant growth respiration as a function of net photosynthesis (An), plant maintenance respiration (Rpm), and a relative contribution factor, Rel.\n\n\n\n\n\n","category":"function"},{"location":"generated/shared_utilities/driver_tutorial/#Using-atmospheric-and-radiative-drivers","page":"Intro to forced site-level runs","title":"Using atmospheric and radiative drivers","text":"The goal of this is to outline how to set up simulations driven by prescribed forcing data (``drivers\"). These are grouped into radiative forcing and atmospheric forcing. We will first cover the types of forcing we support, followed by how to specify the driver structs given the forcing data and how to update the values used during a simulation.","category":"section"},{"location":"generated/shared_utilities/driver_tutorial/#Types-of-forcing-data","page":"Intro to forced site-level runs","title":"Types of forcing data","text":"We currently support site-level simulations and have two site-level driver types, PrescribedAtmosphere and PrescribedRadiativeFluxes.\n\nThe atmosphere driver stores the atmospheric state data as a function of time, including the liquid precipitation rate (m/s), the snow precipitation rate converted into an equivalent rate of liquid water (m/s), the atmopheric pressure (Pa), specific humidity, horizontal wind speed (m/s), temperature (K), CO2 concentration (mol/mol), and the height at which these measurements were taken (currently assumed to be the same value for all variables).\n\nThe radiative fluxes driver stores the data required to specify the radiative forcing. We currently support only a single downwelling shortwave and longwave flux (W/m^2). The radiative driver is also where a function which computes the zenith angle for the site is stored.\n\nBoth drivers store the start date for the data/simulation. This is the DateTime object which corresponds to the time at which t=0 in the simulation. Additionally, for site-level runs, both drivers store the forcing data as a spline function fit to the data which takes the time t as an argument, where t is the simulation time measured in seconds since the start date. The start date should be in UTC.\n\nNote: for coupled runs, corresponding types CoupledAtmosphere and CoupledRadiativeFluxes exist.","category":"section"},{"location":"generated/shared_utilities/driver_tutorial/#Creating-site-level-drivers-for-radiation","page":"Intro to forced site-level runs","title":"Creating site-level drivers for radiation","text":"First, assume that we have data stored for the longwave and shortwave radiation at a particular site, and that we have read it in to an array, along with the times at which the observations were made and the latitude and longitude of the site.\n\nusing Dates\nusing Insolation # for computing zenith angle given lat, lon, time.\nusing ClimaLand\nimport ClimaLand.Parameters as LP\nimport ClimaParams\n\nAssume the local_datetime array is read in from the data file.\n\nlocal_datetime = DateTime(2013):Dates.Hour(1):DateTime(2013, 1, 7); # one week, hourly data\n\nTimezone (offset of local time from UTC in hrs) for the Missouri Ozark site\n\ntime_offset = -6;\n\nSite latitude and longitude\n\nlat = 38.7441; # degree\nlong = -92.2000; # degree\n\nCompute the start date in UTC, and convert local datetime vector into a vector of seconds since the start date\n\nstart_date = local_datetime[1] + Dates.Hour(time_offset);\ndata_dt = 3600.0;\nseconds = 0:data_dt:((length(local_datetime) - 1) * data_dt);\n\nAssume the downwelling long and shortwave radiation, as well as the diffuse fraction are read in from the file and are measured at the times in local_datetime. Here, we'll just make them up periodic on daily timescales:\n\nT = @. 298.15 + 5.0 * sin(2π * (seconds - 3600 * 6) / (3600 * 24));\nLW_d = 5.67 * 10^(-8) .* T .^ 4;\nSW_d = @. max(1400 * sin(2π * (seconds - 3600 * 6) / (3600 * 24)), 0.0);\ndiffuse_fraction = 0.5 .+ zeros(length(seconds));\n\nNext, fit interpolators to the data. These interpolators are what are stored in the driver function. Then we can evaluate the radiative forcing at any simulation time (and not just at times coinciding with measurements). By default, linear interpolation is used.\n\nLW_d = TimeVaryingInput(seconds, LW_d)\nSW_d = TimeVaryingInput(seconds, SW_d);\ndiffuse_fraction = TimeVaryingInput(seconds, diffuse_fraction);\n\nFinally, for many models we also need to specify the function for computing the zenith angle as a function of simulation time. To do so, we use the Insolation package as follows:\n\ntoml_dict = LP.create_toml_dict(Float64);\nearth_param_set = LP.LandParameters(toml_dict);\ninsol_params = earth_param_set.insol_params # parameters of Earth's orbit required to compute the insolation\nzenith_angle =\n    (t, s) -> default_zenith_angle(\n        t,\n        s;\n        insol_params,\n        longitude = long,\n        latitude = lat,\n    );\n\nLastly, we store the interpolators for downwelling fluxes and the zenith angle function in the PrescribedRadiativeFluxes struct.\n\nradiation = ClimaLand.PrescribedRadiativeFluxes(\n    Float64,\n    SW_d,\n    LW_d,\n    start_date;\n    θs = zenith_angle,\n    frac_diff = diffuse_fraction,\n);","category":"section"},{"location":"generated/shared_utilities/driver_tutorial/#Updating-the-driver-variables-during-the-simulation","page":"Intro to forced site-level runs","title":"Updating the driver variables during the simulation","text":"The values for LWd, SWd, the diffuse fraction, and the cosine of the zenith angle θ_s are stored in the simulation/model cache p under the name drivers. Since we did not pass the diffuse fraction directly, it will be computed using an empirical function of the atmospheric state, the zenith angle, and the earth parameter set.\n\nWhen you initialize the variables and cache of a model, the cache p will be returned with memory allocated but all values set to zero:\n\np = (; drivers = (LW_d = [0.0], SW_d = [0.0], cosθs = [0.0], frac_diff = [0.0]));\n\nIn order to update them, we can make use of default update functions:\n\nupdate_radiation! = ClimaLand.make_update_drivers(radiation)\nt0 = seconds[1] # midnight local time\nupdate_radiation!(p, t0);\n@show(p.drivers);\n\np.drivers = (LW_d = [418.7382685853159], SW_d = [0.0], cosθs = [0.4718705875417606], frac_diff = [0.5])\n\n\nDuring a simulation, the drivers are updated in place in p.drivers via a \"callback\", which is a function which is called a specified times or when certain criteria are met during a simulation. In general, then, we don't update drivers every timestep, but less frequently. For example, the simulation timestep may be 10 minutes, but we may only update the drivers every three hours:\n\nupdatefunc = update_radiation!;\ncb = ClimaLand.DriverUpdateCallback(updatefunc, 3600.0 * 3, t0);\n\nThis callback must then be provided to the simulation solve function.","category":"section"},{"location":"generated/shared_utilities/driver_tutorial/#Using-ERA5-data","page":"Intro to forced site-level runs","title":"Using ERA5 data","text":"If you wish to force your ClimaLand simulation with ERA5 reanalysis data, there is a helper function makes this easier than specifying each atmospheric variable as individual TimeVaryingInput objects, and then making the PrescribedAtmosphere struct. ClimaLand provides two ERA5 NetCDF datasets:\n\nA high-resolution dataset with data on a 1 degree x 1 degree grid, available from 1979 to 2024.\n\nThis dataset is about 8.5 GB per year of data.\n\nA low-resolution dataset with data on a 8 degree x 8 degree grid, available for the year 2008.\n\nThis dataset is about 350 MB in size. The low-resolution dataset is best for local simulations and for use in examples in the documentation, but for production runs on compute clusters we recommend using the high-resolution data.\n\nTo use the ERA5 data, you need to provide the start_date and stop_date of your simulation, which should be within the range of dates covered by the dataset you are using (unless you are using the low-resolution dataset for 2008, which will be reused for each year of simulation). You'll also provide a flag use_lowres_forcing which is true if you want to use the low-resolution dataset, and false otherwise. Finally, you need the surface_space of your simulation (corresponding to the grid being used), the parameter toml_dict, and the floating point type of the simulation FT. Then you can access the atmospheric and radiative drivers like this:\n\natmos, radiation = ClimaLand.prescribed_forcing_era5(start_date,\n                                                     stop_date,\n                                                     surface_space,\n                                                     earth_param_set,\n                                                     FT;\n                                                     use_lowres_forcing = true)\n\nEach forcing dataset contains the following variables:\n\n\"tp\" Total precipitation as a mass/m^2/hour (accumulated over an hour)\n\"sf\" Snow precipitation as a mass/m^2/hour (accumulated over an hour)\n\"u10n\", \"v10n\", Neutral wind speed components in the horizontal, at 10m, in m/s\n\"d2m\", Dewpoint temperature at 2m in K\n\"t2m\", Air temperature at 2m in K\n\"sp\", Surface pressure in Pa\n\"ssrd\", Downwelling shortwave radiation in J/m^2/hour (accumulated over an hour)\n\"strd\", Downwelling longwave radiation J/m^2/hour (accumulated over an hour)\n\nPlease note that the default era5 forcing uses linear interpolation in space and time. If your simulation encompasses a time that is beyond the extrema of the data, the data will be reused starting from the start date of the simulation. This corresponds to a value of time_interpolation_method = LinearInterpolation(PeriodicCalendar()). To repeat a single year of data instead, you can use: time_interpolation_method = LinearInterpolation(PeriodicCalendar(Dates.Year(1), DateTime(repeat_year))). Note that this second option repeats the single year over the entire duration of the simulation, as opposed to only when outside of the date range of the data. This behavior can be changed by passing in a timeinterpolationmethod. Another option that be be useful is time_interpolation_method = LinearInterpolation(Flat()), which uses the last (first) value of the data repeatedly when outside the bounds of the data. For more details, please see the documentation string for ClimaLand.prescribed_forcing_era5 or ClimaUtilities.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"APIs/canopy/Photosynthesis/#Photosynthesis","page":"Photosynthesis","title":"Photosynthesis","text":"","category":"section"},{"location":"APIs/canopy/Photosynthesis/#Models-and-Parameters","page":"Photosynthesis","title":"Models and Parameters","text":"","category":"section"},{"location":"APIs/canopy/Photosynthesis/#FarquharModel-Methods","page":"Photosynthesis","title":"FarquharModel Methods","text":"","category":"section"},{"location":"APIs/canopy/Photosynthesis/#PModel-Methods","page":"Photosynthesis","title":"PModel Methods","text":"","category":"section"},{"location":"APIs/canopy/Photosynthesis/#Shared-Methods","page":"Photosynthesis","title":"Shared Methods","text":"","category":"section"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.PModel","page":"Photosynthesis","title":"ClimaLand.Canopy.PModel","text":"PModel{FT,\n       OPFT <: PModelParameters{FT},\n       OPCT <: PModelConstants{FT},\n       F <: Union{FT, ClimaCore.Fields.Field},\n       } <: AbstractPhotosynthesisModel{FT}\n\nAn implementation of the optimality photosynthesis model \"P-model v1.0\" of Stocker et al. (2020).\n\nStocker, B. D., Wang, H., Smith, N. G., Harrison, S. P., Keenan, T. F., Sandoval, D., Davis, T.,     and Prentice, I. C.: P-model v1.0: an optimality-based light use efficiency model for simulating     ecosystem gross primary production, Geosci. Model Dev., 13, 1545–1581,     https://doi.org/10.5194/gmd-13-1545-2020, 2020.\n\nThe P-model computes photosynthesis rates at the canopy level, and ci, Γstar, Ko, Kc are in units of Pa.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.PModel-Tuple{Any, ClimaParams.ParamDict}","page":"Photosynthesis","title":"ClimaLand.Canopy.PModel","text":"function PModel{FT}(\n    domain,\n    toml_dict::CP.ParamDict;\n    is_c3 = clm_photosynthesis_parameters(domain.space.surface).is_c3,\n    cstar = toml_dict[\"pmodel_cstar\"],\n    β = toml_dict[\"pmodel_β\"],\n    temperature_dep_yield = true,\n    ϕ0_c3 = toml_dict[\"pmodel_ϕ0_c3\"],\n    ϕ0_c4 = toml_dict[\"pmodel_ϕ0_c4\"],\n    ϕa0_c3 = toml_dict[\"pmodel_ϕa0_c3\"],\n    ϕa1_c3 = toml_dict[\"pmodel_ϕa1_c3\"],\n    ϕa2_c3 = toml_dict[\"pmodel_ϕa2_c3\"],\n    ϕa0_c4 = toml_dict[\"pmodel_ϕa0_c4\"],\n    ϕa1_c4 = toml_dict[\"pmodel_ϕa1_c4\"],\n    ϕa2_c4 = toml_dict[\"pmodel_ϕa2_c4\"],\n    α = toml_dict[\"pmodel_α\"],\n) where {FT <: AbstractFloat}\n\nConstructs a P-model (an optimality model for photosynthesis) using default parameters.\n\nThe following default parameters (from the TOML file) are used:\n\ncstar = 0.41 (unitless) - 4 * dA/dJmax, assumed to be a constant marginal cost (Wang 2017, Stocker 2020)\nβ = 146 (unitless) - Unit cost ratio of Vcmax to transpiration (Stocker 2020)\nϕ0_c3 = 0.052 (unitless) - constant intrinsic quantum yield. Skillman (2008)\nϕ0_c4 = 0.057 (unitless) - constant intrinsic quantum yield. Skillman (2008)\nϕa0_c3 = 0.352*0.087 (unitless) - constant term in quadratic intrinsic quantum yield (Stocker 2020)\nϕa1_c3 = 0.022*0.087 (K^-1) - first order term in quadratic intrinsic quantum yield (Stocker 2020)\nϕa2_c3 = -0.00034*0.087 (K^-2) - second order term in quadratic intrinsic quantum yield (Stocker 2020)\nϕa0_c4 = 0.352*0.087 (unitless) - constant term in quadratic intrinsic quantum yield (Scott and Smith, 2022)\nϕa1_c4 = 0.022*0.087 (K^-1) - first order term in quadratic intrinsic quantum yield (Scott and Smith, 2022)\nϕa2_c4 = -0.00034*0.087 (K^-2) - second order term in quadratic intrinsic quantum yield (Scott and Smith, 2022)\nα = 0.933 (unitless) - 1 - 1/T where T is the timescale of Vcmax, Jmax acclimation. Here T = 15 days. (Mengoli 2022)\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.PModelParameters","page":"Photosynthesis","title":"ClimaLand.Canopy.PModelParameters","text":"PModelParameters{FT<:AbstractFloat}\n\nThe required parameters for P-model (Stocker et al. 2020). Parameters are typically tunable with considerable uncertainty.\n\ncstar: Constant describing cost of maintaining electron transport (unitless)\nβ: Ratio of unit costs of transpiration and carboxylation (unitless)\ntemperature_dep_yield: A boolean flag indicating if the quantum yield is a function of temperature or not\nϕ0_c3: Temp-independent intrinsic quantum yield. (unitless); C3\nϕ0_c4: Temp-independent intrinsic quantum yield. (unitless); C4\nϕa0_c3: Constant term in temp-dependent intrinsic quantum yield (unitless); C3.\nϕa1_c3: First order term in temp-dependent intrinsic quantum yield (K^-1); C3.\nϕa2_c3: Second order term in temp-dependent intrinsic quantum yield (K^-2); C3.\nϕa0_c4: Constant term in temp-dependent intrinsic quantum yield (unitless); C4.\nϕa1_c4: First order term in temp-dependent intrinsic quantum yield (K^-1); C4.\nϕa2_c4: Second order term in temp-dependent intrinsic quantum yield (K^-2); C4.\nα: Timescale parameter used in EMA for acclimation of optimal photosynthetic capacities (unitless). Setting this to 0 represents no incorporation of past values. Since we update the EMA equation once per day, α = 1 - 1 day/τ where τ is the acclimation timescale in days.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.PModelConstants","page":"Photosynthesis","title":"ClimaLand.Canopy.PModelConstants","text":"PModelConstants{FT<:AbstractFloat}\n\nThe required constants for P-model (Stocker et al. 2020). These are physical or biochemical constants that are not expected to change with time or space.\n\nR: Gas constant (J mol^-1 K^-1)\nKc25: Michaelis-Menten parameter for carboxylation at 25°C (Pa)\nKo25: Michaelis-Menten parameter for oxygenation at 25°C (Pa)\nTo: Reference temperature equal to 25˚C (K)\nΔHkc: Energy of activation for Kc (J mol^-1)\nΔHko: Energy of activation for Ko (J mol^-1)\nDrel: Relative diffusivity of CO2 in the stomatal pores, equal to 1.6.\nΔHΓstar: Effective energy of activation for Γstar (J mol^-1)\nΓstar25: Γstar at 25 °C (Pa)\nHa_Vcmax: Effective energy of activation for Vcmax (J mol^-1)\nHd_Vcmax: Effective energy of deactivation for Vcmax (J mol^-1)\naS_Vcmax: Intercept term for dS in Vcmax deactivation factor (J K^-1 mol^-1)\nbS_Vcmax: Slope term for dS in Vcmax deactivation factor (J K^-2 mol^-1)\nHa_Jmax: Effective energy of activation for Jmax (J mol^-1)\nHd_Jmax: Effective energy of deactivation for Jmax (J mol^-1)\naS_Jmax: Intercept term for dS in Jmax deactivation factor (J K^-1 mol^-1)\nbS_Jmax: Slope term for dS in Jmax deactivation factor (J K^-2 mol^-1)\nMc: Molar mass of carbon (kg mol^-1)\noi: Intercellular O2 mixing ratio (unitless)\naRd: First order coefficient for temp-dependent Rd (K^-1)\nbRd: Second order coefficient for temp-dependent Rd (K^-2)\nfC3: Constant factor appearing the dark respiration term for C3 plants (unitless)\nplanck_h: Planck constant (J s)\nlightspeed: Speed of light (m s^-1)\nN_a: Avogadro constant (mol^-1)\nρ_water: Density of water (kg m^-3)\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.FarquharModel","page":"Photosynthesis","title":"ClimaLand.Canopy.FarquharModel","text":"FarquharModel{FT, FP <: FarquharParameters{FT}}\n\nA photosynthesis model taking leaf-level Vcmax25 and multiple other constants and predicting dark respiration at the leaf level, net photosynthesis at the leaf level, and GPP at the canopy level.\n\nThe Farquhar model computes photosynthetic rates using leaf-level properties, and so Vcmax25, Rd, An, etc are per unit area leaf. This version also works with ci, Γstar, Ko, Ki, in units of mol/mol, and not Pa.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.FarquharModel-Union{Tuple{FT}, Tuple{Any, ClimaParams.ParamDict}} where FT<:AbstractFloat","page":"Photosynthesis","title":"ClimaLand.Canopy.FarquharModel","text":"FarquharModel{FT}(\n    domain;\n    photosynthesis_parameters = clm_photosynthesis_parameters(\n        domain.space.surface,\n    ),\n) where {\n    FT <: AbstractFloat,\n    MECH <: Union{FT, ClimaCore.Fields.Field},\n    VC <: Union{FT, ClimaCore.Fields.Field},\n}\n\nCreates a FarquharModel using default parameters of type FT.\n\nThe photosynthesis_parameters argument is a NamedTuple that contains\n\nis_c3: a Float or Field indicating if plants are C3 (1) or C4 (0) (unitless)\nVcmax25: a Float or Field representing the maximum carboxylation rate at 25C (mol m^-2 s^-1)\n\nBy default, these parameters are set by the clm_photosynthesis_parameters function, which reads in CLM data onto the surface space as ClimaUtilities SpaceVaryingInputs.\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.FarquharParameters","page":"Photosynthesis","title":"ClimaLand.Canopy.FarquharParameters","text":"FarquharParameters{\n    FT<:AbstractFloat,\n    MECH <: Union{FT, ClimaCore.Fields.Field},\n    VC <: Union{FT, ClimaCore.Fields.Field},\n}\n\nThe required parameters for the Farquhar photosynthesis model.\n\nVcmax25: Vcmax at 25 °C (mol CO2/m^2/s); leaf level\nΓstar25: Γstar at 25 °C (mol/mol)\nKc25: Michaelis-Menten parameter for CO2 at 25 °C (mol/mol)\nKo25: Michaelis-Menten parameter for O2 at 25 °C (mol/mol)\nΔHkc: Energy of activation for CO2 (J/mol)\nΔHko: Energy of activation for oxygen (J/mol)\nΔHVcmax: Energy of activation for Vcmax (J/mol)\nΔHΓstar: Energy of activation for Γstar (J/mol)\nΔHJmax: Energy of activation for Jmax (J/mol)\nΔHRd: Energy of activation for Rd (J/mol)\nTo: Reference temperature equal to 25 degrees Celsius (K)\noi: Intercelluar O2 concentration (mol/mol); taken to be constant\nϕ: Quantum yield of photosystem II (Bernacchi, 2003; unitless)\nθj: Curvature parameter, a fitting constant to compute J, unitless\nfC3: Constant factor appearing the dark respiration term for C3, equal to 0.015.\nfC4: Constant factor appearing the dark respiration term for C4, equal to 0.025.\nQ10: Q10 temperature parameter for Vcmax and Rd for C4 photosynthesis; unitless\ns1: Parameter appearing in temperature dependence of C4 Vcmax; K^{-1}\ns2: Parameter appearing in temperature dependence of C4 Vcmax; K\ns3: Parameter appearing in temperature dependence of C4 Vcmax; K^{-1}\ns4: Parameter appearing in temperature dependence of C4 Vcmax; K\ns5: Parameter appearing in temperature dependence of C4 Rd; K^{-1}\ns6: Parameter appearing in temperature dependence of C4 Rd; K\nE: Quantum yield for C4 photosynthesis; mol/mol\nis_c3: Photosynthesis mechanism: 1.0 indicates C3, 0.0 indicates C4\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.FarquharParameters-Tuple{ClimaParams.ParamDict}","page":"Photosynthesis","title":"ClimaLand.Canopy.FarquharParameters","text":"function FarquharParameters(\n    toml_dict::CP.ParamDict;\n    is_c3::Union{AbstractFloat, ClimaCore.Fields.Field},\n    Vcmax25,\n)\n\nConstructor for the FarquharParameters struct.\n\nimport ClimaParams as CP\ntoml_dict = CP.create_toml_dict(Float32);\nClimaLand.Canopy.FarquharParameters(toml_dict, 1.0f0; Vcmax25 = 99999999)\n\n\n\n\n\n","category":"method"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.arrhenius_function","page":"Photosynthesis","title":"ClimaLand.Canopy.arrhenius_function","text":"arrhenius_function(T::FT, To::FT, R::FT, ΔH::FT)\n\nComputes the Arrhenius function at temperature T given the reference temperature To=298.15K, the universal gas constant R, and the energy activation ΔH.\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.intercellular_co2_farquhar","page":"Photosynthesis","title":"ClimaLand.Canopy.intercellular_co2_farquhar","text":"intercellular_co2_farquhar(ca::FT, Γstar::FT, medlyn_factor::FT) where{FT}\n\nComputes the intercellular CO2 concentration (mol/mol) given the atmospheric concentration (ca, mol/mol), the CO2 compensation (Γstar,  mol/mol), and the Medlyn factor (unitless).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.co2_compensation_farquhar","page":"Photosynthesis","title":"ClimaLand.Canopy.co2_compensation_farquhar","text":"co2_compensation_farquhar(Γstar25::FT,\n                 ΔHΓstar::FT,\n                 T::FT,\n                 To::FT,\n                 R::FT) where {FT}\n\nComputes the CO2 compensation point (Γstar), in units of mol/mol, as a function of its value at 25 °C (Γstar25), a constant energy of activation (ΔHΓstar), a standard temperature (To), the unversal gas constant (R), and the temperature (T).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.rubisco_assimilation_farquhar","page":"Photosynthesis","title":"ClimaLand.Canopy.rubisco_assimilation_farquhar","text":"rubisco_assimilation_farquhar(is_c3::AbstractFloat, args...)\n\nCalls the correct rubisco assimilation function based on the is_c3.\n\nA is_c3 value of 1.0 corresponds to C3 photosynthesis and calls c3_rubisco_assimilation_farquhar, while 0.0 corresponds to C4 photsynthesis and calls c4_rubisco_assimilation_farquhar.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.light_assimilation_farquhar","page":"Photosynthesis","title":"ClimaLand.Canopy.light_assimilation_farquhar","text":"light_assimilation_farquhar(is_c3::AbstractFloat, args...)\n\nCalls the correct light assimilation function based on the is_c3.\n\nA is_c3 value of 1.0 corresponds to C3 photosynthesis and calls c3_light_assimilation_farquhar, while 0.0 corresponds to C4 photsynthesis and calls c4_light_assimilation_farquhar.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.max_electron_transport_farquhar","page":"Photosynthesis","title":"ClimaLand.Canopy.max_electron_transport_farquhar","text":"max_electron_transport_farquhar(\n    Vcmax25::FT,\n    ΔHJmax::FT,\n    T::FT,\n    To::FT,\n    R::FT,\n) where {FT}\n\nComputes the maximum potential rate of electron transport (Jmax), in units of mol/m^2/s, as a function of Vcmax at 25 °C (Vcmax25), a constant (ΔHJmax), a standard temperature (To), the unversal gas constant (R), and the temperature (T).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.electron_transport_farquhar","page":"Photosynthesis","title":"ClimaLand.Canopy.electron_transport_farquhar","text":"electron_transport_farquhar(APAR::FT,\n                   Jmax::FT,\n                   θj::FT,\n                   ϕ::FT) where {FT}\n\nComputes the rate of electron transport (J), in units of mol/m^2/s, as a function of the maximum potential rate of electron transport (Jmax), absorbed photosynthetically active radiation (APAR), an empirical \"curvature parameter\" (θj; Bonan Eqn 11.21) and the quantum yield of photosystem II (ϕ).\n\nIn this function, all fluxes are per unit leaf area, including APAR.\n\nSee Ch 11, G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.net_photosynthesis","page":"Photosynthesis","title":"ClimaLand.Canopy.net_photosynthesis","text":"net_photosynthesis(A::FT,\n                   Rd::FT) where {FT}\n\nComputes the total net carbon assimilation (An), in units of mol CO2/m^2/s, as a function of the gross assimilation (A) and  dark respiration (Rd).\n\nNote that if  moisture stress is factored into the model, it must be applied correctly to Rd and A prior to this function.\n\nBoth A and Rd must either be leaf level (standard Farquhar), or  canopy level (p-model), but not mixed. The returned quantity is  similarily either leaf or canopy level.\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.dark_respiration_farquhar","page":"Photosynthesis","title":"ClimaLand.Canopy.dark_respiration_farquhar","text":"dark_respiration_farquhar(is_c3::AbstractFloat, args...)\n\nCalls the correct dark respiration function based on is_c3.\n\nA is_c3 value of 1.0 corresponds to C3 photosynthesis and calls c3_dark_respiration, while 0.0 corresponds to C4 photsynthesis and calls c4_dark_respiration.\n\nTODO: Generalize to p-model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.MM_Kc","page":"Photosynthesis","title":"ClimaLand.Canopy.MM_Kc","text":"MM_Kc(Kc25::FT,\n      ΔHkc::FT,\n      T::FT,\n      To::FT,\n      R::FT) where {FT}\n\nComputes the Michaelis-Menten coefficient for CO2 (Kc), in units of mol/mol or Pa (depending on the units of Kc25), as a function of its value at 25 °C (Kc25), a constant (ΔHkc), a standard temperature (To), the unversal gas constant (R), and the temperature (T).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.MM_Ko","page":"Photosynthesis","title":"ClimaLand.Canopy.MM_Ko","text":"MM_Ko(Ko25::FT,\n      ΔHko::FT,\n      T::FT,\n      To::FT,\n      R::FT) where {FT}\n\nComputes the Michaelis-Menten coefficient for O2 (Ko), in units of mol/mol or Pa (depending on the units of Ko25), as a function of its value at 25 °C (Ko25), a constant (ΔHko), a standard temperature (To), the universal gas constant (R), and the temperature (T).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_Vcmax_farquhar","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_Vcmax_farquhar","text":"compute_Vcmax_farquhar(is_c3::AbstractFloat, args...)\n\nCalls the correct Vcmax function based on is_c3.\n\nA is_c3 value of 1.0 corresponds to C3 photosynthesis and calls c3_compute_Vcmax, while 0.0 corresponds to C4 photsynthesis and calls c4_compute_Vcmax.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_full_pmodel_outputs","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_full_pmodel_outputs","text":"compute_full_pmodel_outputs(\n    parameters::PModelParameters{FT},\n    constants::PModelConstants{FT},\n    T_canopy::FT,\n    P_air::FT,\n    VPD::FT,\n    ca::FT,\n    βm::FT,\n    APAR::FT;\n    is_c3 = FT(1)\n) where {FT}\n\nPerforms the P-model computations as defined in Stocker et al. (2020) and returns a dictionary of full outputs. See https://github.com/geco-bern/rpmodel for a code reference. This should replicate the behavior of the rpmodel package.\n\nThis is for C3 only, since the comparison data for C3.\n\nArgs:\n\nparameters:     PModelParameters object containing the model parameters.\nconstants:      PModelConstants object containing the model constants.\nT_canopy:       Canopy temperature (K).\nP_air:          Ambient air pressure (Pa).\nVPD:            Vapor pressure deficit (Pa).\nca:             Ambient CO2 concentration (mol/mol).\nβm:             Soil moisture stress factor (unitless).\nAPAR:          Absorbed photosynthetically active radiation (mol photons m^-2 s^-1).\n\nReturns: named tuple with the following keys and descriptions: Output name         Description (units)\n\n\"gpp\"           Gross primary productivity (kg m^-2 s^-1)\n\"gammastar\"     CO2 compensation point (Pa)\n\"kmm\"           Effective MM coefficient for Rubisco-limited photosynthesis (Pa)\n\"ns_star\"       Viscosity of water normalized to 25 deg C (unitless)\n\"chi\"           Optimal ratio of intercellular to ambient CO2 (unitless)\n\"xi\"            Sensitivity of χ to VPD (Pa^1/2)\n\"mj\"            CO2 limitation factor for light-limited photosynthesis (unitless)\n\"mc\"            CO2 limitation factor for Rubisco-limited photosynthesis (unitless)\n\"ci\"            Intercellular CO2 concentration (Pa)\n\"iwue\"          Intrinsic water use efficiency (Pa)\n\"gs\"            Stomatal conductance (mol m^-2 s^-1 Pa^-1)\n\"vcmax\"         Maximum rate of carboxlation (mol m^-2 s^-1)\n\"vcmax25\"       Vcmax normalized to 25°C via modified-Arrhenius type function (mol m^-2 s^-1)\n\"jmax\"          Maximum rate of electron transport (mol m^-2 s^-1)\n\"jmax25\"        Jmax normalized to 25°C via modified-Arrhenius type function (mol m^-2 s^-1)\n\"Rd\"            Dark respiration rate (mol m^-2 s^-1)\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.set_historical_cache!","page":"Photosynthesis","title":"ClimaLand.Canopy.set_historical_cache!","text":"function set_historical_cache!(p, Y0, model::PModel, canopy)\n\nThe P-model requires a cache of optimal Vcmax25, Jmax25, and ξ that represent past acclimated values. Before the simulation, we need to have some physically meaningful initial values for these variables, which live in p.canopy.photosynthesis.OptVars.\n\nThis method assumes that the acclimation is to the initial conditions of the simulation. Note that if the initial condition is e.g., nighttime, then initially the optimal Vcmax and Jmax are zero, so it will take ~1 month (two e-folding timescales for α corresponding to 2 week acclimation timescale) for the model to reach a physically meaningful state.\n\nAn alternative to this approach is to initialize the initial optimal values to some reasonable values based on a spun-up simulation.\n\n\n\n\n\nset_historical_cache!(p, Y0, m::AbstractPhotosynthesisModel, canopy)\n\nFor some canopy components (namely the P-model), we need values at t-1 to compute new values, so this function sets the historical cache values for the photosynthesis model. However, for other photosynthesis models this is not needed, so do nothing by default.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.update_optimal_EMA","page":"Photosynthesis","title":"ClimaLand.Canopy.update_optimal_EMA","text":"update_optimal_EMA(is_c3::FT,\n    parameters::PModelParameters{FT},\n    constants::PModelConstants{FT},\n    OptVars::NamedTuple{(:ξ_opt, :Vcmax25_opt, :Jmax25_opt), Tuple{FT, FT, FT}},\n    T_canopy::FT,\n    P_air::FT,\n    VPD::FT,\n    ca::FT,\n    βm::FT,\n    APAR::FT,\n    local_noon_mask::FT,\n) where {FT}\n\nThis function updates the optimal photosynthetic capacities Vcmax25, Jmax25 and sensitivity of stomatal conductance to dryness (ξ) using an exponential moving average (EMA) that computes new optimal values at local noon, following Mengoli et al. (2022).\n\nArgs:\n\nis_c3:      Photosynthesis mechanism\nparameters: PModelParameters object containing the model parameters.\nconstants: PModelConstants object containing the model constants.\nOptVars: NamedTuple containing the current optimal values of ξ, Vcmax25, and Jmax25.\nT_canopy: Canopy temperature (K).\nP_air: Ambient air pressure (Pa).\nVPD: Vapor pressure deficit (Pa).\nca: Ambient CO2 concentration (mol/mol).\nβm: Soil moisture stress factor (unitless).\nAPAR: Absorbed photosynthetically active radiation (mol photons m^-2 s^-1).\nlocal_noon_mask: A mask (0 or 1) indicating whether the current time is within the local noon window.\n\nReturns:\n\nNamedTuple with updated optimal values of ξ, Vcmax25, and Jmax25\n\nReference: Mengoli, G., Agustí-Panareda, A., Boussetta, S., Harrison, S. P., Trotta, C., & Prentice, I. C. (2022). Ecosystem photosynthesis in land-surface models: A first-principles approach incorporating acclimation. Journal of Advances in Modeling Earth Systems, 14, e2021MS002767. https://doi.org/10.1029/2021MS002767\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.make_PModel_callback","page":"Photosynthesis","title":"ClimaLand.Canopy.make_PModel_callback","text":"function make_PModel_callback(\n    ::Type{FT},\n    t0::ITime,\n    dt,\n    canopy,\n    longitude = nothing\n) where {FT <: AbstractFloat}\n\nThis constructs a IntervalBasedCallback for the P-model that updates the optimal photosynthetic capacities using an exponential moving average at local noon.\n\nWe check for local noon using the provided longitude (once passing in lat/lon for point/column domains, this can be automatically extracted from the domain axes) every dt. The time of local noon is expressed in seconds UTC and neglects the effects of obliquity and eccentricity, so it is constant throughout the year. This presents an error of up to ~20 minutes, but it is sufficient for our application here (since meteorological drivers are often updated at coarser time intervals anyway).\n\nArgs\n\nFT: The floating-point type used in the model (e.g., Float32, Float64).\nt0: ITime, with epoch in UTC.\ndt: timestep\ncanopy: the canopy object containing the P-model parameters and constants.\nlongitude: optional longitude in degrees for local noon calculation (default is nothing, which means   that it will be inferred from the canopy domain).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.intrinsic_quantum_yield","page":"Photosynthesis","title":"ClimaLand.Canopy.intrinsic_quantum_yield","text":"intrinsic_quantum_yield(\n    is_c3::FT, T::FT, parameters) where {FT}\n\nComputes the intrinsic quantum yield of photosystem II.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_viscosity_ratio","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_viscosity_ratio","text":"compute_viscosity_ratio(\n    T::FT,\n    To::FT,\n    ρ_water::FT\n) where {FT}\n\nComputes η*, the ratio of the viscosity of water at temperature T to that at To = 25˚C.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_Kmm","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_Kmm","text":"compute_Kmm(\n    T::FT,\n    p::FT,\n    Kc25::FT,\n    Ko25::FT,\n    ΔHkc::FT,\n    ΔHko::FT,\n    To::FT,\n    R::FT,\n    oi::FT\n) where {FT}\n\nComputes the effective Michaelis-Menten coefficient for Rubisco-limited photosynthesis (Kmm), in units Pa, as a function of temperature T (K), atmospheric pressure p (Pa), and constants: Kc25 (Michaelis-Menten coefficient for CO2 at 25 °C), Ko25 (Michaelis-Menten coefficient for O2 at 25 °C), ΔHkc (effective enthalpy of activation for Kc), ΔHko (effective enthalpy of activation for Ko), To (reference temperature, typically 298.15 K), R (universal gas constant), and oi (O2 mixing ratio, typically 0.209).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.intercellular_co2_pmodel","page":"Photosynthesis","title":"ClimaLand.Canopy.intercellular_co2_pmodel","text":"intercellular_co2_pmodel(ξ::FT, ca_pp::FT, Γstar::FT, VPD::FT) where {FT}\n\nComputes the intercellular co2 concentration (ci) as a function of the optimal ξ (sensitivity to dryness), ca_pp (ambient CO2 partial pressure), Γstar (CO2 compensation point), and VPD (vapor pressure deficit).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.gs_co2_pmodel","page":"Photosynthesis","title":"ClimaLand.Canopy.gs_co2_pmodel","text":"gs_co2_pmodel(\n    χ::FT,\n    ca::FT,\n    A::FT\n) where {FT}\n\nComputes the stomatal conductance of CO2 (gs_co2), in units of mol CO2/m^2/s via Fick's law. Parameters are the ratio of intercellular to ambient CO2 concentration (χ), the ambient CO2 concentration (ca, in mol/mol), and the assimilation rate (A, mol m^-2 s^-1). This is related to the conductance of water by a factor Drel (default value = 1.6).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.gs_h2o_pmodel","page":"Photosynthesis","title":"ClimaLand.Canopy.gs_h2o_pmodel","text":"gs_h2o_pmodel(\n    χ::FT,\n    ca::FT,\n    A::FT,\n    Drel::FT\n) where {FT}\n\nComputes the stomatal conductance of H2O (gs_h2o), in units of mol H2O/m^2/s via Fick's law. Parameters are the ratio of intercellular to ambient CO2 concentration (χ), the ambient CO2 concentration (ca, in mol/mol), the assimilation rate (A, mol m^-2 s^-1), and the relative conductivity ratio Drel (unitless).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_mj","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_mj","text":"compute_mj(\n    is_c3::FT, T::FT, parameters) where {FT}\n\nComputes the unitless factor mj = (ci - Γstar)/(ci+2Γstar) (for C3 plants) and mj = 1 for C4 plants, where the rubisco assimilation rate is Ac = Vcmax*mj.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_mc","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_mc","text":"compute_mc(\n    is_c3::FT, T::FT, parameters) where {FT}\n\nComputes the unitless factor mc = (ci - Γstar)/(ci+Kmm) (for C3 plants) and mj = 1 for C4 plants, where the light assimilation rate is Aj = J/4 mj.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.vcmax_pmodel","page":"Photosynthesis","title":"ClimaLand.Canopy.vcmax_pmodel","text":"vcmax_pmodel(\n    ϕ0::FT,\n    APAR::FT,\n    mprime::FT,\n    mc::FT\n    βm::FT\n) where {FT}\n\nComputes the maximum rate of carboxylation assuming optimality and Aj = Ac using the intrinsic quantum yield (ϕ0), absorbed photosynthetically active radiation (APAR), Jmax-adjusted capacity (mprime), a Rubisco-limited capacity (mc), and empirical soil moisture stress factor (βm). See Eqns 16 and 6 in Stocker et al. (2020).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_LUE","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_LUE","text":"compute_LUE(\n    ϕ0::FT,\n    β::FT,\n    mprime::FT,\n    Mc::FT\n) where {FT}\n\nComputes light use efficiency (LUE) in kg C/mol from intrinsic quantum yield (ϕ0), moisture stress factor (β), and a Jmax modified capacity (mprime); see Eqn 17 and 19 in Stocker et al. (2020). Mc is the molar mass of carbon (kg/mol) = 0.0120107 kg/mol.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_mj_with_jmax_limitation","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_mj_with_jmax_limitation","text":"compute_mj_with_jmax_limitation(\n    mj::FT,\n    cstar::FT\n) where {FT}\n\nComputes m' such that Aj = ϕ0 APAR * m' (a LUE model) by assuming that dA/dJmax = c is constant. cstar is defined as 4c, a free parameter. Wang etal (2017) derive cstar = 0.412 at STP and using Vcmax/Jmax = 1.88.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.electron_transport_pmodel","page":"Photosynthesis","title":"ClimaLand.Canopy.electron_transport_pmodel","text":"electron_transport_pmodel(\n    ϕ0::FT,\n    APAR::FT,\n    Jmax::FT\n) where {FT}\n\nComputes the rate of electron transport (J) in mol electrons/m^2/s for the pmodel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.co2_compensation_pmodel","page":"Photosynthesis","title":"ClimaLand.Canopy.co2_compensation_pmodel","text":"co2_compensation_pmode(\n    T::FT,\n    To::FT,\n    p::FT,\n    R::FT,\n    ΔHΓstar::FT\n    Γstar25::FT\n) where {FT}\n\nComputes the CO2 compensation point (Γstar), in units Pa, as a function of temperature T (K) and pressure p (Pa). See Equation B5 of Stocker et al. (2020).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.quadratic_soil_moisture_stress","page":"Photosynthesis","title":"ClimaLand.Canopy.quadratic_soil_moisture_stress","text":"quadratic_soil_moisture_stress(\n    θ::FT,\n    meanalpha::FT = FT(1.0),\n    a_hat::FT = FT(0.0),\n    b_hat::FT = FT(0.685),\n    θ0::FT = FT(0.0),\n    θ1::FT = FT(0.6)\n) where {FT}\n\nComputes an empirical soil moisture stress factor (β) according to the quadratic functional form of Stocker et al. (2020), Eq 21, using the soil moisture (θ), AET/PET (meanalpha), and parameters a_hat, b_hat, θ0, and θ1. Default values are from the original paper.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_APAR_canopy_moles","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_APAR_canopy_moles","text":"compute_APAR_canopy_moles(\n    f_abs::FT,\n    par_d::FT,\n    λ_γ_PAR::FT,\n    lightspeed::FT,\n    planck_h::FT,\n    N_a::FT\n) where {FT}\n\nComputes the absorbed photosynthetically active radiation for the canopy in mol photons m^-2 s^-1, given the fraction of absorbed PAR (f_abs), the PAR downwelling flux (par_d, in W m^-2), and the wavelength of PAR (λ_γ_PAR, in m), and the physical constants necessary to compute the energy per mol PAR photons.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_APAR_leaf_moles","page":"Photosynthesis","title":"ClimaLand.Canopy.compute_APAR_leaf_moles","text":"compute_APAR_leaf_moles(\n    f_abs::FT,\n    par_d::FT,\n    λ_γ_PAR::FT,\n    lightspeed::FT,\n    planck_h::FT,\n    N_a::FT,\n    LAI::FT\n) where {FT}\n\nComputes the absorbed photosynthetically active radiation for the leaf in mol photons m^-2 s^-1, given the fraction of absorbed PAR (f_abs), the PAR downwelling flux (par_d, in W m^-2), and the wavelength of PAR (λ_γ_PAR, in m), the leaf area index LAI, and the physical constants necessary to compute the energy per mol PAR photons.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.gross_photosynthesis","page":"Photosynthesis","title":"ClimaLand.Canopy.gross_photosynthesis","text":"gross_photosynthesis(Ac::FT,\n                     Aj::FT) where {FT}\n\nComputes the gross carbon assimilation (A), in units of mol CO2/m^2/s, as a function of the Rubisco limiting factor (Ac), the electron transport limiting rate (Aj).\n\nNote that if  moisture stress is factored into the model, it must be applied correctly to Ac and Aj prior to this function.\n\nBoth Ac and Aj must either be leaf level (standard Farquhar), or  canopy level (p-model), but not mixed. The returned quantity is  similarily either leaf or canopy level.\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Installation-of-Julia-and-ClimaLand","page":"Running your first simulation","title":"Installation of Julia and ClimaLand","text":"ClimaLand is provided as a Julia package, so it requires having Julia installed. Information about Julia packages is available on the Julia website.\n\nFirst, download and install Julia by following the instructions at https://julialang.org/downloads/. Then, you can launch a Julia REPL by running julia --project and install the ClimaLand.jl package by running the following within the REPL:\n\nusing Pkg\nPkg.add(ClimaLand)","category":"section"},{"location":"getting_started/#Steps-to-run-a-model","page":"Running your first simulation","title":"Steps to run a model","text":"To run a model, you will always need to do these steps:\n\nImport dependencies. You need some libraries to run the model.\nChoose floating point precision: Float32 or Float64.\nImport parameters via .toml files. You need some constants and parameters values to run the model.\nDefine your domain. This specifies where you are solving the equations: globally (on the sphere),\n\nin a region (in a box), or at a site (in a column). See the tutorial to ClimaLand domains!\n\nSet your simulation period: start date, end date, timestep.\nSet the forcings (for example, air temperature, precipitations).\nSet the initial conditions. Differential equations required initial conditions to solve.\n\nFor some simulations (e.g., global land simualtions), we provide default initial condition (\"ic\") functions, but in many cases you need to create your own set_ic! function.\n\nSet how output is saved. For some simulations (e.g., global land simulations), we use the default diagnostic output,\n\ncorresponding to monthly averages of specific variables saved to netcdf files. For your use case, you may wish to change these defaults. See writing and accessing outputs.","category":"section"},{"location":"getting_started/#Example:-running-a-simple-soil-model","page":"Running your first simulation","title":"Example: running a simple soil model","text":"Now that we have Julia installed, let's set up and run a simple ClimaLand simulation! You can follow along by copying the following code segments into your REPL.\n\nFirst we import the necessary Julia packages:\n\nimport ClimaParams as CP\nusing ClimaLand\nusing ClimaLand.Domains\nusing ClimaLand.Soil\nimport ClimaLand.Simulations: LandSimulation, solve!\nimport ClimaLand.Parameters as LP\nusing Dates\n\nChoose a floating point precision, and get the parameter set, which holds constants used across CliMA models. Note: we use SI units unless otherwise specified. See our Physical Units documentation for more information.\n\nFT = Float32\ntoml_dict = LP.create_toml_dict(FT);\n\nWe will run this simulation on a column domain with 1 meter depth, at a lat/lon location near Pasadena, California.\n\nzmax = FT(0)\nzmin = FT(-1.0)\nlonglat = FT.((-118.1, 34.1))\ndomain = Domains.Column(; zlim = (zmin, zmax), nelements = 10, longlat);\nsurface_space = domain.space.surface;\n\nWe choose the initial and final simulation times as DateTimes, and a timestep in seconds.\n\nstart_date = DateTime(2008);\nstop_date = start_date + Second(60 * 60 * 72);\ndt = 1000.0;\n\nThe soil model takes in 2 forcing objects, atmosphere and radiation, which we read in from ERA5 data.\n\natmos, radiation = ClimaLand.prescribed_forcing_era5(\n    start_date,\n    stop_date\n    surface_space,\n    toml_dict,\n    FT;\n    use_lowres_forcing = true,\n);\n\nNow, we can create the EnergyHydrology model. This constructor uses default parameters and parameterizations, but these can also be overwritten, which we'll demonstrate in later tutorials.\n\nmodel = Soil.EnergyHydrology{FT}(\n    domain,\n    (; atmos, radiation),\n    toml_dict,\n);\n\nDefine a function to set initial conditions for the prognostic variables.\n\nfunction set_ic!(Y, p, t0, model)\n    Y.soil.ϑ_l .= FT(0.24);\n    Y.soil.θ_i .= FT(0.0);\n    T = FT(290.15);\n    ρc_s = Soil.volumetric_heat_capacity.(\n        Y.soil.ϑ_l,\n        Y.soil.θ_i,\n        model.parameters.ρc_ds,\n        model.parameters.earth_param_set,\n    );\n    Y.soil.ρe_int .=\n        Soil.volumetric_internal_energy.(\n            Y.soil.θ_i,\n            ρc_s,\n            T,\n            model.parameters.earth_param_set,\n        );\nend\n\nNow construct the LandSimulation object, which contains the model and additional timestepping information.\n\nsimulation = LandSimulation(start_date, stop_date, dt, model; set_ic!, user_callbacks = ());\n\nNow we can run the simulation!\n\nsolve!(simulation);\n\nThat's it! For more complex examples and pretty plots, please see the tutorial section of our docs.\n\nAtmospheric forcing data citation: Hersbach, Hans, et al. \"The ERA5 global reanalysis.\" Quarterly journal of the royal meteorological society 146.730 (2020): 1999-2049.","category":"section"},{"location":"generated/standalone/Snow/base_tutorial/#Seasonal-Snow-Timeseries-Generation-with-a-Neural-Network","page":"Base tutorial","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"This tutorial explains how to make use of the code developed for forecasting seasonal snow depth evolution, using a neural network with structurally-enforced constraints. The following steps through a basic use-case of the system on an already-cleaned dataset, though exploration of optional keyword arguments in the developed code and additional tools for scraping data (explained in the data tutorial) provide for a richer set of functionality.\n\nThe updates of the neural snow model follow the equation\n\nfracdzdt = mathcalMleft(z SWE φ R v T_air P_snowright)\n\nwhere\n\nt is the time (s),\nz is the snow depth (m),\nmathcalM is the neural network,\nSWE is the Snow Water Equivalent, or the height of water if all the snow melted (m),\nφ is the relative humidity (0-1),\nR is the solar radiation (W/m²).\nv is the wind speed (W/m²).\nT_air is the air temperature (degrees C).\nP_snow is the water equivalent rate of snow precipitation (m/s).\n\nThe model is a 1D model to permit utilization over any desired grid resolution and shape.\n\nWe will use the forcings and snow depth data as a validation of the model, so the initial conditions will be the initial value provided in the existing data.\n\nWe begin by importing the developed code to create and run the neural network, as well as some preliminary packages:\n\nusing ClimaLand\nusing DataFrames, CSV, HTTP, Dates, Flux, StatsBase, BSON\n\nThe code lives in an extenson that we have to manually load. The extension can be loaded only if \"DataFrames\", \"CSV\", \"HTTP\", \"Flux\", \"StatsBase\", \"BSON\", and \"ClimaLand\" are loaded.\n\nDataTools = Base.get_extension(ClimaLand, :NeuralSnowExt).DataTools\nModelTools = Base.get_extension(ClimaLand, :NeuralSnowExt).ModelTools;\n\nand also, for this tutorial, some purpose-made functions for displaying the output. A similar analysis_tools.jl file exists alongside display_tools.jl for some basic functions for analyzing/scoring the model, if desired.\n\nusing ClimaLand\ncode_dir = joinpath(pkgdir(ClimaLand), \"docs/src/tutorials/standalone/Snow\")\ninclude(joinpath(code_dir, \"display_tools.jl\"));\n\nNext, we set up values of the network hyperparameters, including the number of epochs to train it, as well as the width parameter n as outlined in the associated parameter, and the two loss function hyperparameters n_1, n_2.\n\nn = 4\nn1 = 2\nn2 = 4;\n\nWe next outline which variables in the dataset will be used as predictors, calling them by their column name as a Symbol. The number and choice of these can be changed to reflect any dataset. Another column is specified as the target variable, in this case, the fracdzdt column.\n\npred_vars = [\n    :z,\n    :SWE,\n    :rel_hum_avg,\n    :sol_rad_avg,\n    :wind_speed_avg,\n    :air_temp_avg,\n    :dprecipdt_snow,\n]\ntarget = :dzdt;\n\nSpecifying the indices of the depth and precipitation variables (used in the constraints) and the total number of input features will be necessary when creating the model, so we will specify them here as well.\n\nnfeatures = length(pred_vars)\nz_idx = 1\np_idx = 7;\n\nWe next read in the already-cleaned training dataset, though for custom datasets there is plenty of functionality provided in the DataTools module to scrape SNOTEL data directly. We also set the unit timestep seen in this data (daily, so 1 day) to be used for setting the network's constraints as well as generating timeseries during usage. To see the code that generated this data file, check out the data tutorial. We also specify the maximum gap size in the data (in units of Δt) that the network can traverse before requiring a reset, via hole_thresh.\n\ntraining_data_download_link = \"https://caltech.box.com/shared/static/1gfyh71c44ljzb9xbnza3lbzj6p9723x.csv\"\ntesting_data_download_link = \"https://caltech.box.com/shared/static/qb2ze1wcc1a37fgt5k9wsj27gpoh39ax.csv\"\ndata_train = CSV.read(HTTP.get(training_data_download_link).body, DataFrame)\nvaldata = CSV.read(HTTP.get(testing_data_download_link).body, DataFrame)\nΔt = Second(86400)\nhole_thresh = 5;\n\nWith this, we can begin the actual usage pipeline. First, we split the precipitation feature into rain and snow constituents, and apply a set of filters before extracting the necessary features with prep_data (the split already exists in the testing data):\n\nusedata = DataTools.prep_data(data_train);\n\nAfter this, we determine scalings for the input and target data that are conducive to beneficial weight updates. In this case, the target data during training will be scaled in the -1 to 1 range, and the neural network will scale input features according to their standard deviations (no shifting is carried out in this case, so that the physical meaning of \"0\" is preserved). This data is then converted into matrix form for ease of its conversion into a Flux DataLoader object, later, during training.\n\nout_scale = maximum(abs.(usedata[!, target]))\nin_scales = std.(eachcol(select(usedata, pred_vars)))\nx_train, y_train = DataTools.make_data(usedata, pred_vars, target, out_scale);\n\nWe then create the model itself given the hyperparameters specified above, and indicate which features are to be used to determine the boundary constraints on the network.\n\nmodel = ModelTools.make_model(\n    Float64,\n    nfeatures,\n    n,\n    z_idx,\n    p_idx,\n    in_scale = in_scales,\n)\n\nChain(\n  pred = SkipConnection(\n    Chain(\n      scale = Dense(7 => 7; bias=false),  # 49 parameters\n      l1 = Dense(7 => 28, relu),        # 224 parameters\n      l2 = Dense(28 => 7, elu),         # 203 parameters\n      l3 = Dense(7 => 1),               # 8 parameters\n    ),\n    vcat,\n  ),\n  get_boundaries = Parallel(\n    vcat,\n    up_bound = NeuralSnowExt.NeuralSnow.ModelTools.var\"#7#10\"{Int64}(7),\n    low_bound = NeuralSnowExt.NeuralSnow.ModelTools.var\"#8#11\"{Int64}(1),\n    output_pos = NeuralSnowExt.NeuralSnow.ModelTools.var\"#9#12\"(),\n  ),\n  final_scale = Dense(3 => 3; bias=false),  # 9 parameters\n  apply_relus = Dense(3 => 3, relu; bias=false),  # 9 parameters\n  apply_upper = Dense(3 => 2, relu; bias=false),  # 6 parameters\n  apply_lower = Dense(2 => 1; bias=false),  # 2 parameters\n)                   # Total: 11 arrays, 510 parameters, 2.918 KiB.\n\nAs training updates are better with the scaled data, we have to modify the timescale and output scaling of the model structure prior to training. This step is undone/reset after training is over.\n\nModelTools.settimescale!(model, Dates.value(Δt) * out_scale)\nModelTools.setoutscale!(model, 1.0);\n\nWith that, training is as simple as calling the trainmodel! function:\n\nprint(\"\\nTraining model!\\n\")\nModelTools.trainmodel!(model, x_train, y_train, n1, n2, verbose = true);\n\n\nTraining model!\n┌ Warning: Layer with Float32 parameters got Float64 input.\n│   The input will be converted, but any earlier layers may be very slow.\n│   layer = Dense(7 => 28, relu)  # 224 parameters\n│   summary(x) = \"7×64 Matrix{Float64}\"\n└ @ Flux ~/.julia/packages/Flux/1wZQP/src/layers/stateless.jl:60\nEpoch: 10 | training loss: 0.00758828074032483\nEpoch: 20 | training loss: 0.007410122650337617\nEpoch: 30 | training loss: 0.007410122650337617\nEpoch: 40 | training loss: 0.007410122650337617\nEpoch: 50 | training loss: 0.007410122650337617\nEpoch: 60 | training loss: 0.007416958266228475\nEpoch: 70 | training loss: 0.007511733659828737\nEpoch: 80 | training loss: 0.007410122650337617\nEpoch: 90 | training loss: 0.007440979245453872\nEpoch: 100 | training loss: 0.007410380360261381\n\n\nTo show the model's output on some of our training data in physically meaningful units, we first reset the timesacle and output scaling constants. From there, all we do is pass the dataframe for a given SNOTEL site and the trained model to the make_timeseries function, and we can compare the result to the actual data.\n\nModelTools.setoutscale!(model, out_scale)\nModelTools.settimescale!(model, Dates.value(Δt));\n\nFor instance, let's show the results on SNOTEL site 1286 (Slagamount Lakes site, Montana):\n\nNote that gaps in the data are shown as shaded regions on the plotted timeseries.\n\nsite_id = 1286\nsitedata = usedata[usedata[!, :id] .== site_id, :]\ntrue_series = sitedata[!, :z]\npred_series, _, _ =\n    ModelTools.make_timeseries(model, sitedata, Δt, hole_thresh = hole_thresh)\nptitle = \"Slagamount Lakes, Snow Depth (m)\"\nsiteplot(\n    ptitle,\n    sitedata[!, :date],\n    [true_series, pred_series],\n    [\"Data\", \"Neural Model\"],\n    [:black, :red],\n    savename = \"base_tutorial_plot1.png\",\n    display_plot = false,\n);\n\n┌ Warning: Layer with Float32 parameters got Float64 input.\n│   The input will be converted, but any earlier layers may be very slow.\n│   layer = Dense(7 => 28, relu)  # 224 parameters\n│   summary(x) = \"7-element Vector{Float64}\"\n└ @ Flux ~/.julia/packages/Flux/1wZQP/src/layers/stateless.jl:60\nGKS: cannot open display - headless operation mode active\n\n\n(Image: )\n\nOr, alternatively, SNOTEL site 1070 (Anchorage Hillside, Alaska) from the testing data:\n\nsite_id = \"1070\" #string format for the testing ids is due to non-numerical testing site codes.\nsitedata = valdata[valdata[!, :id] .== site_id, :]\ntrue_series = sitedata[!, :z]\npred_series, _, _ =\n    ModelTools.make_timeseries(model, sitedata, Δt, hole_thresh = hole_thresh)\nptitle = \"Anchorage Hillside, Snow Depth (m)\"\nsiteplot(\n    ptitle,\n    sitedata[!, :date],\n    [true_series, pred_series],\n    [\"Data\", \"Neural Model\"],\n    [:black, :red],\n    savename = \"base_tutorial_plot2.png\",\n    display_plot = false,\n);\n\n┌ Warning: Layer with Float32 parameters got Float64 input.\n│   The input will be converted, but any earlier layers may be very slow.\n│   layer = Dense(7 => 28, relu)  # 224 parameters\n│   summary(x) = \"7-element Vector{Float64}\"\n└ @ Flux ~/.julia/packages/Flux/1wZQP/src/layers/stateless.jl:60\n\n\n(Image: )\n\nAdditional functionality can be explored through the optional arguments to the developed functions, though creating timeseries for any validation dataset can be handled with a similar call to make_timeseries. The timestep Δt (as well as a matching call to the network with settimescale!) can also be changed to different values to evaluate the network's capability on validation data with different temporal resolutions, without the need for retraining.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/pmodel/","page":"P-model","title":"P-model","text":"The P-model is model for photosynthesis and stomatal conductance that extends the Farquhar model in two main ways: 1) it assumes that all plants adjust their internal CO2 concentration such that carbon assimilation is maximized relative to the combination of two costs—the cost of supporting RuBisCo-limited photosynthesis and the cost of transpiration through stomata; 2) it assumes that RuBisCo-limited and light-limited assimilation rates are equal, i.e., that A_c = A_j (coordination hypothesis). These two additional constraints allow for the prediction of photosynthetic parameters such as V_cmax, J_max, and stomatal conductance g_s. ","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/pmodel/#Usage-in-ClimaLand","page":"P-model","title":"Usage in ClimaLand","text":"The P-model differs from other canopy component models in two main ways: \n\nThe P-model encompasses both a photosynthesis model and a stomatal conductance model. Therefore, PModel must be used for photosynthesis iff PModelConductance is used for stomatal conductance. \nThe P-model requires an extra callback PModelCallback which checks if it is local noon every model timestep and updates the optimal parameters according to local noon (see Implementation for scientific background). When you are constructing a simulation via LandSimulation, this callback will be constructed and added to your simulation automatically.","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/pmodel/#Theory","page":"P-model","title":"Theory","text":"The first assumption, which we'll call the \"cost minimization principle\", can be mathematically written as follows. We define a cost which is dependent on the transpiration E, maximum rate of Rubisco limited photosynthesis V_cmax, normalized to the rate of assimilation A:\n\nmathrmCost = a fracEA + b fracV_cmaxA\n\nHere, a and b are dimensionless numbers that represent the relative weight of each cost. Minimization of this cost represents the general principle that plants seek to maximize assimilation while keeping water loss low (E term) and not overly investing in synthesizing Rubisco protein. The parameter which is adjusted is chi = dfracc_ic_a, the ratio of internal to ambient (external) CO2 concentration. Thus, the first constraint is mathematically written as\n\na fracpartial (EA)partial chi = -b fracpartial (V_cmax  A) partial chi\n\nThe second assumption, called the \"coordination hypothesis\" (see Chen et al., 1993), states that V_cmax varies according to APAR such that it is neither in excess or in deficit of what is required for full utilization of the light. Mathematically, this means that A_c = A_j. These two constraints, when added to the Farquhar model, allows for the computation of V_cmax, J_max, and xi (sensitivity parameter to VPD; see Wang 2017) from environmental conditions: \n\nbeginalign*\nxi^mathrmopt = sqrt dfracbeta(K + Gamma^*)eta^* D_H_2OD_CO_2  02in\nJ_max^mathrmopt = dfrac4phi_0 cdot  mathrmAPARsqrt left beta_m^2left(1 - left c^* dfracc_i + 2Gamma^*c_i - Gamma^* right^23 right) right^-1 - 1  02in\nV_cmax^mathrmopt = phi_0 beta_m cdot mathrmAPAR cdot dfracc_i + Kc_i + 2Gamma^* sqrt 1 - left c^*  dfracc_i+ 2Gamma^*c_i - Gamma^*right^23 \nendalign*\n\nWe refer the reader to the Farquhar docs page for definitions of the biochemical parameters referenced above.","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/pmodel/#Implementation","page":"P-model","title":"Implementation","text":"We follow the scheme of Mengoli et al., (2022) who propose updating optimal parameters V_cmax 25, J_max25, and xi according to conditions at local noon (near maximal APAR). These are then timestepped via the forward Euler discretization of the following ODE: \n\ntau dfrac dbarxdt = barx - x implies barx_t+1 = alpha barx_t + (1 - alpha) x_t+1\n\nwhere barx is the acclimated parameter, x is the parameter computed at local noon, alpha = 1 - dfracDelta ttau and tau is the timescale of acclimation. Since we update this equation every local noon, Delta t is 1 day and tau = 15 days corresponds to alpha = dfrac1415 approx 0933 (the default timescale used in Mengoli 2022). The optimal variables barx are stored in the model cache in p.canopy.photosynthesis.OptVars.  \n\nAt every model timestep, the latest acclimated values V_cmax 25^mathrmopt, J_max 25^mathrmopt, are then adjusted via modified-Arrhenius type functions of form \n\nV_cmax = V_cmax 25^mathrmopt cdot underbrace exp left( dfracDelta H_a(T - T_0)T_0 TR right) _ textactivation (Arrhenius)  cdot underbrace dfrac1 + e^(T_0Delta S - Delta H_d)RT_01 + e^(TDelta S - Delta H_d)RT  _ textdeactivation \n\nwhere Delta H_a, Delta H_d are standard enthalpies of activation and deactivation, T_0 = 29815 K is the reference temperature, and Delta S is the entropy change in deactivation. The acclimated xi^mathrmopt is used to compute the instantaneous intercellular CO2 concentration c_i\n\nc_i =dfrac xi^mathrmopt c_a + Gamma^* sqrt max(D0) xi^mathrmopt + sqrt max(D0) \n\nwhere D is the vapor pressure deficit (VPD). Finally, carboxylation- and light-limited assimilation is computed as\n\nbeginalign*\nA_c = V_cmax dfracc_i - Gamma^*c_i + K \nA_j = dfrac14 underbrace dfrac4phi_0 I_abssqrt 1 + left(dfrac4phi_0I_absJ_maxright)^2  _ J  cdot dfracc_i - Gamma^*c_i + 2 Gamma^*\nendalign*\n\nThe remaining steps for computing A_n and upscaling to canopy-level GPP are identical to the Farquhar model.\n\nThe P-model also gives a stomatal conductance model because it predicts chi = dfracc_ac_i. From Fick's law, we have that \n\ng_s = dfracD_H_2OD_CO_2 dfracA_nc_a- c_i\n\nwhere dfracD_H_2OD_CO_2 approx 16 is treated as a constant (Drel) in our model. ","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/pmodel/#Citations","page":"P-model","title":"Citations","text":"Chen, J.-L., Reynolds, J. F., Harley, P. C. & Tenhunen, J. D. Coordination theory of leaf nitrogen distribution in a canopy. Oecologia 93, 63–69 (1993)\n\nMengoli, G., Agustí-Panareda, A., Boussetta, S., Harrison, S. P., Trotta, C., & Prentice, I. C. (2022). Ecosystem photosynthesis in land-surface models: A first-principles approach incorporating acclimation. Journal of Advances in Modeling Earth Systems, 14, e2021MS002767. https://doi.org/10.1029/2021MS002767\n\nStocker, B. D., Wang, H., Smith, N. G., Harrison, S. P., Keenan, T. F., Sandoval, D., Davis, T., & Prentice, I. C. (2020). P-model v1.0: An optimality-based light use efficiency model for simulating ecosystem gross primary production. Geoscientific Model Development, 13(3), 1545–1581. https://doi.org/10.5194/gmd-13-1545-2020\n\nWang, H., Prentice, I. C., Keenan, T. F., Davis, T. W., Wright, I. J., Cornwell, W. K., Evans, B. J., & Peng, C. (2017). Towards a universal model for carbon dioxide uptake by plants. Nature Plants, 3(9), 734–741. https://doi.org/10.1038/s41477-017-0006-8","category":"section"},{"location":"julia/#Julia-Background","page":"Julia background","title":"Julia Background","text":"New to Julia? We're glad you've found us, and hope you'll like it as much as we do!\n\nThe Julia manual is a very helpful resource, and we recommend reading through it while getting started with the language.\n\nIf you don't have it already, Julia can be downloaded from https://julialang.org/downloads/.","category":"section"},{"location":"julia/#Julia-REPL","page":"Julia background","title":"Julia REPL","text":"The Julia REPL provides a convenient interface to interactively run Julia code, similar in spirit to a Jupyter notebook. To start a Julia REPL, simply run the command julia from your terminal.\n\nMany of our tutorials are designed to be run within the REPL, to see live output as you set up and run the simulation (though they can also be run from the command line).","category":"section"},{"location":"julia/#Julia-environments","page":"Julia background","title":"Julia environments","text":"Julia environments are specified by a Project.toml and a Manifest.toml. The Project.toml lists all packages required to setup the environment, as well as a list of package version requirements (under compat), and additional optional information. The Manifest.toml is automatically generated from the Project.toml and contains more detailed information about the specific package versions to be used when setting up the environment.\n\nAdditional details about Julia environments can be found on the Code Loading manual page.\n\nThe ClimaLand.jl package contains three Julia environments: the top-level ClimaLand.jl environment, a docs/ environment, and a .buildkite/ environment. When running simulations (e.g. tests, experiments, or other simulations), the .buildkite environment should be used. You can enter this environment using the following command from the terminal:\n\njulia --project=.buildkite","category":"section"},{"location":"julia/#Handy-Julia-tools","page":"Julia background","title":"Handy Julia tools","text":"","category":"section"},{"location":"julia/#Revise.jl","page":"Julia background","title":"Revise.jl","text":"One downside to Julia is that it requires (often time-consuming) precompilation. During local development, any source code that has been changed will need to be precompiled again to incorporate the new changes. Given that our package depends on many others, this can take some time.\n\nRevise.jl has been developed to minimize this latency, and is very useful in doing so. Their documentation provides more information about how the package works.\n\nTo install Revise and load it whenever you start Julia, first add it to your base Julia environment. Enter your base Julia environment by simply running julia from the terminal, then run the following:\n\njulia> using Pkg\njulia> Pkg.add(Revise)\n\nNext, create the file ~/.julia/config/startup.jl and add the following line to it: using Revise. This will load Revise anytime you start a Julia session in any local Julia environment.","category":"section"},{"location":"julia/#Juliaup","page":"Julia background","title":"Juliaup","text":"Juliaup is a useful tool to manage installed Julia versions. It allows you to easily download new versions, remove old ones, set a default version, and switch between multiple installed versions.\n\nPlease see the documentation for more information and details about installing juliaup.","category":"section"}]
}
