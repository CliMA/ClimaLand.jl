'use strict';

var url = require('url');
var clientCommon = require('@algolia/client-common');
var http = require('http');
var https = require('https');

function echoRequester(status = 200) {
    return clientCommon.createEchoRequester({ getURL: (url$1) => new url.URL(url$1), status });
}

// Global agents allow us to reuse the TCP protocol with multiple clients
const agentOptions = { keepAlive: true };
const defaultHttpAgent = new http.Agent(agentOptions);
const defaultHttpsAgent = new https.Agent(agentOptions);
function createHttpRequester({ agent: userGlobalAgent, httpAgent: userHttpAgent, httpsAgent: userHttpsAgent, requesterOptions = {}, } = {}) {
    const httpAgent = userHttpAgent || userGlobalAgent || defaultHttpAgent;
    const httpsAgent = userHttpsAgent || userGlobalAgent || defaultHttpsAgent;
    function send(request) {
        return new Promise((resolve) => {
            let responseTimeout;
            // eslint-disable-next-line prefer-const -- linter thinks this is not reassigned
            let connectTimeout;
            const url$1 = new url.URL(request.url);
            const path = url$1.search === null ? url$1.pathname : `${url$1.pathname}${url$1.search}`;
            const options = {
                agent: url$1.protocol === 'https:' ? httpsAgent : httpAgent,
                hostname: url$1.hostname,
                path,
                method: request.method,
                ...requesterOptions,
                headers: {
                    ...request.headers,
                    ...requesterOptions.headers,
                },
            };
            if (url$1.port && !requesterOptions.port) {
                options.port = url$1.port;
            }
            const req = (url$1.protocol === 'https:' ? https : http).request(options, (response) => {
                let contentBuffers = [];
                response.on('data', (chunk) => {
                    contentBuffers = contentBuffers.concat(chunk);
                });
                response.on('end', () => {
                    clearTimeout(connectTimeout);
                    clearTimeout(responseTimeout);
                    resolve({
                        status: response.statusCode || 0,
                        content: Buffer.concat(contentBuffers).toString(),
                        isTimedOut: false,
                    });
                });
            });
            const createTimeout = (timeout, content) => {
                return setTimeout(() => {
                    req.destroy();
                    resolve({
                        status: 0,
                        content,
                        isTimedOut: true,
                    });
                }, timeout);
            };
            connectTimeout = createTimeout(request.connectTimeout, 'Connection timeout');
            req.on('error', (error) => {
                clearTimeout(connectTimeout);
                clearTimeout(responseTimeout);
                resolve({ status: 0, content: error.message, isTimedOut: false });
            });
            req.once('response', () => {
                clearTimeout(connectTimeout);
                responseTimeout = createTimeout(request.responseTimeout, 'Socket timeout');
            });
            if (request.data !== undefined) {
                req.write(request.data);
            }
            req.end();
        });
    }
    return { send };
}

exports.createHttpRequester = createHttpRequester;
exports.echoRequester = echoRequester;
