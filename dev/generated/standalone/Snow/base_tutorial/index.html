<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Base tutorial · ClimaLand.jl</title><meta name="title" content="Base tutorial · ClimaLand.jl"/><meta property="og:title" content="Base tutorial · ClimaLand.jl"/><meta property="twitter:title" content="Base tutorial · ClimaLand.jl"/><meta name="description" content="Documentation for ClimaLand.jl."/><meta property="og:description" content="Documentation for ClimaLand.jl."/><meta property="twitter:description" content="Documentation for ClimaLand.jl."/><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../search_index.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.svg" alt="ClimaLand.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">ClimaLand.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><a class="tocitem" href="../../../../fundamental_concepts/">Fundamental Concepts</a></li><li><a class="tocitem" href="../../../../getting_started/">Running your first simulation</a></li><li><a class="tocitem" href="../../../../available_models/">Available Models and Parameterizations</a></li><li><a class="tocitem" href="../../../../parameters/">Parameters</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox" checked/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Running standalone component simulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Bucket/bucket_tutorial/">Bucket</a></li><li><input class="collapse-toggle" id="menuitem-6-1-2" type="checkbox"/><label class="tocitem" for="menuitem-6-1-2"><span class="docs-label">Soil</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Soil/boundary_conditions/">Boundary conditions</a></li><li><a class="tocitem" href="../../Soil/richards_equation/">Richards Equation</a></li><li><a class="tocitem" href="../../Soil/soil_energy_hydrology/">Energy and Hydrology</a></li><li><input class="collapse-toggle" id="menuitem-6-1-2-4" type="checkbox"/><label class="tocitem" for="menuitem-6-1-2-4"><span class="docs-label">Phase Changes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Soil/freezing_front/">Modeling a freezing front in unsaturated soil</a></li><li><a class="tocitem" href="../../Soil/phase_change_analytic/">The Stefan problem</a></li></ul></li><li><a class="tocitem" href="../../Soil/layered_soil/">Layered Soil</a></li><li><a class="tocitem" href="../../Soil/evaporation/">Coarse Sand Evaporation</a></li><li><a class="tocitem" href="../../Soil/evaporation_gilat_loess/">Gilat Loess Evaporation</a></li><li><a class="tocitem" href="../../Soil/sublimation/">Bare soil site</a></li><li><a class="tocitem" href="../../Soil/changing_soil_parameterizations/">Changing soil parameterizations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-1-3" type="checkbox"/><label class="tocitem" for="menuitem-6-1-3"><span class="docs-label">Canopy</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Canopy/default_canopy/">Default canopy</a></li><li><a class="tocitem" href="../../Canopy/canopy_tutorial/">Default canopy fluxtower simulation </a></li><li><a class="tocitem" href="../../Canopy/changing_canopy_parameterizations/">Changing canopy parameterizations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-1-4" type="checkbox" checked/><label class="tocitem" for="menuitem-6-1-4"><span class="docs-label">Snow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Base tutorial</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Setup:"><span>Setup:</span></a></li><li class="toplevel"><a class="tocitem" href="#Data-Preparation:"><span>Data Preparation:</span></a></li><li class="toplevel"><a class="tocitem" href="#Model-Setup:"><span>Model Setup:</span></a></li><li><a class="tocitem" href="#The-Model:"><span>The Model:</span></a></li><li><a class="tocitem" href="#The-Constraints:"><span>The Constraints:</span></a></li><li><a class="tocitem" href="#Creating-and-Training-a-ConstrainedNeuralModel:"><span>Creating and Training a <code>ConstrainedNeuralModel</code>:</span></a></li><li class="toplevel"><a class="tocitem" href="#Results:"><span>Results:</span></a></li><li class="toplevel"><a class="tocitem" href="#Saving-and-Loading-Models:"><span>Saving and Loading Models:</span></a></li></ul></li><li><a class="tocitem" href="../data_tutorial/">Data tutorial</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Running Fluxnet simulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../integrated/soil_canopy_fluxnet_tutorial/">Canopy and soil</a></li><li><a class="tocitem" href="../../../integrated/snowy_land_fluxnet_tutorial/">Canopy, soil, and snow</a></li><li><a class="tocitem" href="../../../integrated/changing_snowy_land_parameterizations/">Changing LandModel parameterizations</a></li><li><a class="tocitem" href="../../../integrated/fluxnet_data/">Data processing</a></li><li><a class="tocitem" href="../../../integrated/fluxnet_vis/">Visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Running global simulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../global/bucket/">Bucket</a></li><li><a class="tocitem" href="../../../global/snowy_land/">Snow, soil, canopy</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Calibrating a ClimaLand model</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../calibration/perfect_model_site_level_calibration/">Single site perfect model</a></li><li><a class="tocitem" href="../../../calibration/obs_site_level_calibration/">Single site observations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Running coupled simulations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Bucket/coupled_bucket/">Coupled bucket model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">For model developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Usage/model_tutorial/">Intro to standalone models</a></li><li><input class="collapse-toggle" id="menuitem-6-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-6-2"><span class="docs-label">Intro to multi-component models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Usage/LSM_single_column_tutorial/">Single column tutorial</a></li><li><a class="tocitem" href="../../../integrated/handling_soil_fluxes/">Adjusting boundary conditions for the soil</a></li><li><a class="tocitem" href="../../../integrated/handling_snow_fluxes/">Adjusting boundary conditions for the snow</a></li></ul></li><li><a class="tocitem" href="../../Usage/domain_tutorial/">Intro to ClimaLand Domains</a></li><li><a class="tocitem" href="../../../shared_utilities/driver_tutorial/">Intro to forced site-level runs</a></li><li><a class="tocitem" href="../../../shared_utilities/timestepping/">Intro to implicit/explicit timestepping</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Writing and accessing outputs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../diagnostics/users_diagnostics/">For users</a></li><li><a class="tocitem" href="../../../../diagnostics/developers_diagnostics/">For developers</a></li><li><a class="tocitem" href="../../../../diagnostics/available_diagnostics/">Available diagnostics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Model Equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Vegetation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1-1"><span class="docs-label">Radiative transfer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/radiative_transfer/beer_model/">Beer model</a></li><li><a class="tocitem" href="../../../../standalone/pages/vegetation/radiative_transfer/twostream_model/">Two-Stream model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-1-2" type="checkbox"/><label class="tocitem" for="menuitem-8-1-2"><span class="docs-label">Photosynthesis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/photosynthesis/farquhar_model/">Farquhar model</a></li><li><a class="tocitem" href="../../../../standalone/pages/vegetation/photosynthesis/pmodel/">P-model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-1-3" type="checkbox"/><label class="tocitem" for="menuitem-8-1-3"><span class="docs-label">Stomatal conductance</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/stomatal_conductance/medlyn_model/">Medlyn model</a></li><li><a class="tocitem" href="../../../../standalone/pages/vegetation/photosynthesis/pmodel/">P-model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-1-4" type="checkbox"/><label class="tocitem" for="menuitem-8-1-4"><span class="docs-label">Plant hydraulics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/plant_hydraulics/prognostic/">Prognostic model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-1-5" type="checkbox"/><label class="tocitem" for="menuitem-8-1-5"><span class="docs-label">Solar Induced Fluorescence</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/solar_induced_fluorescence/lee_model/">Lee model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-1-6" type="checkbox"/><label class="tocitem" for="menuitem-8-1-6"><span class="docs-label">Canopy structure</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/canopy_structure/prescribed_structure/">Prescribed structure</a></li><li><a class="tocitem" href="../../../../standalone/pages/vegetation/canopy_structure/optimal_lai/">Optimal LAI</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-1-7" type="checkbox"/><label class="tocitem" for="menuitem-8-1-7"><span class="docs-label">Canopy energy</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/canopy_energy/canopy_energy/">Physics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-1-8" type="checkbox"/><label class="tocitem" for="menuitem-8-1-8"><span class="docs-label">Canopy energy</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/turbulent_fluxes/turbulent_fluxes/">Physics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-1-9" type="checkbox"/><label class="tocitem" for="menuitem-8-1-9"><span class="docs-label">Soil moisture stress</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/soil_moisture_stress/piecewise_model/">Piecewise model</a></li><li><a class="tocitem" href="../../../../standalone/pages/vegetation/soil_moisture_stress/tuzet_model/">Tuzet model</a></li><li><a class="tocitem" href="../../../../standalone/pages/vegetation/soil_moisture_stress/no_moisture_stress/">No moisture stress</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-1-10" type="checkbox"/><label class="tocitem" for="menuitem-8-1-10"><span class="docs-label">Autotrophic respiration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/vegetation/autotrophic_respiration/jules_model/">JULES model</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Soil</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-2-1" type="checkbox"/><label class="tocitem" for="menuitem-8-2-1"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/soil/physics/richards_model/">Richards model</a></li><li><a class="tocitem" href="../../../../standalone/pages/soil/physics/energy_model/">Energy+Hydrology model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2-2"><span class="docs-label">Biogeochemistry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/soil/biogeochemistry/DAMM_model/">DAMM model</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Snow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../standalone/pages/snow/snow_model/">Snow model</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Calibration and benchmark</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../calibration/">Calibrating model parameters</a></li><li><a class="tocitem" href="../../../../leaderboard/leaderboard/">Model Benchmark</a></li></ul></li><li><a class="tocitem" href="../../../../architectures/">Running on GPU or with MPI</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Additional resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../repo_structure/">Repository structure</a></li><li><a class="tocitem" href="../../../../restarts/">Restarting a simulation</a></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Software utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../itime/">ITime type</a></li><li><a class="tocitem" href="../../../../shared_utilities/">Shared utilities</a></li></ul></li><li><a class="tocitem" href="../../../../physical_units/">Physical units</a></li></ul></li><li><a class="tocitem" href="../../../../julia/">Julia background</a></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">APIs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-13-1" type="checkbox"/><label class="tocitem" for="menuitem-13-1"><span class="docs-label">Soil</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../APIs/soil/Soil/">Soil Energy and Hydrology</a></li><li><a class="tocitem" href="../../../../APIs/soil/SoilSourcesandBCs/">Soil Sources and Boundary Conditions</a></li><li><a class="tocitem" href="../../../../APIs/soil/SoilBiogeochemistry/">Soil Biogeochemistry</a></li><li><a class="tocitem" href="../../../../APIs/soil/SoilAlbedo/">Soil Albedo</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13-2" type="checkbox"/><label class="tocitem" for="menuitem-13-2"><span class="docs-label">Canopy</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../APIs/canopy/Canopy/">Canopy Models</a></li><li><a class="tocitem" href="../../../../APIs/canopy/PlantHydraulics/">Plant Hydraulics</a></li><li><a class="tocitem" href="../../../../APIs/canopy/Biomass/">Leaf, stem, root dynamics</a></li><li><a class="tocitem" href="../../../../APIs/canopy/LAI/">Optimal LAI</a></li><li><a class="tocitem" href="../../../../APIs/canopy/Photosynthesis/">Photosynthesis</a></li><li><a class="tocitem" href="../../../../APIs/canopy/RadiativeTransfer/">Radiative Transfer</a></li><li><a class="tocitem" href="../../../../APIs/canopy/CanopyEnergy/">Energy</a></li><li><a class="tocitem" href="../../../../APIs/canopy/StomatalConductance/">Stomatal Conductance</a></li><li><a class="tocitem" href="../../../../APIs/canopy/AutotrophicRespiration/">Autotrophic Respiration</a></li></ul></li><li><a class="tocitem" href="../../../../APIs/SurfaceWater/">Surface Water Models</a></li><li><a class="tocitem" href="../../../../APIs/Bucket/">Bucket Model</a></li><li><a class="tocitem" href="../../../../APIs/Snow/">Snow Model</a></li><li><a class="tocitem" href="../../../../APIs/ClimaLand/">Integrated Models</a></li><li><input class="collapse-toggle" id="menuitem-13-7" type="checkbox"/><label class="tocitem" for="menuitem-13-7"><span class="docs-label">Shared Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../APIs/AbstractModels/">Abstract Models and Functions</a></li><li><a class="tocitem" href="../../../../APIs/AuxiliaryVariablesCache/">Auxiliary Variables Cache</a></li><li><a class="tocitem" href="../../../../APIs/Callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../../APIs/Domains/">Domains</a></li><li><a class="tocitem" href="../../../../APIs/Drivers/">Drivers</a></li><li><a class="tocitem" href="../../../../APIs/Simulations/">Simulations</a></li><li><a class="tocitem" href="../../../../APIs/SolverFunctions/">Solver Functions</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../../contributing/">Contributor guide</a></li><li><a class="tocitem" href="../../../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Running standalone component simulations</a></li><li><a class="is-disabled">Snow</a></li><li class="is-active"><a href>Base tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Base tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaLand.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaLand.jl/../../../../.." title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ConstrainedNeuralModels:-Generating-Seasonal-Snow-Timeseries-with-a-Constrained-Neural-Network"><a class="docs-heading-anchor" href="#ConstrainedNeuralModels:-Generating-Seasonal-Snow-Timeseries-with-a-Constrained-Neural-Network"><code>ConstrainedNeuralModels</code>: Generating Seasonal Snow Timeseries with a Constrained Neural Network</a><a id="ConstrainedNeuralModels:-Generating-Seasonal-Snow-Timeseries-with-a-Constrained-Neural-Network-1"></a><a class="docs-heading-anchor-permalink" href="#ConstrainedNeuralModels:-Generating-Seasonal-Snow-Timeseries-with-a-Constrained-Neural-Network" title="Permalink"></a></h1><p>This tutorial gives an example of how to use the <code>ConstrainedNeuralModels</code> module to forecast seasonal snow depth evolution, using a predictive model with structurally-enforced constraints. The following steps through a basic use-case of the module on an already-cleaned dataset, though exploration of the optional arguments in the data scraping tools (explained in the <a href="../data_tutorial/">data tutorial</a>) allow for additional functionality. The <code>ConstrainedNeuralModels</code> module can also be used to develop models for other systems, like the <a href="https://caltech.box.com/v/paper-model-albedo">NeuralAlbedoModel</a> used in ClimaLand (<a href="https://github.com/CliMA/ClimaLand.jl/blob/main/ext/constrained_nn/NeuralSnow.jl">source code</a>).</p><h3 id="Model-Equation:"><a class="docs-heading-anchor" href="#Model-Equation:">Model Equation:</a><a id="Model-Equation:-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Equation:" title="Permalink"></a></h3><p>The updates of the neural snow depth model follow the equation</p><p><span>$\frac{dz}{dt} = \mathcal{M}\left(z, SWE, φ, R, v, T_{air}, P_{snow}\right),$</span></p><p>where</p><ul><li><p><span>$t$</span> is the time (s),</p></li><li><p><span>$z$</span> is the snow depth (m),</p></li><li><p><span>$\mathcal{M}$</span> is the neural network,</p></li><li><p><span>$SWE$</span> is the Snow Water Equivalent, or the height of water if all the snow melted (m),</p></li><li><p><span>$φ$</span> is the relative humidity (0-1),</p></li><li><p><span>$R$</span> is the solar radiation (W/m²).</p></li><li><p><span>$v$</span> is the wind speed (W/m²).</p></li><li><p><span>$T_{air}$</span> is the air temperature (degrees C).</p></li><li><p><span>$P_{snow}$</span> is the water equivalent rate of snow precipitation (m/s).</p></li></ul><p>The model is a 1D model, to permit utilization over any desired grid resolution and shape.</p><p>We will use the forcings and snow depth data as a validation of the model, so the initial conditions will be the initial value provided in the existing data.</p><h1 id="Setup:"><a class="docs-heading-anchor" href="#Setup:">Setup:</a><a id="Setup:-1"></a><a class="docs-heading-anchor-permalink" href="#Setup:" title="Permalink"></a></h1><p>We begin by importing the developed code to create and run the neural network, as well as some preliminary packages:</p><pre><code class="language-julia hljs">using ClimaLand
using DataFrames, Dates, Statistics, Downloads #dependencies for the SNOTEL Scraper extension
using Flux, StaticArrays, JLD2, InteractiveUtils #dependencies for the ConstrainedNeuralModel extension</code></pre><p>The code lives in an extenson that we have to manually load. The extension can be loaded only if its package dependencies and <code>ClimaLand</code> are loaded.</p><pre><code class="language-julia hljs">DataTools = Base.get_extension(ClimaLand, :SNOTELScraperExt).DataTools
ConstrainedNeuralModelExt =
    Base.get_extension(ClimaLand, :ConstrainedNeuralModelExt)
using .ConstrainedNeuralModelExt.ConstrainedNeuralModels
CNM = ConstrainedNeuralModels; #for referring to internal functions with less typing!</code></pre><p>Depending on personal preference, you could also do <code>CNM = Base.get_extension(...[same thing]...).ConstrainedNeuralModels</code> and skip the &quot;using&quot; statement, like how <code>DataTools</code> was handled, though you would instead need to add &quot;<code>CNM.</code>&quot; in front of each appropriate function/macro.</p><p>For this tutorial, we also include some purpose-made functions for displaying the output and building our loss function:</p><pre><code class="language-julia hljs">code_dir = joinpath(pkgdir(ClimaLand), &quot;docs/src/tutorials/standalone/Snow&quot;)
include(joinpath(code_dir, &quot;tutorial_tools.jl&quot;));</code></pre><h1 id="Data-Preparation:"><a class="docs-heading-anchor" href="#Data-Preparation:">Data Preparation:</a><a id="Data-Preparation:-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Preparation:" title="Permalink"></a></h1><p>We next read in the already-cleaned <a href="https://caltech.box.com/v/neuralsnow-training-data">training</a> and <a href="https://caltech.box.com/v/neuralsnow-testing-data">testing</a> datasets, though for custom datasets there is plenty of functionality provided in the <code>DataTools</code> module to scrape SNOTEL data directly. We also set the unit timestep seen in this data (daily, so 1 day) to be used for setting the network&#39;s constraints as well as generating timeseries during usage. To see the code that generated the training data file, check out the <a href="../data_tutorial/">data tutorial</a>. We also specify the maximum gap size in the data (in units of Δt) that the network can traverse before requiring a reset, via <code>hole_thresh</code>, and pick the float-type as <code>Float32</code>.</p><pre><code class="language-julia hljs">training_data_download_link = &quot;https://caltech.box.com/shared/static/1gfyh71c44ljzb9xbnza3lbzj6p9723x.csv&quot;
testing_data_download_link = &quot;https://caltech.box.com/shared/static/qb2ze1wcc1a37fgt5k9wsj27gpoh39ax.csv&quot;
data_train = DataTools.df_from_url(training_data_download_link) # If using the CSV and HTTP modules, you could also use:
valdata = DataTools.df_from_url(testing_data_download_link) # CSV.read(HTTP.get(testing_data_download_link).body, DataFrame)

FT = Float32
Δt = Second(86400)
hole_thresh = 5;</code></pre><p>With the data now loaded, we use the <code>prep_data</code> function to split the precipitation feature into rain and snow constituents with a <a href="https://www.nature.com/articles/s41467-018-03629-7">logistical model</a> of air temperature and humidity, apply a set of training-applicable filters, and extract the necessary features with <code>prep_data</code> (the precipitation split already exists in the testing data):</p><pre><code class="language-julia hljs">usedata = DataTools.prep_data(data_train);</code></pre><p>We next outline which variables in the dataset will be used as predictors, calling them by their column name as a <code>Symbol</code>. The number and choice of these can be changed to reflect any dataset. Another column is specified as the target variable, in this case, the <span>$\frac{dz}{dt}$</span> column.</p><pre><code class="language-julia hljs">pred_vars = [
    :z,
    :SWE,
    :rel_hum_avg,
    :sol_rad_avg,
    :wind_speed_avg,
    :air_temp_avg,
    :dprecipdt_snow,
]
target = :dzdt;</code></pre><p>After this, we determine scalings for the input and target data that are conducive to beneficial weight updates. For this tutorial, the target data during training will be scaled in the -1 to 1 range, and the neural network will scale input features according to their standard deviations (no shifting is carried out, so that the physical meaning of &quot;0&quot; is preserved). This data is then converted into <code>Matrix</code> form for ease of its conversion into a Flux <code>DataLoader</code> object later. The <code>DataTools</code> module contains a function <code>make_data</code> to handle this for you directly from a <code>DataFrame</code>, which extracts the pertinent variables,scales the target appropriately by <code>out_scale</code>, and returns the data <code>Matrix</code>:</p><pre><code class="language-julia hljs">out_scale = FT.(maximum(abs.(usedata[!, target])))
in_scales = FT.(1 ./ std.(eachcol(select(usedata, pred_vars))))
x_train, y_train = DataTools.make_data(usedata, pred_vars, target, out_scale);</code></pre><h1 id="Model-Setup:"><a class="docs-heading-anchor" href="#Model-Setup:">Model Setup:</a><a id="Model-Setup:-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Setup:" title="Permalink"></a></h1><p>When using the <code>ConstrainedNeuralModels</code> module, to create a constrained neural model, one only needs to specify the desired predictive model, and the constraint functions to constrain it.</p><h2 id="The-Model:"><a class="docs-heading-anchor" href="#The-Model:">The Model:</a><a id="The-Model:-1"></a><a class="docs-heading-anchor-permalink" href="#The-Model:" title="Permalink"></a></h2><p>First, we set up values of the predictive network&#39;s hyperparameters, the width parameter <span>$n$</span> as outlined in the associated paper <a href="../../../../references/#Charbonneau2025">Charbonneau <em>et al.</em> [20]</a>, and the two loss function hyperparameters <span>$n_1$</span>, <span>$n_2$</span>.</p><pre><code class="language-julia hljs">n = 4
n1 = 2
n2 = 4;</code></pre><p>Specifying the indices of the depth and precipitation variables (used in the constraints) and the total number of input features will be useful when creating the model, so we will specify them here as well.</p><pre><code class="language-julia hljs">nfeatures = length(pred_vars)
const z_idx::Int = 1
const p_idx::Int = 7;</code></pre><p>We then specify the internal predictive component of our constrained network, a small feed-forward neural network (a <code>Flux.Chain</code>) of 3 <code>Dense</code> layers. This internal prediction model need not be a <code>Flux.Chain</code> or even a neural network - it can take any form/size/complexity you like (including other custom-built functions and layers), as long as it is a valid functor with a defined input function <code>(model::MyFunction)(x)</code>.</p><pre><code class="language-julia hljs">pred_model = Chain(
    l1 = Dense(nfeatures, nfeatures * n, relu),
    l2 = Dense(nfeatures * n, nfeatures, elu),
    l3 = Dense(nfeatures, 1),
);</code></pre><h2 id="The-Constraints:"><a class="docs-heading-anchor" href="#The-Constraints:">The Constraints:</a><a id="The-Constraints:-1"></a><a class="docs-heading-anchor-permalink" href="#The-Constraints:" title="Permalink"></a></h2><h3 id="Constraint-Types"><a class="docs-heading-anchor" href="#Constraint-Types">Constraint Types -</a><a id="Constraint-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Types" title="Permalink"></a></h3><p>Constraint functions must only take two arguments, <code>pred</code> (the output of the predictive model) and <code>input</code> (the input to the predictive model), and have a declared output type. Explicitly supported constraint types can be classified as <code>static</code> (fixed models, for optimal performance when applying them in simulations on GPUs) or <code>dynamic</code> (mutable models where weights can be changed, for training or prototyping) types, as well as <code>batched</code> or <code>single</code> evaluation modes, based on declared arg/return types:</p><table><tr><th style="text-align: right"><strong>:dynamic</strong> Mode</th><th style="text-align: right"><strong><code>:single</code></strong></th><th style="text-align: right"><strong><code>:batched</code></strong></th></tr><tr><td style="text-align: right"><code>pred::T1</code></td><td style="text-align: right"><code>T1 &lt;: Vector{FT}</code> (length 1)</td><td style="text-align: right"><code>T1 &lt;: Matrix{FT}</code> (size (1, N))</td></tr><tr><td style="text-align: right"><code>input::T2</code></td><td style="text-align: right"><code>T2 &lt;: AbstractArray{FT}</code></td><td style="text-align: right"><code>T2 &lt;: AbstractArray{FT}</code></td></tr><tr><td style="text-align: right">return</td><td style="text-align: right"><code>::FT</code></td><td style="text-align: right"><code>::T1</code></td></tr></table><table><tr><th style="text-align: right"><strong>:static</strong> Mode</th><th style="text-align: right"><strong><code>:single</code></strong></th><th style="text-align: right"><strong><code>:batched</code></strong></th></tr><tr><td style="text-align: right"><code>pred::T1</code></td><td style="text-align: right"><code>T1 &gt;: SVector{1, FT}</code></td><td style="text-align: right"><code>T1 &gt;: SMatrix{1, N, FT, N} where {N&lt;:Int}</code></td></tr><tr><td style="text-align: right"><code>input::T2</code></td><td style="text-align: right"><code>T2 &lt;: StaticArray{S, FT} where {S}</code></td><td style="text-align: right"><code>T2 &lt;: StaticArray{S, FT} where {S}</code></td></tr><tr><td style="text-align: right">return</td><td style="text-align: right"><code>::FT</code></td><td style="text-align: right"><code>::T1</code></td></tr></table><p>In all cells above, a <code>where {FT&lt;:AbstractFloat}</code> is implied to indicate that the <code>eltype</code> of <code>pred</code> and <code>input</code> and the function return must be the same. <code>T1</code>, <code>T2</code> do not need to be specified in the function identical to the above, but are shown to indicate viable types for each class. Anything not satisfying the table above is considered a <code>:generic</code> type, which depending on the construction might not find full support in this module.</p><blockquote><p><code>:generic</code> Mode: If creating <code>:generic</code> constraints, to avoid issues we recommend:</p><ul><li>The predictive model output a scalar (float), or a type satisfying <code>&lt;: VecOrMat{FT}</code> in a flattened row-like manner, (e.g., a length-1 <code>Vector</code>, or a single-row 1×N <code>Matrix</code>, instead of column (N×1, or like a length-N <code>Vector</code>) or many-dimension types.</li><li>The constraint function be able to handle the input and output types of your predictive model, and output a similar type to that of the predictive model</li><li>The <code>eltype</code> of the predictive model input, output, and constraint model output be the same.</li></ul></blockquote><h3 id="Constraint-Functionality"><a class="docs-heading-anchor" href="#Constraint-Functionality">Constraint Functionality -</a><a id="Constraint-Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Functionality" title="Permalink"></a></h3><p>The internals of constraint functions do not truly matter as long as the output configuration is compliant and <code>eltype</code>s are consistent, enabling a wide variety of possible functions. Functions that require additional parameters, or are a function of external data, etc., are also possible though the creation of functor methods (create a type <code>MyType</code> with the necessary fields, and create a functor method <code>function (x::MyType)(pred, input)</code> that calls on and makes use of the necessary internal fields; an example is provided below).</p><div class="admonition is-success" id="Design-Tips-b994cf8bc2dd27fb"><header class="admonition-header">Design Tips<a class="admonition-anchor" href="#Design-Tips-b994cf8bc2dd27fb" title="Permalink"></a></header><div class="admonition-body"><p>For optimal performance on GPUs when creating <code>static</code> methods, we recommend minimizing or eliminating any allocations in your functional form. If supplying both an upper and a lower bound as your constraints, for any given input <code>x</code> the value of the upper bound function at <code>x</code>must be greater or equal to the value of the lower bound function at <code>x</code>, though this does not necessarily mean that the upper bound at any input <code>x</code> must be higher than the lower bound at any other input <code>y!=x</code>.</p></div></div><blockquote><p><em>MORE THAN 1D?</em>: This tutorial details a case study for the creation of a 1D model with small <code>Vector</code> inputs, however, <code>ConstrainedNeuralModels</code> can be used for multidimensional inputs and outputs as well (CNN&#39;s on images/tensors, etc.) - just make sure to have a flattening layer/operation at the end of your prediction model to send all outputs to a 1×N <code>Matrix</code> (and a corresponding flattening/ordering inside of your constraint functions), with compliant constraint functions, and a restructuring operation after the output of the <code>ConstrainedNeuralModel</code>.</p></blockquote><h3 id="Function-type-Constraint-Example"><a class="docs-heading-anchor" href="#Function-type-Constraint-Example">Function-type Constraint Example -</a><a id="Function-type-Constraint-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Function-type-Constraint-Example" title="Permalink"></a></h3><p>For our snow depth model, we pick an upper boundary function that leaves the prediction unchanged if snowfall is present, but clamps the prediction to be nonpositive if no snowfall is present. We also pick a lower boundary boundary defining <span>$\frac{dz}{dt} \leq -z/Δt$</span> to prevent the snowpack from ever becoming a negative value.</p><p>It is not required, but one can declare bound methods with the <code>@bound</code> macro from <code>ConstrainedNeuralModels</code>, which runs some automated function compliance checks to ensure its usability within <code>ClimaLand</code>, and stores any function information useful for generating metadata when saving a <code>ConstrainedNeuralModel</code>. In this case, the below initial attempt will be deemed <code>:generic</code> bounds that are supported by the module - they work for our <code>Flux.Chain</code> predictive network both when receiving either single (<code>Vector</code> input, outputting <code>Vector</code>) or batched (<code>Matrix</code> input, outputting <code>Matrix</code>) inputs, (This is a good first start for prototyping, but we could do more to optimize performance):</p><pre><code class="language-julia hljs">@bound function upper_bound(
    pred::AbstractArray{T},
    input::AbstractArray{T},
)::AbstractArray{T} where {T &lt;: AbstractFloat}
    return @. (input[p_idx:p_idx, :] &gt; 0) * relu(pred) #outputs as a row Matrix, could do input[p_idx, :]&#39; instead
end

const dt::Float32 = FT(Dates.value(Δt))
@bound function lower_bound(
    pred::AbstractArray{T},
    input::AbstractArray{T},
)::AbstractArray{T} where {T &lt;: AbstractFloat}
    return -input[z_idx, :]&#39; ./ dt  #outputs as a row matrix
end</code></pre><div class="admonition is-info" id="Note-c2a0a668d960761b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c2a0a668d960761b" title="Permalink"></a></header><div class="admonition-body"><p>The functions here are specified with argtypes AND return types of <code>AbstractArray{T}</code> instead of each being specified as <code>AbstractArray{&lt;:AbstractFloat}</code>, so that the compiler knows all arg and return types will have the SAME float-type. Failing to specify this way can result in an immense slow-downs during gradient-based training.</p></div></div><h3 id="Functor-type-Constraint-Example"><a class="docs-heading-anchor" href="#Functor-type-Constraint-Example">Functor-type Constraint Example -</a><a id="Functor-type-Constraint-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Functor-type-Constraint-Example" title="Permalink"></a></h3><p>For this tutorial, the feature indices are known beforehand and hard-coded as <code>const</code>ants so that our <code>:generic</code> function definition is compiled equivalently to writing <code>input[1, :]&#39;</code> or <code>input[7:7, :]</code>. In general, constraint functions do not have to index into <code>pred</code> or <code>input</code> (or even use them at all), and functions including any variables defined in global scope are fine. However, it is often better practice to define these as functor methods over a custom type, storing all necessary information in a more performance-optimized manner. For example, we could have declared the below for the lower bound instead. Like the <code>@bound</code> macro, we could optionally declare our custom constraint type with the <code>ConstrainedNeuralModels</code> <code>@bound_type</code> macro, to store useful metadata:</p><pre><code class="language-julia hljs"># Declare the type:
@bound_type struct SDLowerBound{FT &lt;: AbstractFloat}
    z_idx::Int
    negative_one_over_Δt::Ref{FT} #reduces cost, reducing all operations to one multiplication
end

# A constructor
function make_lower_bound(FT::Type{&lt;:AbstractFloat}, z_idx::Int, Δt::Period)
    return SDLowerBound{FT}(z_idx, Ref(FT(-1 / Dates.value(Dates.Second(Δt)))))
end

# Could dispatch on type: here is a :batched dynamic version
@bound function (b::SDLowerBound)(
    pred::Matrix{T},
    input::Matrix{T},
)::Matrix{T} where {T &lt;: AbstractFloat}
    return b.negative_one_over_Δt * view(input, (b.z_idx):(b.z_idx), :)
end

# and a :single dynamic version
@bound function (b::SDLowerBound)(
    pred::Vector{T},
    input::Vector{T},
)::T where {T &lt;: AbstractFloat}
    return b.negative_one_over_Δt * input[b.z_idx]
end

# could also make additional methods to interact with the bound and set the time-step value:
function set_time_step!(b::SDLowerBound{T}, dt::Real) where {T &lt;: AbstractFloat}
    b.negative_one_over_Δt[] = T(-1 / dt)
end

# Create an instance of the custom bound functor type:
lowerb = make_lower_bound(Float32, z_idx, Δt);</code></pre><p>With functor constraints, the possibilities of constraints for <code>ConstrainedNeuralModels</code> is greatly expanded, with virtually no limits to the types of data, mutable or fixed types, parameters, and additional methods (e.g., like <code>set_time_step!()</code>, so it could be altered before/during/after training) for abstract constraint functionality and form. In this case, we suggest such additional methods are well-documented, so that if using <code>@bound</code> and <code>@bound_type</code> their internals can be made explicit and reproducible upon saving/transfering the <code>ConstrainedNeuralModel</code> to another system (see below).</p><h2 id="Creating-and-Training-a-ConstrainedNeuralModel:"><a class="docs-heading-anchor" href="#Creating-and-Training-a-ConstrainedNeuralModel:">Creating and Training a <code>ConstrainedNeuralModel</code>:</a><a id="Creating-and-Training-a-ConstrainedNeuralModel:-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-and-Training-a-ConstrainedNeuralModel:" title="Permalink"></a></h2><p>We then create the <code>ConstrainedNeuralModel</code>, by specifying a float-type for the model (<code>Float32</code> will run faster than <code>Float64</code>), and create the model by specifying the predictive component, any upper or lower boundary constraints, and the input and/or output scaling:</p><pre><code class="language-julia hljs">model = ConstrainedNeuralModel(
    FT,
    pred_model,
    upper_bound = upper_bound,
    lower_bound = lower_bound, #or `lowerb`
    in_scales = in_scales,
    out_scale = out_scale,
)</code></pre><pre><code class="nohighlight hljs">ConstrainedNeuralModel(
  Chain(
    l1 = Dense(7 =&gt; 28, relu),          # 224 parameters
    l2 = Dense(28 =&gt; 7, elu),           # 203 parameters
    l3 = Dense(7 =&gt; 1),                 # 8 parameters
  ),
)         # Total: 6 trainable arrays, 435 parameters,
          # plus 6 non-trainable, 56 parameters, summarysize 2.559 KiB.</code></pre><p>In general, the minimal construction of a <code>ConstrainedNeuralModel</code> requires only a float type and predictive model, and at least one of either a lower or upper bound constraint (a function or an instance of a functor type). Input and output scaling are optional, as well as the option for custom fixed layers, or an additional <code>trainable_constraints</code> argument (default: <code>false</code>; can be changed to <code>true</code>) that allows the parameters of a supplied functor bound to be trained simultaneously alongside the network.</p><div class="admonition is-info" id="Trainable-Constraints-34001991ed3139e"><header class="admonition-header">Trainable Constraints<a class="admonition-anchor" href="#Trainable-Constraints-34001991ed3139e" title="Permalink"></a></header><div class="admonition-body"><p>For trainable constraints, make sure the <code>Flux.trainable()</code> function is defined for your bound functor type.</p></div></div><p>For this <code>model</code>, the returned <code>ConstrainedNeuralModel</code> will use a default set of fixed layers to apply the constraint functions to the predictive model in a scalable manner. As is discussed in the <a href="../../../../references/#Charbonneau2025">Charbonneau <em>et al.</em> [20]</a> paper, for certain types of boundary functions, these fixed layers can be simplified to further reduce computational cost. Custom fixed layers can be specified via the <code>fixed_layers</code> argument, taking a <code>Flux.Chain</code> of <code>Dense</code> layers with <code>relu</code> activation (for an example, load <a href="https://github.com/CliMA/ClimaLand.jl/blob/main/ext/constrained_nn/NeuralSnow.jl">the actual <code>NeuralDepthModel</code></a> used in the <code>NeuralSnow</code> extension for <code>ClimaLand.Snow</code>).</p><p>As training updates are better with the scaled data, we can put a ConstrainedNeuralModel into <code>:scaled_train</code> mode, which maintains the output scaling with regards to how predicted values as they are passed to the constraint functions, but rescales the final output as if there was no output scaling (this corresponds to our scaling of <code>y_train</code> to be within -1 to 1 as well):</p><pre><code class="language-julia hljs">scale_model!(model, :scaled_train);</code></pre><p>We define the loss function as defined in <a href="../../../../references/#Charbonneau2025">Charbonneau <em>et al.</em> [20]</a>, taking an input of a model, <code>x</code>, and <code>y</code>, e.g. <code>loss(m, x, y) = sum(abs.(m(x) .- y))</code>:</p><pre><code class="language-julia hljs">loss(_model, x, y) = custom_loss(x, y, _model, n1, n2); #in &quot;docs/src/tutorials/standalone/Snow/tutorial_tools.jl&quot;</code></pre><p>With that, training is as simple as calling the <code>trainmodel!</code> function:</p><pre><code class="language-julia hljs">print(&quot;\nTraining model!\n&quot;)
trainmodel!(model, x_train, y_train, loss, nbatch = 256, verbose = true);</code></pre><pre><code class="nohighlight hljs">
Training model!
Epoch: 10 | training loss: 0.0027834391
Epoch: 20 | training loss: 0.0027780344
Epoch: 30 | training loss: 0.0028270262
Epoch: 40 | training loss: 0.0027434342
Epoch: 50 | training loss: 0.0028260131
Epoch: 60 | training loss: 0.0026030457
Epoch: 70 | training loss: 0.0027000855
Epoch: 80 | training loss: 0.0025868127
Epoch: 90 | training loss: 0.0025806718
Epoch: 100 | training loss: 0.0025885638
</code></pre><p>To show the model&#39;s output on some of our training data in physically meaningful units, we first reset the model back from its :scaled_train mode.</p><pre><code class="language-julia hljs">scale_model!(model, :reset);</code></pre><h1 id="Results:"><a class="docs-heading-anchor" href="#Results:">Results:</a><a id="Results:-1"></a><a class="docs-heading-anchor-permalink" href="#Results:" title="Permalink"></a></h1><p>We make use of the <code>make_timeseries()</code> function defined for this tutorial, which allows us to pass the model a dataframe for a given SNOTEL site, and compare the result to actual data.</p><p>For instance, let&#39;s show the results on SNOTEL site 1286 (Slagamount Lakes site, Montana):</p><p><em><em>Note that gaps in the data are shown as shaded regions on the plotted timeseries</em></em>.</p><pre><code class="language-julia hljs">site_id = 1286
sitedata = usedata[usedata[!, :id] .== site_id, :]
true_series = sitedata[!, :z]
pred_series, _, _ =
    make_timeseries(model, sitedata, Δt, hole_thresh = hole_thresh)
ptitle = &quot;Slagamount Lakes, Snow Depth (m)&quot;
siteplot(
    ptitle,
    sitedata[!, :date],
    [true_series, pred_series],
    [&quot;Data&quot;, &quot;Neural Model&quot;],
    [:black, :red],
    savename = &quot;base_tutorial_plot1.png&quot;,
    display_plot = false,
);</code></pre><pre><code class="nohighlight hljs">GKS: cannot open display - headless operation mode active
</code></pre><p><img src="../base_tutorial_plot1.png" alt/></p><p>Or, alternatively, SNOTEL site 1070 (Anchorage Hillside, Alaska) from the testing data:</p><pre><code class="language-julia hljs">site_id = 1070
sitedata = valdata[valdata[!, :id] .== site_id, :]
true_series = sitedata[!, :z]
pred_series, _, _ =
    make_timeseries(model, sitedata, Δt, hole_thresh = hole_thresh)
ptitle = &quot;Anchorage Hillside, Snow Depth (m)&quot;
siteplot(
    ptitle,
    sitedata[!, :date],
    [true_series, pred_series],
    [&quot;Data&quot;, &quot;Neural Model&quot;],
    [:black, :red],
    savename = &quot;base_tutorial_plot2.png&quot;,
    display_plot = false,
);</code></pre><p><img src="../base_tutorial_plot2.png" alt/></p><p>Creating timeseries for other datasets/systems with other models can be handled with a similar call to this tutorial&#39;s <code>make_timeseries()</code> function. In this system, the timestep <code>Δt</code> could also be changed to different values to evaluate the network&#39;s capability on validation data with different temporal resolutions, without the need for retraining of the predictive network (or, for a <code>SDLowerBound</code> constraint, changing the timescale on-the-fly).</p><h1 id="Saving-and-Loading-Models:"><a class="docs-heading-anchor" href="#Saving-and-Loading-Models:">Saving and Loading Models:</a><a id="Saving-and-Loading-Models:-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-Loading-Models:" title="Permalink"></a></h1><p>The <code>save_model()</code> function can be used to save a <code>ConstrainedNeuralModel</code> to two JLD2 files, one for its structure and one for its weights. Models can be loaded using the <code>load_model()</code> functionality, which combines a model structure file with a provided vector of model parameters. The structure-parameter split is deliberate to allow online tuning of models within a larger model ensemble. The parameter and structure files for the neural networks used in <code>ClimaLand.Snow</code> are stored <code>ClimaLand</code> artifacts, or are human-readable at the hyperlinks for the <a href="https://caltech.box.com/v/paper-model-z"><span>$z$</span> network</a> and <a href="https://caltech.box.com/v/paper-model-swe"><span>$SWE$</span> network</a> utilized in <a href="../../../../references/#Charbonneau2025">Charbonneau <em>et al.</em> [20]</a>. Note that the SWE network uses <code>n=5</code> instead of the snow depth <code>n=4</code>.</p><h3 id="Model-Metadata:"><a class="docs-heading-anchor" href="#Model-Metadata:">Model Metadata:</a><a id="Model-Metadata:-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Metadata:" title="Permalink"></a></h3><p>For storing model information in a save-file for a <code>ConstrainedNeuralModel</code>, custom metadata can be passed as a <code>String</code> to the <code>save_model()</code> function via the optional <code>user_param_metadata</code> and <code>user_model_metadata</code> arguments. To aid in this, the <code>build_model_bound_documentation()</code> and <code>build_model_API()</code> functions also exist, if you have chosen to specify your bound methods/types with the <code>@bound</code> and/or <code>@bound_type</code> macros.</p><p><code>build_model_bound_documentation()</code> generates a metadata string containing the actual code syntax for constraints defined with the macros, and other model metadata, to aid in reproducibility and transferability across systems and codespaces.</p><p><code>build_model_API()</code> will also construct an API (but not the actual code syntax; this property is exclusive only for code specified with the <code>@bound</code> and <code>@bound_type</code> macros) of any methods related to utilized custom bound functor types, or types/methods/modules utilized by the <code>ConstrainedNeuralModel</code> that are not already available in <code>ClimaLand</code>. This is to aid in reproducibility on other systems, even if the original script to generate the model is lost, as associated documentation is also captured.</p><div class="admonition is-success" id="Tip-7e8f8daf74530935"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-7e8f8daf74530935" title="Permalink"></a></header><div class="admonition-body"><p>Since <code>build_model_API()</code> captures documentation strings, pasting the code syntax into the documentation of custom methods/types mostly mitigates reproducibility concerns.</p></div></div><p>For loading models, all necessary methods/types for the desired <code>ConstrainedNeuralModel</code> must already be loaded into the codespace when <code>load_model()</code> is called. To aid in this, one can use <code>inspect_model_metadata()</code> on the loaded model data object to print any model metadata.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Canopy/changing_canopy_parameterizations/">« Changing canopy parameterizations</a><a class="docs-footer-nextpage" href="../data_tutorial/">Data tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Saturday 28 February 2026 03:37">Saturday 28 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
