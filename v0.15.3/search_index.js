var documenterSearchIndex = {"docs":
[{"location":"APIs/canopy/RadiativeTransfer/#Radiative-Transfer","page":"Canopy RT","title":"Radiative Transfer","text":"","category":"section"},{"location":"APIs/canopy/RadiativeTransfer/","page":"Canopy RT","title":"Canopy RT","text":"CurrentModule = ClimaLand.Canopy","category":"page"},{"location":"APIs/canopy/RadiativeTransfer/#Parameters","page":"Canopy RT","title":"Parameters","text":"","category":"section"},{"location":"APIs/canopy/RadiativeTransfer/","page":"Canopy RT","title":"Canopy RT","text":"ClimaLand.Canopy.BeerLambertParameters","category":"page"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.BeerLambertParameters","page":"Canopy RT","title":"ClimaLand.Canopy.BeerLambertParameters","text":"BeerLambertParameters{FT <: AbstractFloat}\n\nThe required parameters for the Beer-Lambert radiative transfer model.\n\nα_PAR_leaf: PAR leaf reflectance (unitless)\nα_NIR_leaf: NIR leaf reflectance\nϵ_canopy: Emissivity of the canopy\nΩ: Clumping index following Braghiere (2021) (unitless)\nλ_γ_PAR: Typical wavelength per PAR photon (m)\nλ_γ_NIR: Typical wavelength per NIR photon (m)\nG_Function: Leaf angle distribution function\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/RadiativeTransfer/#Methods","page":"Canopy RT","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/RadiativeTransfer/","page":"Canopy RT","title":"Canopy RT","text":"ClimaLand.Canopy.compute_absorbances\nClimaLand.Canopy.plant_absorbed_pfd_beer_lambert\nClimaLand.Canopy.plant_absorbed_pfd_two_stream\nClimaLand.Canopy.extinction_coeff\nClimaLand.Canopy.extinction_coeff\nClimaLand.Canopy.canopy_radiant_energy_fluxes!","category":"page"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.plant_absorbed_pfd_beer_lambert","page":"Canopy RT","title":"ClimaLand.Canopy.plant_absorbed_pfd_beer_lambert","text":"plant_absorbed_pfd_beer_lambert(\n    Ω::FT,\n    SW_d:FT,\n    α_leaf::FT,\n    LAI::FT,\n    K::FT,\n    α_soil::FT\n)\n\nComputes the absorbed, reflected, and transmitted photon flux density in terms of mol photons per m^2 per second for a radiation band.\n\nThis applies the Beer-Lambert law, which is a function of downwelling radiation (SW_d; moles of photons/m^2/), leaf reflectance (α_leaf), the extinction coefficient (K), leaf area index (LAI), and the albedo of the soil (α_soil).\n\nReturns a tuple of reflected, absorbed, and transmitted radiation in mol photons/m^2/s.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.plant_absorbed_pfd_two_stream","page":"Canopy RT","title":"ClimaLand.Canopy.plant_absorbed_pfd_two_stream","text":"plant_absorbed_pfd_two_stream(\n    G::FT,\n    Ω::FT,\n    n_layers::UInt64,\n    SW_d::FT,\n    α_leaf::FT,\n    τ_leaf::FT,\n    LAI::FT,\n    K::FT,\n    θs::FT,\n    α_soil::FT,\n    frac_diff::FT,\n)\n\nComputes the absorbed, transmitted, and reflected  photon flux density in terms of mol photons  per m^2 per second for a radiation band.\n\nThis applies the two-stream radiative transfer solution which takes into account the impacts of scattering within the canopy. The function takes in all parameters from the parameter struct of a TwoStreamModel, along with the incident radiation, LAI, extinction coefficient K, soil albedo from the canopy soil_driver, solar zenith angle, and τ.\n\nReturns a tuple of reflected, absorbed, and transmitted radiation in mol photons/m^2/s.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.extinction_coeff","page":"Canopy RT","title":"ClimaLand.Canopy.extinction_coeff","text":"extinction_coeff(ld::FT,\n                 θs::FT) where {FT}\n\nComputes the vegetation extinction coefficient (K), as a function of the sun zenith angle (θs), and the leaf angle distribution (G).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/RadiativeTransfer/#ClimaLand.Canopy.canopy_radiant_energy_fluxes!","page":"Canopy RT","title":"ClimaLand.Canopy.canopy_radiant_energy_fluxes!","text":"Canopy.canopy_radiant_energy_fluxes!(p::NamedTuple,\n                                     s::PrognosticSoilConditions,\n                                     canopy,\n                                     radiation::PrescribedRadiativeFluxes,\n                                     earth_param_set::PSE,\n                                     Y::ClimaCore.Fields.FieldVector,\n                                     t,\n                                    ) where {PSE}\n\nIn standalone mode, this function computes and stores the net long and short wave radition, in W/m^2, absorbed by the canopy.\n\nIn integrated mode, we have already computed those quantities in lsm_radiant_energy_fluxes!, so this method does nothing additional.\n\nLW and SW net radiation are stored in p.canopy.radiative_transfer.LW_n and p.canopy.radiative_transfer.SW_n.\n\n\n\n\n\ncanopy_radiant_energy_fluxes!(p::NamedTuple,\n                              ground::PrescribedGroundConditions\n                              canopy,\n                              radiation::PrescribedRadiativeFluxes,\n                              earth_param_set::PSE,\n                              Y::ClimaCore.Fields.FieldVector,\n                              t,\n                             ) where {PSE}\n\nComputes and stores the net long and short wave radition, in W/m^2, absorbed by the canopy when the canopy is run in standalone mode, with only a :canopy model as a prognostic component, with PrescribedGroundConditions.\n\nLW and SW net radiation are stored in p.canopy.radiative_transfer.LW_n and p.canopy.radiative_transfer.SW_n.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/available_diagnostics/#Available-diagnostic-variables","page":"Available diagnostics","title":"Available diagnostic variables","text":"","category":"section"},{"location":"diagnostics/available_diagnostics/","page":"Available diagnostics","title":"Available diagnostics","text":"Autogenerate table of available diagnostics:","category":"page"},{"location":"diagnostics/available_diagnostics/","page":"Available diagnostics","title":"Available diagnostics","text":"include(\"make_diagnostic_table.jl\")","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"This sets up the simulation that mimicks the coarse sand lab experiment presented in Figures 7 and 8a of Lehmann, Assouline, Or  (Phys Rev E 77, 2008).","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"using CairoMakie\nimport SciMLBase\nimport ClimaTimeSteppers as CTS\nusing Thermodynamics\n\nusing ClimaCore\nimport ClimaParams as CP\nusing SurfaceFluxes\nusing StaticArrays\nusing Dates\nusing DelimitedFiles: readdlm\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\nimport ClimaLand\nimport ClimaLand.Parameters as LP\nimport SurfaceFluxes.Parameters as SFP\n\nFT = Float64;\nearth_param_set = LP.LandParameters(FT)\nthermo_params = LP.thermodynamic_parameters(earth_param_set);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"We model evaporation using Monin-Obukhov surface theory. In our soil model, it is not possible to set the initial condition corresponding to  MOST fluxes, but not include radiative fluxes. This is because for land surface models does not make sense to include atmospheric forcing but not radiative forcing.","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Because of this, we need to supply downward welling short and long wave radiation. We chose SW = 0 and LW = σT^4, in order to approximately balance out the blackbody emission of the soil which is accounted for by our model. Our assumption is that in the lab experiment there was no radiative heating or cooling of the soil.","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"start_date = DateTime(2005) # required argument, but not used in this case\nSW_d = (t) -> 0\nLW_d = (t) -> 301.15^4 * 5.67e-8\nradiation = PrescribedRadiativeFluxes(\n    FT,\n    TimeVaryingInput(SW_d),\n    TimeVaryingInput(LW_d),\n    start_date,\n);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Set up atmospheric conditions that result in the potential evaporation rate obsereved in the experiment. Some of these conditions are reported in the paper.","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"T_air = FT(301.15)\nrh = FT(0.38)\nesat = Thermodynamics.saturation_vapor_pressure(\n    thermo_params,\n    T_air,\n    Thermodynamics.Liquid(),\n)\ne = rh * esat\nq = FT(0.622 * e / (101325 - 0.378 * e))\nprecip = (t) -> 0.0\nT_atmos = (t) -> T_air\nu_atmos = (t) -> 1.0\nq_atmos = (t) -> q\nh_atmos = FT(0.1)\nP_atmos = (t) -> 101325\ngustiness = FT(1e-2)\natmos = PrescribedAtmosphere(\n    TimeVaryingInput(precip),\n    TimeVaryingInput(precip),\n    TimeVaryingInput(T_atmos),\n    TimeVaryingInput(u_atmos),\n    TimeVaryingInput(q_atmos),\n    TimeVaryingInput(P_atmos),\n    start_date,\n    h_atmos,\n    earth_param_set;\n    gustiness = gustiness,\n);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Define the boundary conditions","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"top_bc = ClimaLand.Soil.AtmosDrivenFluxBC(atmos, radiation)\nzero_water_flux = WaterFluxBC((p, t) -> 0)\nzero_heat_flux = HeatFluxBC((p, t) -> 0)\nboundary_fluxes = (;\n    top = top_bc,\n    bottom = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"[ Info: Warning: No runoff model was provided; zero runoff generated.\n","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Define the parameters n and alpha estimated by matching vG curve.","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"K_sat = FT(225.1 / 3600 / 24 / 1000)\nvg_n = FT(10.0)\nvg_α = FT(6.0)\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n)\nν = FT(0.43)\nθ_r = FT(0.045)\nS_s = FT(1e-3)\nν_ss_om = FT(0.0)\nν_ss_quartz = FT(1.0)\nν_ss_gravel = FT(0.0)\nemissivity = FT(1.0)\nPAR_albedo = FT(0.2)\nNIR_albedo = FT(0.4)\nz_0m = FT(1e-3)\nz_0b = FT(1e-4)\nd_ds = FT(0.01)\nparams = ClimaLand.Soil.EnergyHydrologyParameters(\n    FT;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm = hcm,\n    K_sat,\n    S_s,\n    θ_r,\n    PAR_albedo,\n    NIR_albedo,\n    emissivity,\n    z_0m,\n    z_0b,\n    earth_param_set,\n    d_ds,\n);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Domain - single column","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"zmax = FT(0)\nzmin = FT(-0.35)\nnelems = 5\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems)\nz = ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z;","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Soil model, and create the prognostic vector Y and cache p:","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"soil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = (),\n)\n\nY, p, cds = initialize(soil);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Set initial conditions","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"function hydrostatic_equilibrium(z, z_interface, params)\n    (; ν, S_s, hydrology_cm) = params\n    (; α, n, m) = hydrology_cm\n    if z < z_interface\n        return -S_s * (z - z_interface) + ν\n    else\n        return ν * (1 + (α * (z - z_interface))^n)^(-m)\n    end\nend\nfunction init_soil!(Y, z, params)\n    FT = eltype(Y.soil.ϑ_l)\n    Y.soil.ϑ_l .= hydrostatic_equilibrium.(z, FT(-0.001), params)\n    Y.soil.θ_i .= 0\n    T = FT(296.15)\n    ρc_s = @. Soil.volumetric_heat_capacity(\n        Y.soil.ϑ_l,\n        FT(0),\n        params.ρc_ds,\n        params.earth_param_set,\n    )\n    Y.soil.ρe_int =\n        Soil.volumetric_internal_energy.(FT(0), ρc_s, T, params.earth_param_set)\nend\ninit_soil!(Y, z, soil.parameters);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Timestepping:","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"t0 = Float64(0)\ntf = Float64(24 * 3600 * 13)\ndt = Float64(900.0)","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"900.0","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"We also set the initial conditions of the cache here:","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"set_initial_cache! = make_set_initial_cache(soil)\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Define the tendency functions","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"exp_tendency! = make_exp_tendency(soil)\nimp_tendency! = make_imp_tendency(soil);\njacobian! = ClimaLand.make_jacobian(soil);\njac_kwargs = (; jac_prototype = ImplicitEquationJacobian(Y), Wfact = jacobian!);\n\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Define the problem and callbacks:","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"prob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n);\nsaveat = Array(t0:3600.0:tf)\nsv = (;\n    t = Array{Float64}(undef, length(saveat)),\n    saveval = Array{NamedTuple}(undef, length(saveat)),\n)\nsaving_cb = ClimaLand.NonInterpSavingCallback(sv, saveat)\nupdateat = deepcopy(saveat)\nmodel_drivers = ClimaLand.get_drivers(soil)\nupdatefunc = ClimaLand.make_update_drivers(model_drivers)\ndriver_cb = ClimaLand.DriverUpdateCallback(updateat, updatefunc)\ncb = SciMLBase.CallbackSet(driver_cb, saving_cb);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Solve","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"sol = SciMLBase.solve(prob, ode_algo; dt = dt, callback = cb, saveat = saveat);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Figures","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"Extract the evaporation at each saved step","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"evap = [\n    parent(sv.saveval[k].soil.turbulent_fluxes.vapor_flux_liq)[1] for\n    k in 1:length(sol.t)\n]\nsavepath = joinpath(pkgdir(ClimaLand), \"docs/tutorials/standalone/Soil/\")\nevaporation_data =\n    ClimaLand.Artifacts.lehmann_assouline_or2008_evaporation_data();\nref_soln_E = readdlm(evaporation_data, ',')\nref_soln_E_350mm = ref_soln_E[2:end, 1:2]\ndata_dates = ref_soln_E_350mm[:, 1]\ndata_e = ref_soln_E_350mm[:, 2];\n\nfig = Figure(size = (800, 400))\nax = Axis(\n    fig[1, 1],\n    xlabel = \"Day\",\n    ylabel = \"Evaporation rate (mm/d)\",\n    title = \"Bare soil evaporation\",\n)\nCairoMakie.xlims!(minimum(data_dates), maximum(data_dates))\nCairoMakie.lines!(\n    ax,\n    FT.(data_dates),\n    FT.(data_e),\n    label = \"Data\",\n    color = :blue,\n)\nCairoMakie.lines!(\n    ax,\n    sol.t ./ 3600 ./ 24,\n    evap .* (1000 * 3600 * 24),\n    label = \"Model\",\n    color = :black,\n)\nCairoMakie.axislegend(ax)\n\nax = Axis(\n    fig[1, 2],\n    xlabel = \"Mass (g)\",\n    yticksvisible = false,\n    yticklabelsvisible = false,\n)\nA_col = π * (0.027)^2\nmass_0 = sum(sol.u[1].soil.ϑ_l) * 1e6 * A_col\nmass_loss =\n    [mass_0 - sum(sol.u[k].soil.ϑ_l) * 1e6 * A_col for k in 1:length(sol.t)]\nCairoMakie.lines!(\n    ax,\n    cumsum(FT.(data_e)) ./ (1000 * 24) .* A_col .* 1e6,\n    FT.(data_e),\n    label = \"Data\",\n    color = :blue,\n)\nCairoMakie.lines!(\n    ax,\n    mass_loss,\n    evap .* (1000 * 3600 * 24),\n    label = \"Model\",\n    color = :black,\n)\nsave(\"evaporation_lehmann2008_fig8b.png\", fig);","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"","category":"page"},{"location":"generated/standalone/Soil/evaporation/","page":"Coarse Sand Evaporation","title":"Coarse Sand Evaporation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The AbstractModel framework allows users to define land component models (e.g. for snow, soil, vegetation, carbon...) which can be run in standalone mode, or as part of a land surface model with many components. In order to achieve this flexibility, we require a standard interface, which is what AbstractModels provide. The interface is designed to work with an external package for the time-stepping of ODEs, ClimaTimesteppers.jl, with ClimaCore.jl, for the spatial discretization of PDEs, and with ClimaLand.jl, for designing and running multi-component land surface models. For a developer of a new land model component, using AbstractModels as shown below is the first step towards building a model which can be run in standalone or with other components in an integrated land surface model.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"This tutorial introduces some of the functionality of the AbstractModel interface functions and types. We demonstrate how to use a Model <: AbstractModel structure to define a set of equations, and explain a few core methods which must be defined for your Model type in order to run a simulation.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/#General-setup","page":"Intro to standalone models","title":"General setup","text":"","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"We assume you are solving a system of the form of a set of PDEs or ODEs. Additional algebraic equations can be accomodated as well, but only in addition to variables advanced using differential equations.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Spatially discretized PDEs reduce to a system of ODEs, so we can assume an ODE system in what follows without a loss of generality. When using AbstractModels, you should use ClimaCore to discretize your PDE, as applicable.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Your model defines a system of equations of the following form:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"fracd vecYd t = vecf(vecY vecx t mboxparams ldots)","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The variables that are stepped forward via a differential equation are referred to as prognostic variables, and are stored in vecY. Generically, we will speak of the functions vecf as tendencies; these can be functions of the prognostic state, of space vecx, and of time t, as well as of other parameters. Note that quantities such as boundary conditions, source terms, etc, will appear within these tendency functions","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/#The-cache-(\"auxiliary-variables\")","page":"Intro to standalone models","title":"The cache (\"auxiliary variables\")","text":"","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"There are typically quantities, which depend on the state vector vecY, location, time, and other parameters, which are expensive to compute, needed multiple times in the tendency computation, or require \"a lot\" of  memory to store (e.g., most variables in global runs). Allocating memory \"on-the-fly\" is typically time-consuming.  In these cases, it is far better to compute a quantity once and store in a variable where memory has been pre-allocated. The location where memory is allocated is called the model cache.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Denoting the cache as vecp, your equations may be rewritten as:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"fracd vecYd t = vecf(vecY vecp vecx t mboxparams ldots)","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"vecp(vecx t) = vecg(vecY vecx t mboxparams ldots)","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The variables vecp at the current timestep are functions of the prognostic state, space, time, and parameters. These variables are referred to as auxiliary variables (or cache variables). Their main purpose is for storing the value of a quantity in a pre-allocated spot in memory, to avoid computing something expensive many times per time-step, or to avoid allocating memory each timestep. From a mathematical point of view, they represent intermediate quantities computed in each tendency. A model purely consisting of algebraic equations, with no prognostic variables, is not supported (vecY cannot be zero dimensional).","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"In order to define this set of equations, in a manner which is consistent with the AbstractModel interface (used by ClimaLand.jl) and time-stepping algorithms (OrdinaryDiffEq.jl for the present), the following must be provided.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/#The-Model","page":"Intro to standalone models","title":"The Model","text":"","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"All ClimaLand component models are concrete instances of AbstractModels. The reason for grouping them in such a way is because they all have shared required functionality, as we will see, and can make use of common default behavior.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The model structure holds all of the information needed to create the full right hand side function, including parameters (which can be functions of space and time), boundary conditions, and physical equations.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The purpose of our AbstractModel interface is that it allows you to run land component models in standalone mode and in an LSM mode without a change in interface.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"As a simple demonstration of use, we'll build a model now which solves Richards Equation assuming a prescribed flux at the surface, and zero flux at the bottom of the column.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Note that some model equations are stiff and require a very small timestep if stepped explicitly in time. Some model equations are amenable to \"imex\" timestepping, where some tendency functions are stepped implicitly, and some are stepped explicitly. Tagging a tendency function as \"explicit\" or \"implicit\" hardcodes something about the timestepping, and as such, conflates the idea of the model (which defines the equations) and the independent idea of a simulation (which solves the equations). However, we decided we did not need to support the flexibility of solving any set of equations in any way, as we are focused on land surface modeling in particular. In this example, we will tag the tendency as an explicitly time-stepped tendency. A follow-on tutorial will explain how to define an implicit tendency and tendency Jacobian.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Let's first import some needed packages.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"import ClimaTimeSteppers as CTS\nusing SciMLBase\nusing Plots\nusing ClimaCore\nusing ClimaLand","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Import the functions we are extending for our model:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"import ClimaLand:\n    name,\n    make_exp_tendency,\n    make_compute_exp_tendency,\n    make_update_aux,\n    make_update_boundary_fluxes,\n    prognostic_vars,\n    prognostic_types,\n    prognostic_domain_names,\n    auxiliary_vars,\n    auxiliary_types,\n    auxiliary_domain_names","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The model should contain everything you need to create the tendency function. In this case, that is some parameters, the surface flux boundary value, the floating point precision, and the domain of the model (single column, global run, etc..).","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"struct RichardsTutorialModel{FT, D} <: AbstractModel{FT}\n    \"van Genuchten model parameters\"\n    vGmodel::ClimaLand.Soil.vanGenuchten{FT}\n    \"Porosity [unitless]\"\n    ν::FT\n    \"Residual water fraction [unitless]\"\n    θ_r::FT\n    \"Saturated hydraulic conductiity [m/s]\"\n    Ksat::FT\n    \"Surface flux, used as boundary condition [m/s]\"\n    F_sfc::FT\n    \"Domain of the model\"\n    domain::D\nend;","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"For reasons that will be clear momentarily, let's also define the name of the model:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"ClimaLand.name(model::RichardsTutorialModel) = :soil;","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/#Explicit-tendency","page":"Intro to standalone models","title":"Explicit tendency","text":"","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Here is where we need to specify the equations of motion. The prognostic variables for Richards equation consist of the volumetric water content at each location in the domain, θ. The differential equations are:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"fracpartial ϑ_lpartial t = - -K(θ) (ψ(θ)+z)","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"where K(θ) is the hydraulic conductivity, and ψ(θ) is the matric potential. We now create the function which makes the compute_exp_tendency! function:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"function ClimaLand.make_compute_exp_tendency(model::RichardsTutorialModel)\n    function compute_exp_tendency!(dY, Y, p, t)\n        gradc2f = ClimaCore.Operators.GradientC2F()\n        interpc2f = ClimaCore.Operators.InterpolateC2F()\n        FT = FTfromY(Y)\n        divf2c = ClimaCore.Operators.DivergenceF2C(\n            top = ClimaCore.Operators.SetValue(\n                ClimaCore.Geometry.WVector.(model.F_sfc),\n            ),\n            bottom = ClimaCore.Operators.SetValue(\n                ClimaCore.Geometry.WVector.(FT(0)),\n            ),\n        )\n\n        @. dY.soil.θ =\n            -(divf2c(-interpc2f(p.soil.K) * gradc2f(p.soil.ψ + p.soil.z)))\n    end\n    return compute_exp_tendency!\nend;","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"A couple of notes: the vector vecdY contains the evaluation of the tendency function for each variable in vecY. It is updated in place (so no extra allocations are needed). Note that Y is not a simple array. It is a ClimaCore FieldVector, which allow us to impose some organizational structure on the state while still behaving like arrays in some ways. We use the symbol returned by name(model) to create the naming hierarchy in Y, dY, p. This is useful for multi-component models.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The arguments of compute_exp_tendency! are generic for any time-stepping algorithm. The compute_exp_tendency! function is only created once. If there are time-varying forcing terms appearing, for example, the forcing functions must be stored in model and passed in that way.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/#The-prognostic-state-vector-\\vec{Y}-and-cache-\\vec{p}","page":"Intro to standalone models","title":"The prognostic state vector vecY and cache vecp","text":"","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"We have given the state vector vecY a particular structure, and don't expect the user to build this themselves. In order to have the structure Y (and p) correctly created, the model developer needs to define the names of the prognostic and auxiliary variables, as well as their types (often a floating point scalar), and where in the domain they are defined. For example, the volumetric water content is a scalar (type FT), with name θ, and it is defined throughout the subsurface of the domain.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"ClimaLand.prognostic_vars(::RichardsTutorialModel) = (:θ,);\nClimaLand.prognostic_types(::RichardsTutorialModel{FT}) where {FT} = (FT,);\nClimaLand.prognostic_domain_names(::RichardsTutorialModel) = (:subsurface,);","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The auxiliary variables for this model are the hydraulic conductivity, matric potential, boundary fluxes, and heights of each level in the domain. All of these are scalars, and some are defined throughout the soil volume, or subsurface, while some are defined only on a surface (at the top or bottom of the domain).","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"ClimaLand.auxiliary_vars(::RichardsTutorialModel) =\n    (:K, :ψ, :top_flux, :bottom_flux, :z)\nClimaLand.auxiliary_types(::RichardsTutorialModel{FT}) where {FT} =\n    (FT, FT, FT, FT, FT);\nClimaLand.auxiliary_domain_names(::RichardsTutorialModel) =\n    (:subsurface, :subsurface, :surface, :surface, :subsurface);","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/#Updating-the-cache","page":"Intro to standalone models","title":"Updating the cache","text":"","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"We next need to define how we update the auxiliary variables. These are split between two functions, update_aux!, and update_boundary_fluxes!. For standalone component models, these could be combined into a single function, and indeed they could also be part of the tendency function itself.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"function ClimaLand.make_update_aux(model::RichardsTutorialModel)\n    function update_aux!(p, Y, t)\n        p.soil.z .=\n            ClimaCore.Fields.coordinate_field(model.domain.space.subsurface).z # technically this does not need to update each step\n        @. p.soil.K = ClimaLand.Soil.hydraulic_conductivity(\n            model.vGmodel,\n            model.Ksat,\n            ClimaLand.Soil.effective_saturation(model.ν, Y.soil.θ, model.θ_r),\n        )\n        @. p.soil.ψ = ClimaLand.Soil.matric_potential(\n            model.vGmodel,\n            ClimaLand.Soil.effective_saturation(model.ν, Y.soil.θ, model.θ_r),\n        )\n    end\n    return update_aux!\nend;\n\nfunction ClimaLand.make_update_boundary_fluxes(model::RichardsTutorialModel)\n    function update_boundary_fluxes!(p, Y, t)\n        FT = ClimaLand.FTfromY(Y)\n        p.soil.top_flux .= model.F_sfc\n        p.soil.bottom_flux .= FT(0)\n    end\n    return update_boundary_fluxes!\nend;","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The default tendency function in ClimaLand for any AbstractModel carries out the following:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"function make_exp_tendency(model::AbstractModel)\n    update_aux! = make_update_aux(model)\n    update_boundary_fluxes! = make_update_boundary_fluxes(model)\n    compute_exp_tendency! = make_compute_exp_tendency(model)\n    function exp_tendency!(dY,Y,p,t)\n        update_aux!(p,Y,t)\n        update_boundary_fluxes!(p,Y,t)\n        compute_exp_tendency!(dY,Y,p,t)\n    end\n    return exp_tendency!\nend;","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Therefore, each time we need the tendency, we first update auxiliary variables, then update boundary fluxes, and then compute the tendency itself.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Why do we do this? It would be straightforward, and arguably a lot simpler, to update the cache p within compute_exp_tendency!itself. The reason why we introduce these other functions is because we want to be able to combine standalone \"component\" models, like this one, with others, to create land surface models. For example, if we would like to run a land surface model with the soil and the canopy, the canopy auxiliary variables (e.g. interception of water and snow, transmitted radiation) affect the boundary fluxes of the soil. In this case, we must update auxiliary variables for all components, before computing boundary conditions and tendency functions. Please see the (LSM tutorial) for further explanation.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"More complex cases might require the evaluation of external data. For this, use the TimeVaryingInput interface. You can wrap functions, 1D/2D data in TimeVaryingInput to obtain an object that know how to evaluate that data on the model time (e.g., by performing linear interpolation). Then, in your model, you can just call evaluate!(destination, itp, time) to evaluate the itp on the given time and write the result to dest (typically a Field). With this common interface, you do not have to worry about the detail of the underlying data.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/#Running-a-simulation","page":"Intro to standalone models","title":"Running a simulation","text":"","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Create a model instance.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"FT = Float32\nvGmodel = ClimaLand.Soil.vanGenuchten{FT}(; α = 2.3f0, n = 2.0f0)\nKsat = FT(4.0e-7)\nν = 0.5f0\nθ_r = 0.0f0\nF_sfc = FT(-3.0e-8)\ndomain = ClimaLand.Domains.Column(; zlim = (-1.0f0, 0.0f0), nelements = 10)\nsoil = RichardsTutorialModel{Float32, typeof(domain)}(\n    vGmodel,\n    ν,\n    θ_r,\n    Ksat,\n    F_sfc,\n    domain,\n);","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Create the initial state structure, using the default method. This step creates the vector Y and cache p, but initializes them with zeros.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Y, p, cds = initialize(soil);","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Note that Y has the structure we planned on in our compute_exp_tendency! function, for x,","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Y.soil","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"1-blocked 10-element ClimaCore.Fields.FieldVector{Float32, @NamedTuple{θ::ClimaCore.Fields.Field{ClimaCore.DataLayouts.VF{Float32, 10, Matrix{Float32}}, ClimaCore.Spaces.FiniteDifferenceSpace{ClimaCore.Grids.FiniteDifferenceGrid{ClimaCore.Topologies.IntervalTopology{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.Meshes.IntervalMesh{ClimaCore.Domains.IntervalDomain{ClimaCore.Geometry.ZPoint{Float32}, Tuple{Symbol, Symbol}}, LinRange{ClimaCore.Geometry.ZPoint{Float32}, Int64}}, @NamedTuple{bottom::Int64, top::Int64}}, ClimaCore.Geometry.CartesianGlobalGeometry, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, 10, Matrix{Float32}}, ClimaCore.DataLayouts.VF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, 11, Matrix{Float32}}}, ClimaCore.Grids.CellCenter}}}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The same is true for p:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"p.soil","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"(K = Float32-valued Field:\n  Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], ψ = Float32-valued Field:\n  Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], top_flux = Float32-valued Field:\n  Float32[0.0], bottom_flux = Float32-valued Field:\n  Float32[0.0], z = Float32-valued Field:\n  Float32[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Here we now update Y in place with initial conditions of our choosing.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Y.soil.θ = 0.25f0;","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Set initial cache variable values, and inspect values:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"set_initial_cache! = make_set_initial_cache(soil);\nset_initial_cache!(p, Y, 0.0);\n@show p.soil.K\n\n@show p.soil.ψ\n\n@show p.soil.top_flux","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Float32-valued Field:\n  Float32[-3.0f-8]","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Next up is to create the exp_tendency! function:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"exp_tendency! = make_exp_tendency(soil);","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/#Running-the-simulation","page":"Intro to standalone models","title":"Running the simulation","text":"","category":"section"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Set the initial and end times, timestep:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"t0 = 0.0;\ntf = 7 * 24 * 3600.0;\ndt = 1800.0;","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Select the timestepping algorithm we want to use from CTS.jl.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"timestepper = CTS.RK4()\node_algo = CTS.ExplicitAlgorithm(timestepper)","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"ClimaTimeSteppers.IMEXAlgorithm{ClimaTimeSteppers.Unconstrained, ClimaTimeSteppers.RK4, ClimaTimeSteppers.IMEXTableau{ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}}, Nothing}(ClimaTimeSteppers.Unconstrained(), ClimaTimeSteppers.RK4(), ClimaTimeSteppers.IMEXTableau{ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}}(ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}([0.0 0.0 0.0 0.0; 0.5 0.0 0.0 0.0; 0.0 0.5 0.0 0.0; 0.0 0.0 1.0 0.0]), ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.16666666666666666, 0.3333333333333333, 0.3333333333333333, 0.16666666666666666]), ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.0, 0.5, 0.5, 1.0]), ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}([0.0 0.0 0.0 0.0; 0.5 0.0 0.0 0.0; 0.0 0.5 0.0 0.0; 0.0 0.0 1.0 0.0]), ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.16666666666666666, 0.3333333333333333, 0.3333333333333333, 0.16666666666666666]), ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.0, 0.5, 0.5, 1.0])), nothing)","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"SciMLBase problem statement using CTS.jl internals:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"prob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(T_exp! = exp_tendency!),\n    Y,\n    (t0, tf),\n    p,\n);","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"Solve command:","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"sol = SciMLBase.solve(prob, ode_algo; dt = dt, saveat = dt);","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"The solution is stored in sol.u[k].soil.θ, where k ranges over the number of timesteps.","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"","category":"page"},{"location":"generated/standalone/Usage/model_tutorial/","page":"Intro to standalone models","title":"Intro to standalone models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/ClimaLand/#ClimaLand","page":"ClimaLand","title":"ClimaLand","text":"","category":"section"},{"location":"APIs/ClimaLand/","page":"ClimaLand","title":"ClimaLand","text":"CurrentModule = ClimaLand","category":"page"},{"location":"APIs/ClimaLand/#LSM-Model-Types-and-methods","page":"ClimaLand","title":"LSM Model Types and methods","text":"","category":"section"},{"location":"APIs/ClimaLand/","page":"ClimaLand","title":"ClimaLand","text":"ClimaLand.SoilPlantHydrologyModel\nClimaLand.LandSoilBiogeochemistry\nClimaLand.LandHydrology\nClimaLand.make_interactions_update_aux\nClimaLand.initialize_interactions\nClimaLand.land_components\nClimaLand.lsm_aux_vars\nClimaLand.lsm_aux_types\nClimaLand.lsm_aux_domain_names\nClimaLand.domain_name","category":"page"},{"location":"APIs/ClimaLand/#ClimaLand.LandSoilBiogeochemistry","page":"ClimaLand","title":"ClimaLand.LandSoilBiogeochemistry","text":"struct LandSoilBiogeochemistry{\n    FT,\n    SEH <: Soil.EnergyHydrology{FT},\n    SB <: Soil.Biogeochemistry.SoilCO2Model{FT},\n} <: AbstractLandModel{FT}\n\nA concrete type of land model used for simulating systems with a soil energy, hydrology, and biogeochemistry component.\n\nsoil: The soil model\nsoilco2: The biochemistry model\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.LandHydrology","page":"ClimaLand","title":"ClimaLand.LandHydrology","text":"struct LandHydrology{\n    FT,\n    SM <: Soil.AbstractSoilModel{FT},\n    SW <: Pond.AbstractSurfaceWaterModel{FT},\n} <: AbstractLandModel{FT}\n\nA concrete type of land model used for simulating systems with a soil and surface water component.\n\nsoil: The soil model\nsurface_water: The surface water model\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.land_components","page":"ClimaLand","title":"ClimaLand.land_components","text":"land_components(land::AbstractLandModel)\n\nReturns the component names of the land model, by calling propertynames(land).\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.lsm_aux_vars","page":"ClimaLand","title":"ClimaLand.lsm_aux_vars","text":"lsmauxvars(m::AbstractLandModel)\n\nReturns the additional aux variable symbols for the model in the form of a tuple.\n\n\n\n\n\nlsm_aux_vars(m::SoilCanopyModel)\n\nThe names of the additional auxiliary variables that are included in the integrated Soil-Canopy model.\n\nThese include the broadband albedo of the land surface α_sfc, defined as the ratio of SWu/SWd, and T_sfc, defined as the temperature a blackbody with emissivity ϵ_sfc would have in order to emit the same LWu as the land surface does. This is called the  [effective temperature](https://en.wikipedia.org/wiki/Effectivetemperature) in some fields, and is not the same as the skin temperature (defined e.g. Equation 7.13 of  Bonan, 2019, Climate Change and Terrestrial Ecosystem Modeling.  DOI: 10.1017/9781107339217).\n\n\n\n\n\nlsm_aux_vars(m::LandHydrologyModel)\n\nThe names of the additional auxiliary variables that are included in the integrated Soil-Snow model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.lsm_aux_types","page":"ClimaLand","title":"ClimaLand.lsm_aux_types","text":"lsmauxtypes(m::AbstractLandModel)\n\nReturns the shared additional aux variable types for the model in the form of a tuple.\n\n\n\n\n\nlsm_aux_types(m::SoilCanopyModel)\n\nThe types of the additional auxiliary variables that are included in the integrated Soil-Canopy model.\n\n\n\n\n\nlsm_aux_types(m::LandHydrologyModel)\n\nThe types of the additional auxiliary variables that are included in the integrated Soil-Snow model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.lsm_aux_domain_names","page":"ClimaLand","title":"ClimaLand.lsm_aux_domain_names","text":"lsmauxdomain_names(m::AbstractLandModel)\n\nReturns the additional domain symbols in the form of a tuple e.g. :surface or :subsurface.\n\nThis is only required for variables shared between land submodels, and only needed for multi-component models, not standalone components. Component-specific variables should be listed as prognostic or auxiliary variables which do not require this to initialize.\n\n\n\n\n\nlsm_aux_domain_names(m::SoilCanopyModel)\n\nThe domain names of the additional auxiliary variables that are included in the integrated Soil-Canopy model.\n\n\n\n\n\nlsm_aux_domain_names(m::LandHydrologyModel)\n\nThe domain names of the additional auxiliary variables that are included in the integrated Soil-Snow model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#Land-Hydrology","page":"ClimaLand","title":"Land Hydrology","text":"","category":"section"},{"location":"APIs/ClimaLand/","page":"ClimaLand","title":"ClimaLand","text":"ClimaLand.infiltration_capacity\nClimaLand.infiltration_at_point\nClimaLand.PrognosticRunoff\nClimaLand.RunoffBC","category":"page"},{"location":"APIs/ClimaLand/#ClimaLand.infiltration_capacity","page":"ClimaLand","title":"ClimaLand.infiltration_capacity","text":"function infiltration_capacity(\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n)\n\nFunction which computes the infiltration capacity of the soil based on soil characteristics, moisture levels, and pond height.\n\nDefined such that positive means into soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.infiltration_at_point","page":"ClimaLand","title":"ClimaLand.infiltration_at_point","text":"infiltration_at_point(η::FT, i_c::FT, P::FT)\n\nReturns the infiltration given pond height η, infiltration capacity, and precipitation.\n\nThis is defined such that positive means into soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/ClimaLand/#ClimaLand.PrognosticRunoff","page":"ClimaLand","title":"ClimaLand.PrognosticRunoff","text":"PrognosticRunoff <: Pond.AbstractSurfaceRunoff\n\nConcrete type of Pond.AbstractSurfaceRunoff for use in LSM models, where precipitation is passed in, but infiltration is computed prognostically.\n\nThis is paired with Soil.RunoffBC: both are used at the same time, ensuring the infiltration used for the boundary condition of soil is also used to compute the runoff for the surface water.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#ClimaLand.RunoffBC","page":"ClimaLand","title":"ClimaLand.RunoffBC","text":"RunoffBC <: Soil.AbstractSoilBC\n\nConcrete type of Soil.AbstractSoilBC for use in LSM models, where precipitation is passed in, but infiltration is computed prognostically. This infiltration is then used to set an upper boundary condition for the soil.\n\nThis is paired with Pond.PrognosticRunoff: both are used at the same time, ensuring that the infiltration used for the boundary condition of soil is also used to compute the runoff for the surface water.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#SoilCanopyModel","page":"ClimaLand","title":"SoilCanopyModel","text":"","category":"section"},{"location":"APIs/ClimaLand/","page":"ClimaLand","title":"ClimaLand","text":"ClimaLand.PrognosticSoil\nClimaLand.RootExtraction","category":"page"},{"location":"APIs/ClimaLand/#ClimaLand.RootExtraction","page":"ClimaLand","title":"ClimaLand.RootExtraction","text":"RootExtraction{FT} <: Soil.AbstractSoilSource{FT}\n\nConcrete type of Soil.AbstractSoilSource, used for dispatch in an LSM with both soil and plant hydraulic components.\n\nThis is paired with the source term Canopy.PrognosticSoil:both are used at the same time, ensuring that the water flux into the roots is extracted correctly from the soil.\n\n\n\n\n\n","category":"type"},{"location":"APIs/ClimaLand/#LandSoilBiogeochemistry","page":"ClimaLand","title":"LandSoilBiogeochemistry","text":"","category":"section"},{"location":"APIs/ClimaLand/","page":"ClimaLand","title":"ClimaLand","text":"ClimaLand.PrognosticMet","category":"page"},{"location":"APIs/shared_utilities/#Shared-Utilities","page":"Shared Utilities","title":"Shared Utilities","text":"","category":"section"},{"location":"APIs/shared_utilities/","page":"Shared Utilities","title":"Shared Utilities","text":"CurrentModule = ClimaLand","category":"page"},{"location":"APIs/shared_utilities/#Domains","page":"Shared Utilities","title":"Domains","text":"","category":"section"},{"location":"APIs/shared_utilities/","page":"Shared Utilities","title":"Shared Utilities","text":"ClimaLand.Domains.AbstractDomain\nClimaLand.Domains.AbstractLSMDomain\nClimaLand.Domains.SphericalShell\nClimaLand.Domains.SphericalSurface\nClimaLand.Domains.HybridBox\nClimaLand.Domains.Column\nClimaLand.Domains.Plane\nClimaLand.Domains.Point\nClimaLand.Domains.coordinates\nClimaLand.Domains.obtain_face_space\nClimaLand.Domains.obtain_surface_space\nClimaLand.Domains.obtain_surface_domain\nClimaLand.Domains.top_center_to_surface\nClimaLand.Domains.top_face_to_surface\nClimaLand.Domains.linear_interpolation_to_surface!\nClimaLand.Domains.get_Δz\n","category":"page"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.AbstractDomain","page":"Shared Utilities","title":"ClimaLand.Domains.AbstractDomain","text":"AbstractDomain{FT <:AbstractFloat}\n\nAn abstract type for domains.\n\nThe domain structs typically hold information regarding the bounds of the domain, the boundary condition type (periodic or not), and the spatial discretization.\n\nAdditionally, the domain struct holds the relevant spaces for that domain. For example, a 3D domain holds the center space (in terms of finite difference - the space corresponding to the centers of each element), and the top face space where surface fluxes are computed.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.SphericalShell","page":"Shared Utilities","title":"ClimaLand.Domains.SphericalShell","text":"struct SphericalShell{FT} <: AbstractDomain{FT}\n    radius::FT\n    depth::FT\n    dz_tuple::Union{Tuple{FT, FT}, Nothing}\n    nelements::Tuple{Int, Int}\n    npolynomial::Int\nend\n\nA struct holding the necessary information to construct a domain, a mesh, a 2d spectral element space (non-radial directions) x a 1d finite difference space (radial direction),  and the resulting coordinate field.\n\nspace is a NamedTuple holding the surface space (in this case, the top face space) and the center space for the subsurface. These are stored using the keys :surface and :subsurface.\n\nFields\n\nradius: The radius of the shell\ndepth: The radial extent of the shell\ndz_tuple: Tuple for mesh stretching specifying target (dzbottom, dztop) (m). If nothing, no stretching is applied.\nnelements: The number of elements to be used in the non-radial and radial directions\nnpolynomial: The polynomial order to be used in the non-radial directions\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface space and subsurface center space\nfields: Fields associated with the coordinates of the domain that are useful to store\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.SphericalSurface","page":"Shared Utilities","title":"ClimaLand.Domains.SphericalSurface","text":"struct SphericalSurface{FT} <: AbstractDomain{FT}\n    radius::FT\n    nelements::Tuple{Int, Int}\n    npolynomial::Int\nend\n\nA struct holding the necessary information to construct a domain, a mesh, a 2d spectral element space (non-radial directions) and the resulting coordinate field.\n\nspace is a NamedTuple holding the surface space (in this case, the entire SphericalSurface space).\n\nFields\n\nradius: The radius of the surface\nnelements: The number of elements to be used in the non-radial directions\nnpolynomial: The polynomial order to be used in the non-radial directions\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface (SphericalSurface) space\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.HybridBox","page":"Shared Utilities","title":"ClimaLand.Domains.HybridBox","text":"struct HybridBox{FT} <: AbstractDomain{FT}\n    xlim::Tuple{FT, FT}\n    ylim::Tuple{FT, FT}\n    zlim::Tuple{FT, FT}\n    longlat::Union{Nothing, Tuple{FT, FT}},\n    dz_tuple::Union{Tuple{FT, FT}, Nothing}\n    nelements::Tuple{Int, Int, Int}\n    npolynomial::Int\n    periodic::Tuple{Bool, Bool}\nend\n\nA struct holding the necessary information to construct a domain, a mesh, a 2d spectral element space (horizontal) x a 1d finite difference space (vertical), and the resulting coordinate field. This domain is not periodic along the z-axis. Note that no-flow boundary conditions are supported in the horizontal.\n\nWhen longlat is not nothing, assume that the box describes a region on the globe centered around the long and lat.\n\nspace is a NamedTuple holding the surface space (in this case, the top face space) and the center space for the subsurface. These are stored using the keys :surface and :subsurface.\n\nFields\n\nxlim: Domain interval limits along x axis, in meters or degrees (if latlong != nothing)\nylim: Domain interval limits along y axis, in meters or degrees (if latlong != nothing)\nzlim: Domain interval limits along z axis, in meters\nlonglat: When not nothing, a Tuple that contains the center long and lat.\ndz_tuple: Tuple for mesh stretching specifying target (dzbottom, dztop) (m). If nothing, no stretching is applied.\nnelements: Number of elements to discretize interval, (nx, ny,nz)\nnpolynomial:  Polynomial order for the horizontal directions\nperiodic: Flag indicating periodic boundaries in horizontal\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface space and subsurface center space\nfields: Fields associated with the coordinates of the domain that are useful to store\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.Column","page":"Shared Utilities","title":"ClimaLand.Domains.Column","text":"Column{FT} <: AbstractDomain{FT}\n\nA struct holding the necessary information to construct a domain, a mesh, a center and face space, etc. for use when a finite difference in 1D is suitable, as for a soil column model.\n\nspace is a NamedTuple holding the surface space (in this case, the top face space) and the center space for the subsurface. These are stored using the keys :surface and :subsurface.\n\nFields\n\nzlim: Domain interval limits, (zmin, zmax), in meters\nnelements: Number of elements used to discretize the interval\ndz_tuple: Tuple for mesh stretching specifying target (dzbottom, dztop) (m). If nothing, no stretching is applied.\nboundary_names: Boundary face identifiers\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface space and subsurface center space\nfields: Fields associated with the coordinates of the domain that are useful to store\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.Plane","page":"Shared Utilities","title":"ClimaLand.Domains.Plane","text":"Plane{FT} <: AbstractDomain{FT}\n\nA struct holding the necessary information to construct a domain, a mesh, a 2d spectral element space, and the resulting coordinate field.\n\nWhen longlat is not nothing, the plane is assumed to be centered around these coordinates. In this case, the curvature of the Earth is not accounted for.\n\nlonglat are in degrees, with longitude going from -180 to 180.\n\n:warning: Only independent columns are supported! (No lateral flow).\n\nspace is a NamedTuple holding the surface space (in this case, the entire Plane space).\n\nFields\n\nxlim: Domain interval limits along x axis, in meters or degrees (if latlong != nothing)\nylim: Domain interval limits along y axis, in meters or degrees (if latlong != nothing)\nlonglat: When not nothing, a Tuple that contains the center long and lat (in degrees, with long     from -180 to 180).\nnelements: Number of elements to discretize interval, (nx, ny)\nperiodic: Flags for periodic boundaries. Only periodic or no lateral flow is supported.\nnpolynomial: Polynomial order for both x and y\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the surface(Plane) space\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.Point","page":"Shared Utilities","title":"ClimaLand.Domains.Point","text":"Point{FT} <: AbstractDomain{FT}\n\nA domain for single column surface variables. For models such as ponds, snow, plant hydraulics, etc. Enables consistency in variable initialization across all domains.\n\nspace is a NamedTuple holding the surface space (in this case, the Point space).\n\nFields\n\nz_sfc: Surface elevation relative to a reference (m)\nspace: A NamedTuple of associated ClimaCore spaces: in this case, the Point (surface) space\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.coordinates","page":"Shared Utilities","title":"ClimaLand.Domains.coordinates","text":"coordinates(domain::AbstractDomain)\n\nReturns the coordinate fields for the domain as a NamedTuple.\n\nThe returned coordinates are stored with keys :surface, :subsurface, e.g. as relevant for the domain.\n\n\n\n\n\nDomains.coordinates(model::AbstractLandModel)\n\nReturns a NamedTuple of the unique set of coordinates for the LSM model, where the unique set is taken over the coordinates of all of the subcomponents.\n\nFor example, an LSM with a single layer snow model, multi-layer soil model, and canopy model would have a coordinate set corresponding to the coordinates of the surface (snow), the subsurface coordinates (soil) and the coordinates of the surface (canopy). This would return the coordinates of the surface and subsurface. These are distinct because the subsurface coordinates correspond to the centers of the layers, while the surface corresponds to the top face of the domain.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.obtain_face_space","page":"Shared Utilities","title":"ClimaLand.Domains.obtain_face_space","text":"obtain_face_space(cs::ClimaCore.Spaces.AbstractSpace)\n\nReturns the face space, if applicable, for the center space cs.\n\n\n\n\n\nobtain_face_space(cs::ClimaCore.Spaces.CenterExtrudedFiniteDifferenceSpace)\n\nReturns the face space for the CenterExtrudedFiniteDifferenceSpace cs.\n\n\n\n\n\nobtain_face_space(cs::ClimaCore.Spaces.CenterFiniteDifferenceSpace)\n\nReturns the face space corresponding to the CenterFiniteDifferenceSpace cs.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.obtain_surface_space","page":"Shared Utilities","title":"ClimaLand.Domains.obtain_surface_space","text":"obtain_surface_space(cs::ClimaCore.Spaces.AbstractSpace)\n\nReturns the surface space, if applicable, for the center space cs.\n\n\n\n\n\nobtain_surface_space(cs::ClimaCore.Spaces.CenterExtrudedFiniteDifferenceSpace)\n\nReturns the horizontal space for the CenterExtrudedFiniteDifferenceSpace cs.\n\n\n\n\n\nobtain_surface_space(cs::ClimaCore.Spaces.CenterFiniteDifferenceSpace)\n\nReturns the top level of the face space corresponding to the CenterFiniteDifferenceSpace cs.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.obtain_surface_domain","page":"Shared Utilities","title":"ClimaLand.Domains.obtain_surface_domain","text":"obtain_surface_domain(d::AbstractDomain) where {FT}\n\nDefault method throwing an error; any domain with a corresponding domain should define a new method of this function.\n\n\n\n\n\nobtain_surface_domain(c::Column{FT}) where {FT}\n\nReturns the Point domain corresponding to the top face (surface) of the Column domain c.\n\n\n\n\n\nobtain_surface_domain(b::HybridBox{FT}) where {FT}\n\nReturns the Plane domain corresponding to the top face (surface) of the HybridBox domain b.\n\n\n\n\n\nobtain_surface_domain(s::SphericalShell{FT}) where {FT}\n\nReturns the SphericalSurface domain corresponding to the top face (surface) of the SphericalShell domain s.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.top_center_to_surface","page":"Shared Utilities","title":"ClimaLand.Domains.top_center_to_surface","text":"top_center_to_surface(center_field::ClimaCore.Fields.Field)\n\nCreates and returns a ClimaCore.Fields.Field defined on the space corresponding to the surface of the space on which center_field is defined, with values equal to the those at the level of the top center.\n\nFor example, given a center_field defined on 1D center finite difference space, this would return a field defined on the Point space of the surface of the column. The value would be the value of the oroginal center_field at the topmost location. Given a center_field defined on a 3D extruded center finite difference space, this would return a 2D field corresponding to the surface, with values equal to the topmost level.\n\n\n\n\n\ntop_center_to_surface(val)\n\nWhen val is a scalar (e.g. a single float or struct), returns val.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.top_face_to_surface","page":"Shared Utilities","title":"ClimaLand.Domains.top_face_to_surface","text":"top_face_to_surface(face_field::ClimaCore.Fields.Field, surface_space)\n\nCreates and returns a ClimaCore.Fields.Field defined on the space corresponding to the surface of the space on which face_field is defined, with values equal to the those at the level of the top face.\n\nGiven a face_field defined on a 3D extruded face finite difference space, this would return a 2D field corresponding to the surface, with values equal to the topmost level.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.linear_interpolation_to_surface!","page":"Shared Utilities","title":"ClimaLand.Domains.linear_interpolation_to_surface!","text":"linear_interpolation_to_surface!(sfc_field, center_field, z, Δz_top)\n\nLinearly interpolate the center field center_field to the surface defined by the top face coordinate of z with a center to face distance Δz_top in the first layer; updates the sfc_field on the surface (face) space in place.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.Domains.get_Δz","page":"Shared Utilities","title":"ClimaLand.Domains.get_Δz","text":"get_Δz(z::ClimaCore.Fields.Field)\n\nA function to return a tuple containing the distance between the top boundary and its closest center, and the bottom boundary and its closest center, both as Fields. It also returns the widths of each layer as a field.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#Models","page":"Shared Utilities","title":"Models","text":"","category":"section"},{"location":"APIs/shared_utilities/","page":"Shared Utilities","title":"Shared Utilities","text":"ClimaLand.AbstractModel\nClimaLand.AbstractImExModel\nClimaLand.AbstractExpModel\nClimaLand.make_exp_tendency\nClimaLand.make_imp_tendency\nClimaLand.make_compute_exp_tendency\nClimaLand.make_compute_imp_tendency\nClimaLand.make_update_aux\nClimaLand.make_update_boundary_fluxes\nClimaLand.make_set_initial_cache\nClimaLand.make_update_drivers\nClimaLand.prognostic_vars\nClimaLand.prognostic_types\nClimaLand.prognostic_domain_names\nClimaLand.auxiliary_vars\nClimaLand.auxiliary_types\nClimaLand.auxiliary_domain_names\nClimaLand.initialize_prognostic\nClimaLand.initialize_auxiliary\nClimaLand.initialize\nClimaLand.name\nClimaLand.AbstractBC\nClimaLand.AbstractSource\nClimaLand.source!\nClimaLand.AbstractBoundary\nClimaLand.TopBoundary\nClimaLand.BottomBoundary\nClimaLand.boundary_flux!\nClimaLand.diffusive_flux\nClimaLand.boundary_vars\nClimaLand.boundary_var_domain_names\nClimaLand.boundary_var_types\nClimaLand.make_jacobian\nClimaLand.make_compute_jacobian\nClimaLand.set_dfluxBCdY!\nClimaLand.get_drivers","category":"page"},{"location":"APIs/shared_utilities/#ClimaLand.AbstractModel","page":"Shared Utilities","title":"ClimaLand.AbstractModel","text":"abstract type AbstractModel{FT <: AbstractFloat}\n\nAn abstract type for all models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.AbstractImExModel","page":"Shared Utilities","title":"ClimaLand.AbstractImExModel","text":"AbstractImExModel{FT} <: AbstractModel{FT}\n\nAn abstract type for models which must be treated implicitly (and which may also have tendency terms that can be treated explicitly). This inherits all the default function definitions from AbstractModel, as well as make_imp_tendency and make_compute_imp_tendency defaults.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.AbstractExpModel","page":"Shared Utilities","title":"ClimaLand.AbstractExpModel","text":"AbstractExpModel{FT} <: AbstractModel{FT}\n\nAn abstract type for models which must be treated explicitly. This inherits all the default function definitions from AbstractModel, as well as a make_imp_tendency default.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.make_exp_tendency","page":"Shared Utilities","title":"ClimaLand.make_exp_tendency","text":"make_exp_tendency(model::AbstractModel)\n\nReturns an exp_tendency that updates auxiliary variables and updates the prognostic state of variables that are stepped explicitly.\n\ncompute_exp_tendency! should be compatible with SciMLBase.jl solvers.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.make_imp_tendency","page":"Shared Utilities","title":"ClimaLand.make_imp_tendency","text":"make_imp_tendency(model::AbstractImExModel)\n\nReturns an imp_tendency that updates auxiliary variables and updates the prognostic state of variables that are stepped implicitly.\n\ncompute_imp_tendency! should be compatible with SciMLBase.jl solvers.\n\n\n\n\n\nmake_imp_tendency(model::AbstractModel)\n\nReturns an imp_tendency that does nothing. This model type is not stepped explicity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.make_compute_exp_tendency","page":"Shared Utilities","title":"ClimaLand.make_compute_exp_tendency","text":"make_explicit_tendency(model::Soil.RichardsModel)\n\nAn extension of the function make_compute_imp_tendency, for the Richardson- Richards equation.\n\nConstruct the tendency computation function for the explicit terms of the RHS, which are horizontal components and source/sink terms.\n\n\n\n\n\nmake_compute_exp_tendency(model::EnergyHydrology)\n\nAn extension of the function make_compute_exp_tendency, for the integrated soil energy and heat equations, including phase change.\n\nThis function creates and returns a function which computes the entire right hand side of the PDE for Y.soil.ϑ_l, Y.soil.θ_i, Y.soil.ρe_int, and updates dY.soil in place with those values. All of these quantities will be stepped explicitly.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_compute_exp_tendency(model::BucketModel{FT}) where {FT}\n\nCreates the computeexptendency! function for the bucket model.\n\n\n\n\n\nmake_compute_exp_tendency(model::AbstractModel)\n\nReturn a compute_exp_tendency! function that updates state variables that we will be stepped explicitly. This fallback sets all tendencies of this model to zero, which is appropriate for models that do not have any explicit tendencies to update. Note that we cannot set dY .= 0 here because this would overwrite the tendencies of all models in the case of an integrated LSM.\n\ncompute_exp_tendency! should be compatible with SciMLBase.jl solvers.\n\n\n\n\n\n ClimaLand.make_compute_exp_tendency(component::AbstractCanopyComponent, canopy)\n\nCreates the computeexptendency!(dY,Y,p,t) function for the canopy component.\n\nSince component models are not standalone models, other information may be needed and passed in (via the canopy model itself). The right hand side for the entire canopy model can make use of these functions for the individual components.\n\n\n\n\n\nmake_compute_exp_tendency(canopy::CanopyModel)\n\nCreates and returns the computeexptendency! for the CanopyModel.\n\n\n\n\n\nmake_compute_exp_tendency(model::SoilCO2Model)\n\nAn extension of the function make_compute_exp_tendency, for the soilco2 equation. This function creates and returns a function which computes the entire right hand side of the PDE for C, and updates dY.soil.C in place with that value. These quantities will be stepped explicitly.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_compute_exp_tendency(model::PlantHydraulicsModel, _)\n\nA function which creates the computeexptendency! function for the PlantHydraulicsModel. The computeexptendency! function must comply with a rhs function of SciMLBase.jl.\n\nBelow, fa denotes a flux multiplied by the relevant cross section (per unit area ground, or area index, AI). The tendency for the ith compartment can be written then as: ∂ϑ[i]/∂t = 1/(AI*dz)[fa[i]-fa[i+1]).\n\nNote that if the area_index is zero because no plant is present, AIdz is zero, and the fluxes fa appearing in the numerator are zero because they are scaled by AI.\n\nTo prevent dividing by zero, we change AI/(AI x dz)\" to \"AI/max(AI x dz, eps(FT))\"\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.make_compute_imp_tendency","page":"Shared Utilities","title":"ClimaLand.make_compute_imp_tendency","text":"make_compute_imp_tendency(model::RichardsModel)\n\nAn extension of the function make_compute_imp_tendency, for the Richardson- Richards equation.\n\nThis function creates and returns a function which computes the entire right hand side of the PDE for ϑ_l, and updates dY.soil.ϑ_l in place with that value.\n\n\n\n\n\nmake_compute_imp_tendency(model::EnergyHydrology)\n\nAn extension of the function make_compute_imp_tendency, for the integrated soil energy and heat equations, including phase change.\n\nThis version of this function computes the right hand side of the PDE for Y.soil.ϑ_l, which is the only quantity we currently step implicitly.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_compute_imp_tendency(model::AbstractModel)\n\nReturn a compute_imp_tendency! function that updates state variables that we will be stepped implicitly. This fallback sets all tendencies of this model to zero, which is appropriate for models that do not have any implicit tendencies to update. Note that we cannot set dY .= 0 here because this would overwrite the tendencies of all models in the case of an integrated LSM.\n\ncompute_imp_tendency! should be compatible with SciMLBase.jl solvers.\n\n\n\n\n\n ClimaLand.make_compute_imp_tendency(component::AbstractCanopyComponent, canopy)\n\nCreates the computeimptendency!(dY,Y,p,t) function for the canopy component.\n\nSince component models are not standalone models, other information may be needed and passed in (via the canopy model itself). The right hand side for the entire canopy model can make use of these functions for the individual components.\n\n\n\n\n\nmake_compute_imp_tendency(canopy::CanopyModel)\n\nCreates and returns the computeimptendency! for the CanopyModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.make_update_aux","page":"Shared Utilities","title":"ClimaLand.make_update_aux","text":"make_update_aux(model::RichardsModel)\n\nAn extension of the function make_update_aux, for the Richardson- Richards equation.\n\nThis function creates and returns a function which updates the auxiliary variables p.soil.variable in place.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_update_aux(model::EnergyHydrology)\n\nAn extension of the function make_update_aux, for the integrated soil hydrology and energy model.\n\nThis function creates and returns a function which updates the auxiliary variables p.soil.variable in place.\n\nThis has been written so as to work with Differential Equations.jl.\n\n\n\n\n\nmake_update_aux(model::BucketModel{FT}) where {FT}\n\nCreates the update_aux! function for the BucketModel.\n\n\n\n\n\nmake_update_aux(model::AbstractModel)\n\nReturn an update_aux! function that updates auxiliary parameters p.\n\n\n\n\n\n ClimaLand.make_update_aux(canopy::CanopyModel{FT,\n                                              <:AutotrophicRespirationModel,\n                                              <:Union{BeerLambertModel, TwoStreamModel},\n                                              <:FarquharModel,\n                                              <:MedlynConductanceModel,\n                                              <:PlantHydraulicsModel,},\n                          ) where {FT}\n\nCreates the update_aux! function for the CanopyModel; a specific method for update_aux! for the case where the canopy model components are of the type in the parametric type signature: AutotrophicRespirationModel, AbstractRadiationModel, FarquharModel, MedlynConductanceModel, and PlantHydraulicsModel.\n\nPlease note that the plant hydraulics model has auxiliary variables that are updated in its prognostic compute_exp_tendency! function. While confusing, this is better for performance as it saves looping over the state vector multiple times.\n\nThe other sub-components rely heavily on each other, so the version of the CanopyModel with these subcomponents has a single update_aux! function, given here.\n\n\n\n\n\nmake_update_aux(model::SoilCO2Model)\n\nAn extension of the function make_update_aux, for the soilco2 equation. This function creates and returns a function which updates the auxiliary variables p.soil.variable in place. This has been written so as to work with Differential Equations.jl.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.make_update_boundary_fluxes","page":"Shared Utilities","title":"ClimaLand.make_update_boundary_fluxes","text":"make_update_boundary_fluxes(model::AbstractModel)\n\nReturn an update_boundary_fluxes! function that updates the auxiliary parameters in p corresponding to boundary fluxes or interactions between componets..\n\n\n\n\n\nmake_update_boundary_fluxes(\n    land::LandHydrology{FT, SM, SW},\n) where {FT, SM <: Soil.RichardsModel{FT}, SW <: Pond.PondModel{FT}}\n\nA method which makes a function; the returned function updates the auxiliary variable p.soil_infiltration, which is needed for both the boundary condition for the soil model and the source term (runoff) for the surface water model.\n\nThis function is called each ode function evaluation.\n\n\n\n\n\nmake_update_boundary_fluxes(\n    land::SoilCanopyModel{FT, MM, SM, RM},\n) where {\n    FT,\n    MM <: Soil.Biogeochemistry.SoilCO2Model{FT},\n    SM <: Soil.RichardsModel{FT},\n    RM <: Canopy.CanopyModel{FT}\n    }\n\nA method which makes a function; the returned function updates the additional auxiliary variables for the integrated model, as well as updates the boundary auxiliary variables for all component models.\n\nThis function is called each ode function evaluation, prior to the tendency function evaluation.\n\n\n\n\n\nmake_update_boundary_fluxes(\n    land::LandHydrologyModel{FT, SnM, SoM},\n) where {\n    FT,\n    SnM <: Snow.SnowModel{FT},\n    SoM <: Soil.EnergyHydrology{FT},\n    }\n\nA method which makes a function; the returned function updates the additional auxiliary variables for the integrated model, as well as updates the boundary auxiliary variables for all component models. \n\nThis function is called each ode function evaluation, prior to the tendency function evaluation.\n\nIn this method, we\n\nCompute the ground heat flux between soil and snow. This is required to update the snow and soil boundary fluxes\nUpdate the snow boundary fluxes, which also computes any excess flux of energy or water which occurs when the snow\n\ncompletely melts in a step. In this case, that excess must go to the soil for conservation\n\nUpdate the soil boundary fluxes use precomputed ground heat flux and excess fluxes from snow.\nCompute the net flux for the atmosphere, which is useful for assessing conservation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.make_set_initial_cache","page":"Shared Utilities","title":"ClimaLand.make_set_initial_cache","text":"make_set_initial_cache(model::AbstractModel)\n\nReturns the setinitialcache! function, which updates the auxiliary state p in place with the initial values corresponding to Y(t=t0) = Y0.\n\nIn principle, this function is not needed, because in the very first evaluation of either explicit_tendency or implicit_tendency, at t=t0, the auxiliary state is updated using the initial conditions for Y=Y0. However, without setting the initial p state prior to running the simulation, the value of p in the saved output at t=t0 will be unset.\n\nFurthermore, specific methods of this function may be useful for models which store time indepedent spatially varying parameter fields in the auxiliary state. In this case, update_aux! does not need to do anything, but they do need to be set with the initial (constant) values before the simulation can be carried out.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.make_update_drivers","page":"Shared Utilities","title":"ClimaLand.make_update_drivers","text":"make_update_drivers(::AbstractClimaLandDrivers)\n\nCreates and returns a function which updates the driver variables in the default case of no drivers. More generally, this should return a function which updates the driver fields stored in p.drivers.\n\n\n\n\n\nmake_update_drivers(driver_tuple)\n\nCreates and returns a function which updates the forcing variables (\"drivers\"). If no drivers are being used, driver_tuple is empty, and the update function does nothing.\n\n\n\n\n\nmake_update_drivers(a::PrescribedAtmosphere{FT}) where {FT}\n\nCreates and returns a function which updates the driver variables in the case of a PrescribedAtmosphere.\n\n\n\n\n\nmake_update_drivers(a::PrescribedPrecipitation{FT}) where {FT}\n\nCreates and returns a function which updates the driver variables in the case of a PrescribedPrecipitation.\n\n\n\n\n\nmake_update_drivers(r::PrescribedRadiativeFluxes{FT}) where {FT}\n\nCreates and returns a function which updates the driver variables in the case of a PrescribedRadiativeFluxes.\n\n\n\n\n\nmake_update_drivers(d::PrescribedSoilOrganicCarbon{FT}) where {FT}\n\nCreates and returns a function which updates the driver variables in the case of a PrescribedSoilOrganicCarbon.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.prognostic_vars","page":"Shared Utilities","title":"ClimaLand.prognostic_vars","text":"prognostic_vars(soil::RichardsModel)\n\nA function which returns the names of the prognostic variables of RichardsModel.\n\n\n\n\n\nprognostic_vars(soil::EnergyHydrology)\n\nA function which returns the names of the prognostic variables of EnergyHydrology.\n\n\n\n\n\nprognostic_vars(::SnowModel)\n\nReturns the prognostic variable names of the snow model.\n\nFor this model, we track the snow water equivalent S m and the energy per unit ground area U [J/m^2] prognostically.\n\n\n\n\n\nprognostic_vars(m::AbstractModel)\n\nReturns the prognostic variable symbols for the model in the form of a tuple.\n\nNote that this default suggests that a model has no prognostic variables, which is an invalid model setup. This function is meant to be extended for all models.\n\n\n\n\n\nClimaLand.prognostic_vars(::AbstractCanopyComponent)\n\nReturns the prognostic vars of the canopy component passed in as an argument.\n\n\n\n\n\nprognostic_vars(canopy::CanopyModel)\n\nReturns the prognostic variables for the canopy model by looping over each sub-component name in canopy_components.\n\nThis relies on the propertynames of CanopyModel being the same as those returned by canopy_components.\n\n\n\n\n\nprognostic_vars(model::PlantHydraulicsModel)\n\nA function which returns the names of the prognostic variables of the PlantHydraulicsModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.prognostic_types","page":"Shared Utilities","title":"ClimaLand.prognostic_types","text":"prognostic_types(soil::EnergyHydrology{FT}) where {FT}\n\nA function which returns the types of the prognostic variables of EnergyHydrology.\n\n\n\n\n\nprognostic_types(::SnowModel{FT})\n\nReturns the prognostic variable types of the snow model; both snow water equivalent and energy per unit area are scalars.\n\n\n\n\n\nprognostic_types(m::AbstractModel{FT}) where {FT}\n\nReturns the prognostic variable types for the model in the form of a tuple.\n\nTypes provided must have ClimaCore.RecursiveApply.rzero(T::DataType)  defined. Common examples  include\n\nFloat64, Float32 for scalar variables (a scalar value at each\n\ncoordinate point)\n\nSVector{k,Float64} for a mutable but statically sized array of\n\nlength k at each coordinate point.\n\nHere, the coordinate points are those returned by coordinates(model).\n\nNote that this default suggests that a model has no prognostic variables, which is an invalid model setup. This function is meant to be extended for all models.\n\n\n\n\n\nClimaLand.prognostic_types(::AbstractCanopyComponent)\n\nReturns the prognostic types of the canopy component passed in as an argument.\n\n\n\n\n\nprognostic_types(canopy::CanopyModel)\n\nReturns the prognostic types for the canopy model by looping over each sub-component name in canopy_components.\n\nThis relies on the propertynames of CanopyModel being the same as those returned by canopy_components.\n\n\n\n\n\nClimaLand.prognostic_types(model::PlantHydraulicsModel{FT}) where {FT}\n\nDefines the prognostic types for the PlantHydraulicsModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.prognostic_domain_names","page":"Shared Utilities","title":"ClimaLand.prognostic_domain_names","text":"prognostic_domain_names(::SnowModel)\n\nReturns the prognostic variable domain names of the snow model; both snow water equivalent and energy per unit area are modeling only as a function of (x,y), and not as a function of depth. Therefore their domain name is \":surface\".\n\n\n\n\n\nprognosticdomainnames(m::AbstractModel)\n\nReturns the domain names for the prognostic variables in the form of a tuple.\n\nExamples: (:surface, :surface, :subsurface).\n\nNote that this default suggests that a model has no prognostic variables, which is an invalid model setup. This function is meant to be extended for all models.\n\n\n\n\n\nprognosticdomainnames(m::AbstractCanopyComponent)\n\nReturns the domain names for the prognostic variables in the form of a tuple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.auxiliary_vars","page":"Shared Utilities","title":"ClimaLand.auxiliary_vars","text":"auxiliary_vars(soil::RichardsModel)\n\nA function which returns the names of the auxiliary variables of RichardsModel.\n\n\n\n\n\nauxiliary_vars(soil::EnergyHydrology)\n\nA function which returns the names of the auxiliary variables of EnergyHydrology.\n\n\n\n\n\nauxiliary_vars(::SnowModel)\n\nReturns the auxiliary variable names for the snow model. These include the mass fraction in liquid water (q_l, unitless), the thermal conductivity (κ, W/m/K), the bulk temperature (T, K), the surface temperature (T_sfc, K), the depth (z, m), the SHF, LHF, and vapor flux (turbulent_fluxes.shf, etc), the net radiation (R_n, J/m^2/s), the energy flux in liquid water runoff (energy_runoff, J/m^2/s), the water volume in runoff (water_runoff, m/s), and the total energy and water fluxes applied to the snowpack.\n\nSince the snow can melt completely in one timestep, we clip the water and energy fluxes such that SWE cannot become negative and U cannot become unphysical. The clipped values are what are actually applied as boundary fluxes, and are stored in applied_ fluxes.\n\n\n\n\n\nauxiliary_vars(m::AbstractModel)\n\nReturns the auxiliary variable symbols for the model in the form of a tuple.\n\n\n\n\n\nClimaLand.auxiliary_vars(::AbstractCanopyComponent)\n\nReturns the auxiliary types of the canopy component passed in as an argument.\n\n\n\n\n\nauxiliary_vars(canopy::CanopyModel)\n\nReturns the auxiliary variables for the canopy model by looping over each sub-component name in canopy_components.\n\nThis relies on the propertynames of CanopyModel being the same as those returned by canopy_components.\n\n\n\n\n\nauxiliary_vars(model::PlantHydraulicsModel)\n\nA function which returns the names of the auxiliary variables of the PlantHydraulicsModel, the transpiration stress factor β (unitless), the water potential ψ (m), the volume fluxcross section fa (1/s), and the volume fluxroot cross section in the roots fa_roots (1/s), where the cross section can be represented by an area index.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.auxiliary_types","page":"Shared Utilities","title":"ClimaLand.auxiliary_types","text":"auxiliary_types(soil::RichardsModel)\n\nA function which returns the names of the auxiliary types of RichardsModel.\n\n\n\n\n\nauxiliary_types(soil::EnergyHydrology{FT}) where {FT}\n\nA function which returns the types of the auxiliary variables of EnergyHydrology.\n\n\n\n\n\nauxiliary_types(m::AbstractModel{FT}) where {FT}\n\nReturns the auxiliary variable types for the model in the form of a tuple.\n\nTypes provided must have ClimaCore.RecursiveApply.rzero(T::DataType) defined. Common examples  include\n\nFloat64, Float32 for scalar variables (a scalar value at each\n\ncoordinate point)\n\nSVector{k,Float64} for a mutable but statically sized array of\n\nlength k at each coordinate point.\n\nNote that Arrays, MVectors are not isbits and cannot be used.\n\nHere, the coordinate points are those returned by coordinates(model).\n\n\n\n\n\nClimaLand.auxiliary_types(::AbstractCanopyComponent)\n\nReturns the auxiliary types of the canopy component passed in as an argument.\n\n\n\n\n\nauxiliary_types(canopy::CanopyModel)\n\nReturns the auxiliary types for the canopy model by looping over each sub-component name in canopy_components.\n\nThis relies on the propertynames of CanopyModel being the same as those returned by canopy_components.\n\n\n\n\n\nClimaLand.auxiliary_types(model::PlantHydraulicsModel{FT}) where {FT}\n\nDefines the auxiliary types for the PlantHydraulicsModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.auxiliary_domain_names","page":"Shared Utilities","title":"ClimaLand.auxiliary_domain_names","text":"auxiliary_domain_names(soil::RichardsModel)\n\nA function which returns the names of the auxiliary domain names of RichardsModel.\n\n\n\n\n\nauxiliarydomainnames(m::AbstractModel)\n\nReturns the domain names for the auxiliary variables in the form of a tuple.\n\nExamples: (:surface, :surface, :subsurface).\n\n\n\n\n\nauxiliarydomainnames(m::AbstractCanopyComponent)\n\nReturns the domain names for the auxiliary variables in the form of a tuple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.initialize_prognostic","page":"Shared Utilities","title":"ClimaLand.initialize_prognostic","text":"initialize_prognostic(model::AbstractModel, state::NamedTuple)\n\nReturns a FieldVector of prognostic variables for model with the required structure, with values equal to similar(state). This assumes that all prognostic variables are defined over the entire domain, and that all prognostic variables have the same dimension and type.\n\nIf a model has no prognostic variables, the returned FieldVector contains only an empty array.\n\nThe input state is an array-like object, usually a ClimaCore Field or a Vector{FT}.\n\nAdjustments to this - for example because different prognostic variables have different dimensions - require defining a new method.\n\n\n\n\n\ninitialize_prognostic(\n    component::AbstractCanopyComponent,\n    state,\n)\n\nCreates and returns a ClimaCore.Fields.FieldVector with the prognostic variables of the canopy component  component, stored using the name of the component.\n\nThe input state is usually a ClimaCore Field object.\n\n\n\n\n\ninitialize_prognostic(\n    model::CanopyModel{FT},\n    coords,\n) where {FT}\n\nCreates the prognostic state vector of the CanopyModel and returns it as a ClimaCore.Fields.FieldVector.\n\nThe input state is usually a ClimaCore Field object.\n\nThis function loops over the components of the CanopyModel and appends each component models prognostic state vector into a single state vector, structured by component name.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.initialize_auxiliary","page":"Shared Utilities","title":"ClimaLand.initialize_auxiliary","text":"initialize_auxiliary(model::AbstractModel, state::NamedTuple)\n\nReturns a NamedTuple of auxiliary variables for model with the required structure, with values equal to similar(state). This assumes that all  auxiliary variables are defined over the entire domain, and that all auxiliary variables have the same dimension and type. The auxiliary variables NamedTuple can also hold preallocated objects which are not Fields.\n\nIf a model has no auxiliary variables, the returned NamedTuple contains only an empty array.\n\nThe input state is an array-like object, usually a ClimaCore Field or a Vector{FT}.\n\nAdjustments to this - for example because different auxiliary variables have different dimensions - require defining a new method.\n\n\n\n\n\ninitialize_auxiliary(\n    component::AbstractCanopyComponent,\n    state,\n)\n\nCreates and returns a ClimaCore.Fields.FieldVector with the auxiliary variables of the canopy component  component, stored using the name of the component.\n\nThe input state is usually a ClimaCore Field object.\n\n\n\n\n\ninitialize_auxiliary(\n    model::CanopyModel{FT},\n    coords,\n) where {FT}\n\nCreates the auxiliary state vector of the CanopyModel and returns  it as a ClimaCore.Fields.FieldVector.\n\nThe input coords is usually a ClimaCore Field object.\n\nThis function loops over the components of the CanopyModel and appends each component models auxiliary state vector into a single state vector, structured by component name.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.initialize","page":"Shared Utilities","title":"ClimaLand.initialize","text":"initialize(model::AbstractModel)\n\nCreates the prognostic and auxiliary states structures, but with unset values; constructs and returns the coordinates for the model domain. We may need to consider this default more as we add diverse components and Simulations.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.name","page":"Shared Utilities","title":"ClimaLand.name","text":"name(model::AbstractModel)\n\nReturns a symbol of the model component name, e.g. :soil or :vegetation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.AbstractBC","page":"Shared Utilities","title":"ClimaLand.AbstractBC","text":"AbstractBC\n\nAn abstract type for types of boundary conditions, which will include prescribed functions of space and time as Dirichlet conditions or Neumann conditions, in addition to other  convenient conditions.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.AbstractSource","page":"Shared Utilities","title":"ClimaLand.AbstractSource","text":"AbstractSource{FT <: AbstractFloat}\n\nAn abstract type for types of source terms.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.source!","page":"Shared Utilities","title":"ClimaLand.source!","text":" source!(dY::ClimaCore.Fields.FieldVector,\n         src::PhaseChange{FT},\n         Y::ClimaCore.Fields.FieldVector,\n         p::NamedTuple,\n         model\n         )\n\nComputes the source terms for phase change.\n\n\n\n\n\n source!(dY::ClimaCore.Fields.FieldVector,\n         src::SoilSublimation{FT},\n         Y::ClimaCore.Fields.FieldVector,\n         p::NamedTuple,\n         model\n         )\n\nUpdates dY.soil.θ_i in place with a term due to sublimation; this only affects the surface layer of soil.\n\n\n\n\n\n source!(dY::ClimaCore.Fields.FieldVector,\n         src::AbstractSource,\n         Y::ClimaCore.Fields.FieldVector,\n         p::NamedTuple\n         )::ClimaCore.Fields.Field\n\nA stub function, which is extended by ClimaLand.\n\n\n\n\n\nClimaLand.source!(dY::ClimaCore.Fields.FieldVector,\n                 src::RootExtraction,\n                 Y::ClimaCore.Fields.FieldVector,\n                 p::NamedTuple\n                 model::EnergyHydrology)\n\nAn extension of the ClimaLand.source! function,  which computes source terms for the soil model; this method returns the water and energy loss/gain due to root extraction.\n\n\n\n\n\n source!(dY::ClimaCore.Fields.FieldVector,\n         src::SoilSublimationwithSnow{FT},\n         Y::ClimaCore.Fields.FieldVector,\n         p::NamedTuple,\n         model\n         )\n\nUpdates dY.soil.θ_i in place with a term due to sublimation; this only affects the surface layer of soil.\n\n\n\n\n\nClimaLand.source!(dY::ClimaCore.Fields.FieldVector,\n                      src::MicrobeProduction,\n                      Y::ClimaCore.Fields.FieldVector,\n                      p::NamedTuple,\n                      params)\n\nA method which extends the ClimaLand source! function for the case of microbe production of CO2 in soil.\n\n\n\n\n\nClimaLand.source!(\n    dY::ClimaCore.Fields.FieldVector,\n    src::TOPMODELSubsurfaceRunoff,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    model::AbstractSoilModel{FT},\n) where {FT}\n\nAdjusts dY.soil.ϑ_l in place to account for the loss of water due to subsurface runoff.\n\nThe sink term is given by - Rss/h∇ H(twc - ν), where H is the Heaviside function, h∇ is the water table thickness (defined to be where twc>ν), where twc is the total water content,  and Rss is the runoff as a flux(m/s).\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.AbstractBoundary","page":"Shared Utilities","title":"ClimaLand.AbstractBoundary","text":"AbstractBoundary\n\nAn abstract type to indicate which boundary we are doing calculations for. Currently, we support the top boundary (TopBoundary) and bottom boundary (BottomBoundary).\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.TopBoundary","page":"Shared Utilities","title":"ClimaLand.TopBoundary","text":"TopBoundary{} <: AbstractBoundary{}\n\nA simple object which should be passed into a function to indicate that we are considering the top boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.BottomBoundary","page":"Shared Utilities","title":"ClimaLand.BottomBoundary","text":"BottomBoundary{} <: AbstractBoundary{}\n\nA simple object which should be passed into a function to indicate that we are considering the bottom boundary.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.boundary_flux!","page":"Shared Utilities","title":"ClimaLand.boundary_flux!","text":"boundary_flux!(bc_field, bc::WaterFluxBC,  _...)\n\nA method of boundary fluxes which updates the desired flux.\n\n\n\n\n\nboundary_flux!(bc_field, bc::RichardsAtmosDrivenFluxBC,\n                       boundary::ClimaLand.AbstractBoundary,\n                       model::RichardsModel{FT},\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       ) where {FT}\n\nA method of boundary fluxes which returns the desired water volume flux for the RichardsModel, at the top of the domain, in the case of a prescribed precipitation flux.\n\nIf model.runoff is not of type NoRunoff, surface runoff is accounted for when computing the infiltration.\n\n\n\n\n\nboundary_flux!(bc_field, rre_bc::MoistureStateBC,\n                       ::ClimaLand.TopBoundary,\n                       model::AbstractSoilModel,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       )\n\nA method of boundary fluxes which converts a state boundary condition on θ_l at the top of the domain into a flux of liquid water.\n\n\n\n\n\nboundary_flux!(bc_field, rre_bc::MoistureStateBC,\n                       ::ClimaLand.BottomBoundary,\n                       model::AbstractSoilModel,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       )\n\nA method of boundary fluxes which converts a state boundary condition on θ_l at the bottom of the domain into a flux of liquid water.\n\n\n\n\n\nboundary_flux!(bc_field, bc::FreeDrainage,\n                       boundary::ClimaLand.BottomBoundary,\n                       model::AbstractSoilModel,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       )\n\nA method of boundary fluxes which enforces free drainage at the bottom of the domain.\n\n\n\n\n\nboundary_flux!(bc_field, bc::HeatFluxBC,  _...)\n\nA method of boundary fluxes which updates the desired flux.\n\n\n\n\n\nboundary_flux!(bc_field, heat_bc::TemperatureStateBC,\n                       ::ClimaLand.TopBoundary,\n                       model::EnergyHydrology,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       ):\n\nA method of boundary fluxes which converts a state boundary condition on temperature at the top of the domain into a flux of energy.\n\n\n\n\n\nboundary_flux!(bc_field, heat_bc::TemperatureStateBC,\n                       ::ClimaLand.BottomBoundary,\n                       model::EnergyHydrology,\n                       Δz::ClimaCore.Fields.Field,\n                       Y::ClimaCore.Fields.FieldVector,\n                       p::NamedTuple,\n                       t,\n                       )\n\nA method of boundary fluxes which converts a state boundary condition on temperature at the bottom of the domain into a flux of energy.\n\n\n\n\n\nboundary_flux!(bc_field, bc::AbstractBC, bound_type::AbstractBoundary, Δz, _...)\n\nA function which updates bc_field with the correct boundary flux  given any boundary condition (BC). \n\n\n\n\n\nfunction ClimaLand.boundary_flux!(bc_field,\n    bc::RunoffBC,\n    ::TopBoundary,\n    model::Soil.RichardsModel,\n    Δz::FT,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n    params,\n)\n\nExtension of the ClimaLand.boundary_flux function, which returns the water volume boundary flux for the soil. At the top boundary, return the soil infiltration (computed each step and stored in p.soil_infiltration).\n\n\n\n\n\nClimaLand.boundary_flux!(bc_field,\n    bc::SoilCO2FluxBC,\n    boundary::ClimaLand.AbstractBoundary,\n    Δz::ClimaCore.Fields.Field,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nA method of ClimaLand.boundary_flux which updates the soilco2 flux (kg CO2 /m^2/s) in the case of a prescribed flux BC at either the top or bottom of the domain.\n\n\n\n\n\nClimaLand.boundary_flux!(bc_field,\nbc::SoilCO2StateBC,\nboundary::ClimaLand.TopBoundary,\nΔz::ClimaCore.Fields.Field,\nY::ClimaCore.Fields.FieldVector,\np::NamedTuple,\nt,\n)\n\nA method of ClimaLand.boundary_flux which returns the soilco2 flux in the case of a prescribed state BC at  top of the domain.\n\n\n\n\n\nClimaLand.boundary_flux!(bc_field,\n    bc::SoilCO2StateBC,\n    boundary::ClimaLand.BottomBoundary,\n    Δz::ClimaCore.Fields.Field,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nA method of ClimaLand.boundary_flux which returns the soilco2 flux in the case of a prescribed state BC at bottom of the domain.\n\n\n\n\n\nClimaLand.boundary_flux!(bc_field,\nbc::AtmosCO2StateBC,\nboundary::ClimaLand.TopBoundary,\nΔz::ClimaCore.Fields.Field,\nY::ClimaCore.Fields.FieldVector,\np::NamedTuple,\nt,\n)\n\nA method of ClimaLand.boundary_flux which returns the soilco2 flux in the case when the atmospheric CO2 is ued at top of the domain.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.diffusive_flux","page":"Shared Utilities","title":"ClimaLand.diffusive_flux","text":"diffusive_flux(K, x_2, x_1, Δz)\n\nCalculates the diffusive flux of a quantity x (water content, temp, etc). Here, x2 = x(z + Δz) and x1 = x(z), so x_2 is at a larger z by convention.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.boundary_vars","page":"Shared Utilities","title":"ClimaLand.boundary_vars","text":"boundary_vars(::RichardsAtmosDrivenFluxBC{<:PrescribedPrecipitation,\n                                          <:Runoff.AbstractRunoffModel,\n                                          }, ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_vars method for RichardsAtmosDrivenFluxBC with runoff.\n\nThese variables are updated in place in boundary_flux!.\n\n\n\n\n\nboundary_vars(::AtmosDrivenFluxBC{<:AbstractAtmosphericDrivers,\n                                <:AbstractRadiativeDrivers,\n                                <:AbstractRunoffModel,\n                                }, ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_vars method for AtmosDrivenFluxBC. This adds the surface conditions (SHF, LHF, evaporation, and resistance) and the net radiation to the auxiliary variables.\n\nThese variables are updated in place in soil_boundary_fluxes!.\n\n\n\n\n\nboundary_vars(::MoistureStateBC, ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_vars method for MoistureStateBC at the top boundary.\n\nThese variables are updated in place in boundary_flux!.\n\n\n\n\n\nboundary_vars(::AbstractBC , ::ClimaLand.TopBoundary)\n\nThe list of symbols for additional variables to add to the model auxiliary state, for models solving PDEs, which defaults  to adding storage for the top boundary flux fields, but which can be extended depending on the type of  boundary condition used.\n\nFor the Soil and SoilCO2 models - which solve PDEs - the  tendency functions and  updateboundaryfluxes functions are coded to access the field  :top_bc  to be present in the model cache, which is why  this is the default.  If this is not your (PDE) model's  desired behavior, you can extend this function with a new method.\n\nThe field top_bc_wvec is created to prevent allocations only; it is used in the tendency function only.\n\nUse this function in the exact same way you would use auxiliary_vars.\n\n\n\n\n\nboundary_vars(::AbstractBC, ::ClimaLand.BottomBoundary)\n\nThe list of symbols for additional variables to add to the model auxiliary state, for models solving PDEs, which defaults  to adding storage for the bottom boundary flux fields, but which can be extended depending on the type of  boundary condition used.\n\nFor the Soil and SoilCO2 models - which solve PDEs - the  tendency functions and  updateboundaryfluxes functions are coded to access the field  :bottom_bc  to be present in the model cache, which is why  this is the default.  If this is not your (PDE) model's  desired behavior, you can extend this function with a new method.\n\nThe field bottom_bc_wvec is created to prevent allocations only; it is used in the tendency function only.\n\nUse this function in the exact same way you would use auxiliary_vars.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.boundary_var_domain_names","page":"Shared Utilities","title":"ClimaLand.boundary_var_domain_names","text":"boundary_var_domain_names(::RichardsAtmosDrivenFluxBC{<:PrescribedPrecipitation,\n                                          <:Runoff.AbstractRunoffModel,\n                                          },\n                          ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_var_domain_names method for RichardsAtmosDrivenFluxBC with runoff.\n\n\n\n\n\nboundary_var_domain_names(::AtmosDrivenFluxBC,\n                          ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_var_domain_names method for AtmosDrivenFluxBC. This specifies the part of the domain on which the additional variables should be defined.\n\n\n\n\n\nboundary_var_domain_names(::MoistureStateBC, ::ClimaLand.TopBoundary)\n\nAn extension of the boundary_var_domain_names method for MoistureStateBC at the top boundary.\n\n\n\n\n\nboundary_var_domain_names(::AbstractBC, ::ClimaLand.AbstractBoundary)\n\nThe list of domain names for additional variables to add to the model auxiliary state, for models solving PDEs, which defaults  to adding storage on the surface domain  for the top or bottom boundary flux fields, but which can be extended depending on the type of  boundary condition used.\n\nUse in conjunction with boundary_vars, in the same way you would use auxiliary_var_domain_names. \n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.boundary_var_types","page":"Shared Utilities","title":"ClimaLand.boundary_var_types","text":"boundary_var_types(::RichardsModel{FT},\n                    ::RichardsAtmosDrivenFluxBC{<:PrescribedPrecipitation,\n                                                <: Runoff.AbstractRunoffModel,\n                                              },\n                    ::ClimaLand.TopBoundary,\n                    ) where {FT}\n\nAn extension of the boundary_var_types method for RichardsAtmosDrivenFluxBC with runoff.\n\n\n\n\n\nboundary_var_types(::Soil.EnergyHydrology{FT}, ::AbstractEnergyHydrologyBC, ::ClimaLand.AbstractBoundary) where {FT}\n\nThe list of domain names for additional variables added to the EnergyHydrology model auxiliary state, which defaults to adding storage for the  boundary flux field.\n\nBecause we supply boundary conditions for water and heat, we found it convenient to have these stored as a NamedTuple under the names top_bc and bottom_bc.\n\n\n\n\n\nboundary_var_types(\n    ::EnergyHydrology{FT},\n    ::AtmosDrivenFluxBC,\n    ::ClimaLand.TopBoundary,\n) where {FT}\n\nAn extension of the boundary_var_types method for AtmosDrivenFluxBC. This specifies the type of the additional variables.\n\n\n\n\n\nboundary_var_types(::RichardsModel{FT},\n                    ::MoistureStateBC,\n                    ::ClimaLand.TopBoundary,\n                    ) where {FT}\n\nAn extension of the boundary_var_types method for MoistureStateBC at the     top boundary.\n\n\n\n\n\nboundary_var_types(model::AbstractModel{FT}, ::AbstractBC, ::ClimaLand.AbstractBoundary) where {FT}\n\nThe list of types for additional variables to add to the model auxiliary state, for models solving PDEs, which defaults  to adding a scalar variable on the surface domain  for the top or bottom boundary flux fields, but which can be extended depending on the type of  boundary condition used.\n\nUse in conjunction with boundary_vars, in the same way you would use auxiliary_var_types. The use of a scalar is appropriate for models with a single PDE; models with multiple PDEs will need to supply multiple scalar fields.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.make_jacobian","page":"Shared Utilities","title":"ClimaLand.make_jacobian","text":"make_jacobian(model::AbstractModel)\n\nCreates and returns a function which updates the auxiliary variables p in place and then updates the entries of the Jacobian matrix W for the model in place.\n\nThe default is that no updates are required, no implicit tendency is present, and hence the timestepping is entirely explicit.\n\nNote that the returned function jacobian! should be used as Wfact! in ClimaTimeSteppers.jl and SciMLBase.jl.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.make_compute_jacobian","page":"Shared Utilities","title":"ClimaLand.make_compute_jacobian","text":"ClimaLand.make_compute_jacobian(model::RichardsModel{FT}) where {FT}\n\nCreates and returns the compute_jacobian! function for RichardsModel. This updates the contribution for the soil liquid water content.\n\nUsing this Jacobian with a backwards Euler timestepper is equivalent to using the modified Picard scheme of Celia et al. (1990).\n\n\n\n\n\nClimaLand.make_compute_jacobian(model::EnergyHydrology{FT}) where {FT}\n\nCreates and returns the compute_jacobian! function for the EnergyHydrology model. This updates the contribution for the soil liquid water content only.\n\nUsing this Jacobian with a backwards Euler timestepper is equivalent to using the modified Picard scheme of Celia et al. (1990).\n\n\n\n\n\nmake_compute_jacobian(model::AbstractModel)\n\nCreates and returns a function which computes the entries of the Jacobian matrix W in place.\n\nIf the implicit tendency function is given by T!(dY, Y, p, t) = make_implicit_tendency(model), the Jacobian should be given by W_{i,j}! = ∂T!_i/∂Y_j, where Y_j is the j-th state variable and T!_i is the implicit tendency of the i-th state variable.\n\nThe default is that no updates are required, but this function must be extended for models that use implicit timestepping.\n\n\n\n\n\nClimaLand.make_compute_jacobian(canopy::CanopyModel)\n\nCreates and returns the compute_jacobian! for the CanopyModel.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.set_dfluxBCdY!","page":"Shared Utilities","title":"ClimaLand.set_dfluxBCdY!","text":"ClimaLand.set_dfluxBCdY!(\n    model::RichardsModel,\n    ::MoistureStateBC,\n    boundary::ClimaLand.TopBoundary,\n    Δz,\n    Y,\n    p,\n    t,\n\n)\n\nComputes the derivative of the flux in the top layer (due to the boundary condition), with respect to the state variable in the top layer. This value is then updated in-place in the cache.\n\nFor Richards equation (a diffusion equation with a single state variable), this is given by ∂F_bc/∂Y_N= -K_N (∂ψ_bc/∂ϑ_N) / Δz, where N indicates the top layer cell index and ψ_bc is the pressure head at the boundary condition.\n\n\n\n\n\nset_dfluxBCdY!(::AbstractModel,\n              ::AbstractBC,\n              ::AbstractBoundary,\n              _...)::Union{ClimaCore.Fields.FieldVector, Nothing}\n\nA function stub which returns the derivative of the implicit tendency term of the model arising from the boundary condition, with respect to the state Y.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.get_drivers","page":"Shared Utilities","title":"ClimaLand.get_drivers","text":"ClimaLand.get_drivers(model::RichardsModel)\n\nReturns the driver variable symbols for the RichardsModel; these depend on the boundary condition type and currently only are required for the RichardsAtmosDrivenFluxBC, which is driven by a prescribed time and space varying precipitation.\n\n\n\n\n\nClimaLand.get_drivers(model::SnowModel)\n\nReturns the driver variable symbols for the SnowModel.\n\n\n\n\n\nget_drivers(model::AbstractModel)\n\nReturns the driver objects for the model - atmospheric and radiative forcing, etc - as a tuple (atmos, radiation, ...). If no drivers are needed by a model, an empty tuple should be returned\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#Drivers","page":"Shared Utilities","title":"Drivers","text":"","category":"section"},{"location":"APIs/shared_utilities/","page":"Shared Utilities","title":"Shared Utilities","text":"ClimaLand.PrescribedAtmosphere\nClimaLand.PrescribedPrecipitation\nClimaLand.PrescribedRadiativeFluxes\nClimaLand.PrescribedSoilOrganicCarbon\nClimaLand.CoupledAtmosphere\nClimaLand.CoupledRadiativeFluxes\nClimaLand.AbstractAtmosphericDrivers\nClimaLand.AbstractRadiativeDrivers\nClimaLand.turbulent_fluxes\nClimaLand.turbulent_fluxes_at_a_point\nClimaLand.radiative_fluxes_at_a_point\nClimaLand.set_atmos_ts!\nClimaLand.surface_air_density\nClimaLand.surface_temperature\nClimaLand.surface_resistance\nClimaLand.surface_specific_humidity\nClimaLand.make_update_drivers","category":"page"},{"location":"APIs/shared_utilities/#ClimaLand.PrescribedAtmosphere","page":"Shared Utilities","title":"ClimaLand.PrescribedAtmosphere","text":"PrescribedAtmosphere{FT, CA, DT} <: AbstractAtmosphericDrivers{FT}\n\nContainer for holding prescribed atmospheric drivers and other information needed for computing turbulent surface fluxes when driving land models in standalone mode.\n\nThe default CO2 concentration is a constant as a function of time, equal to 4.2e-4 mol/mol.\n\nSince not all models require co2 concentration, the default for that is nothing.\n\nliquid_precip: Precipitation (m/s) function of time: positive by definition\nsnow_precip: Snow precipitation (m/s) function of time: positive by definition\nT: Prescribed atmospheric temperature (function of time)  at the reference height (K)\nu: Prescribed wind speed (function of time)  at the reference height (m/s)\nq: Prescribed specific humidity (function of time)  at the reference height (_)\nP: Prescribed air pressure (function of time)  at the reference height (Pa)\nc_co2: CO2 concentration in atmosphere (mol/mol)\nstart_date: Start date - the datetime corresponding to t=0 for the simulation\nh: Reference height (m), relative to surface elevation\ngustiness: Minimum wind speed (gustiness; m/s)\nthermo_params: Thermodynamic parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.PrescribedPrecipitation","page":"Shared Utilities","title":"ClimaLand.PrescribedPrecipitation","text":"PrescribedPrecipitation{FT, LP} <: AbstractAtmosphericDrivers{FT}\n\nContainer for holding prescribed precipitation driver for models which only require precipitation (RichardsModel).\n\nliquid_precip: Precipitation (m/s) function of time: positive by definition\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.PrescribedRadiativeFluxes","page":"Shared Utilities","title":"ClimaLand.PrescribedRadiativeFluxes","text":"PrescribedRadiativeFluxes{FT, SW, LW, DT, T} <: AbstractRadiativeDrivers{FT}\n\nContainer for the prescribed radiation functions needed to drive land models in standalone mode.\n\nSW_d: Downward shortwave radiation function of time (W/m^2): positive indicates towards surface\nLW_d: Downward longwave radiation function of time (W/m^2): positive indicates towards surface\nstart_date: Start date - the datetime corresponding to t=0 for the simulation\nθs: Sun zenith angle, in radians\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.PrescribedSoilOrganicCarbon","page":"Shared Utilities","title":"ClimaLand.PrescribedSoilOrganicCarbon","text":" PrescribedSoilOrganicCarbon{FT}\n\nA type for prescribing soil organic carbon.\n\nsoc: Soil organic carbon, function of time and space: kg C/m^3\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.CoupledAtmosphere","page":"Shared Utilities","title":"ClimaLand.CoupledAtmosphere","text":"CoupledAtmosphere{FT} <: AbstractAtmosphericDrivers{FT}\n\nTo be used when coupling to an atmosphere model.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.CoupledRadiativeFluxes","page":"Shared Utilities","title":"ClimaLand.CoupledRadiativeFluxes","text":"CoupledRadiativeFluxes{FT} <: AbstractRadiativeDrivers{FT}\n\nTo be used when coupling to an atmosphere model.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.AbstractAtmosphericDrivers","page":"Shared Utilities","title":"ClimaLand.AbstractAtmosphericDrivers","text":" AbstractAtmosphericDrivers{FT}\n\nAn abstract type of atmospheric drivers of land models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.AbstractRadiativeDrivers","page":"Shared Utilities","title":"ClimaLand.AbstractRadiativeDrivers","text":" AbstractRadiativeDrivers{FT}\n\nAn abstract type of radiative drivers of land models.\n\n\n\n\n\n","category":"type"},{"location":"APIs/shared_utilities/#ClimaLand.turbulent_fluxes","page":"Shared Utilities","title":"ClimaLand.turbulent_fluxes","text":"turbulent_fluxes(atmos::PrescribedAtmosphere,\n               model::AbstractModel,\n               Y::ClimaCore.Fields.FieldVector,\n               p::NamedTuple,\n               t\n               )\n\nComputes the turbulent surface flux terms at the ground for a standalone simulation, including turbulent energy fluxes as well as the water vapor flux (in units of m^3/m^2/s of water). Positive fluxes indicate flow from the ground to the atmosphere.\n\nIt solves for these given atmospheric conditions, stored in atmos, model parameters, and the surface conditions.\n\n\n\n\n\nturbulent_fluxes(atmos::CoupledAtmosphere,\n                model::AbstractModel,\n                Y,\n                p,\n                t)\n\nComputes the turbulent surface fluxes terms at the ground for a coupled simulation.\n\n\n\n\n\nfunction ClimaLand.turbulent_fluxes(\n    atmos::PrescribedAtmosphere,\n    model::CanopyModel,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nA canopy specific function for compute turbulent fluxes with the atmosphere; returns the latent heat flux, sensible heat flux, vapor flux, and aerodynamic resistance.\n\nWe cannot use the default version in src/shared_utilities/drivers.jl because the canopy requires a different resistance for vapor and sensible heat fluxes, and the resistances depend on ustar, which we must compute using SurfaceFluxes before adjusting to account for these resistances.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.turbulent_fluxes_at_a_point","page":"Shared Utilities","title":"ClimaLand.turbulent_fluxes_at_a_point","text":"turbulent_fluxes_at_a_point(T_sfc::FT,\n                            q_sfc::FT,\n                            ρ_sfc::FT,\n                            β_sfc::FT,\n                            h_sfc::FT,\n                            r_sfc::FT,\n                            d_sfc::FT,\n                            ts_in,\n                            u::FT,\n                            h::FT,\n                            gustiness::FT,\n                            z_0m::FT,\n                            z_0b::FT,\n                            earth_param_set::EP,\n                           ) where {FT <: AbstractFloat, P}\n\nComputes turbulent surface fluxes at a point on a surface given (1) the surface temperature (Tsfc), specific humidity (qsfc),     and air density (ρsfc), (2) Other surface properties, such as the factor     βsfc  which scales the evaporation from the potential rate     (used in bucket models), and the surface resistance rsfc (used     in more complex land models), and the topographical height of the surface (hsfc) (3) the roughness lengths z_0m, z_0b, and the Earth parameter set for the model     earth_params. (4) the prescribed atmospheric state, ts_in, u, h the height     at which these measurements are made, and the gustiness parameter (m/s). (5) the displacement height for the model d_sfc\n\nThis returns an energy flux and a liquid water volume flux, stored in a tuple with self explanatory keys.\n\nPlease note that this function, if rsfc is set to zero, makes no alteration to the output of the `SurfaceFluxes.surfaceconditions` call, aside from unit conversion of evaporation from a mass to a liquid water volume flux. When r_sfc is nonzero, an additional resistance is applied in series to the vapor flux (and hence also the latent heat flux).\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.set_atmos_ts!","page":"Shared Utilities","title":"ClimaLand.set_atmos_ts!","text":"set_atmos_ts!(ts_in, atmos::PrescribedAtmosphere{FT}, p)\n\nFill the pre-allocated ts_in Field with a thermodynamic state computed from the atmosphere.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.surface_air_density","page":"Shared Utilities","title":"ClimaLand.surface_air_density","text":"surface_air_density(\n                    atmos::PrescribedAtmosphere,\n                    model::AbstractModel,\n                    Y,\n                    p,\n                    t,\n                    T_sfc,\n                    )\n\nA helper function which returns the surface air density; this assumes that the model has a property called parameters containing earth_param_set.\n\nWe additionally include the atmos type as an argument because the surface air density computation will change between a coupled simulation and a prescibed atmos simulation.\n\nExtending this function for your model is only necessary if you need to compute the air density in a different way.\n\n\n\n\n\nClimaLand.surface_air_density(\n                atmos::CoupledAtmosphere,\n                model::AbstractModel,\n                Y,\n                p,\n                _...,\n            )\n\nReturns the air density at the surface in the case of a coupled simulation.\n\nThis requires the field ρ_sfc to be present in the cache p under the name of the model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.surface_temperature","page":"Shared Utilities","title":"ClimaLand.surface_temperature","text":"ClimaLand.surface_temperature(\n    model::EnergyHydrology{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nReturns the surface temperature field of the EnergyHydrology soil model.\n\nThe assumption is that the soil surface temperature is the same as the temperature at the center of the first soil layer.\n\n\n\n\n\nClimaLand.surface_temperature(model::SnowModel, Y, p)\n\na helper function which returns the surface temperature for the snow  model, which is stored in the aux state.\n\n\n\n\n\nClimaLand.surface_temperature(model::BucketModel, Y, p)\n\na helper function which returns the surface temperature for the bucket model, which is stored in the aux state.\n\n\n\n\n\nsurface_temperature(model::AbstractModel, Y, p, t)\n\nA helper function which returns the surface temperature for a given model, needed because different models compute and store surface temperature in different ways and places.\n\nExtending this function for your model is only necessary if you need to compute surface fluxes and radiative fluxes at the surface using the functions in this file.\n\n\n\n\n\nClimaLand.surface_temperature(model::CanopyModel, Y, p, t)\n\nA helper function which returns the temperature for the canopy model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.surface_resistance","page":"Shared Utilities","title":"ClimaLand.surface_resistance","text":"surface_resistance(model::AbstractModel, Y, p, t)\n\nA helper function which returns the surface resistance for a given model, needed because different models compute and store surface resistance in different ways and places.\n\nExtending this function for your model is only necessary if you need to compute surface fluxes and radiative fluxes at the surface using the functions in this file.\n\nThe default is 0, which is no additional resistance aside from the usual aerodynamic resistance from MOST.\n\n\n\n\n\nClimaLand.surface_resistance(\n    model::CanopyModel{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nReturns the stomatal resistance field of the CanopyModel canopy.\n\n\n\n\n\n","category":"function"},{"location":"APIs/shared_utilities/#ClimaLand.surface_specific_humidity","page":"Shared Utilities","title":"ClimaLand.surface_specific_humidity","text":"ClimaLand.surface_specific_humidity(model::BucketModel, Y, p)\n\nComputes and returns the specific humidity over snow as a weighted fraction of the saturated specific humidity over liquid and frozen water.\n\n\n\n\n\nClimaLand.surface_specific_humidity(model::BucketModel, Y, p)\n\na helper function which returns the surface specific humidity for the bucket model, which is stored in the aux state.\n\n\n\n\n\nsurface_specific_humidity(model::AbstractModel, Y, p, T_sfc, ρ_sfc)\n\nA helper function which returns the surface specific humidity for a given model, needed because different models compute and store q_sfc in different ways and places.\n\nExtending this function for your model is only necessary if you need to compute surface fluxes and radiative fluxes at the surface using the functions in this file.\n\n\n\n\n\n","category":"function"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/#Farquhar-Model","page":"Farquhar model","title":"Farquhar Model","text":"","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"This section breaks down the Farquhar model that describes the biochemical process of photosynthesis in plants as environmental conditions change.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"The biochemical processes within a leaf determine the rate of photosynthesis, particularly the diffusion of CO_2 into the leaf, the assimilation of CO_2 during photosynthesis, and the transpiration of water vapor. It takes into account factors such as light intensity, temperature, and CO_2 concentration to estimate the rate at which plants convert light energy into chemical energy through photosynthesis.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"The net assimilation by a leaf (An) is calculated based on the biochemistry of C3 and C4 photosynthesis to determine potential (unstressed by water availability) leaf-level photosynthesis. This is calculated in terms of two potentially-limiting rates:","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"An vs. air Temperature (T, °C) and Photosynthetically Active Radiation (PAR, μmol m⁻² s⁻¹)","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"<iframe src=\"https://clima.westus3.cloudapp.azure.com/jsserve/leaf_An\"\n   style=\"height:1200px;width:90%;\">\n</iframe>","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"An vs. air Temperature (T, °C) and intra-cellular CO2 (ci, ppm)","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"<iframe src=\"https://clima.westus3.cloudapp.azure.com/jsserve/leaf_An_ci\"\n   style=\"height:1400px;width:100%;\">\n</iframe>","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/#Rubisco-limited-rate","page":"Farquhar model","title":"Rubisco limited rate","text":"","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"beginequation\na_1(T c_a VPD) =\nbegincases\n      V_cmax(T)  frac(c_i(T c_a VPD) - Gamma^*(T))(c_i(T c_a VPD) + K_c(T)*(1+o_iK_o(T)))  textfor C3\n      V_cmax(T)  textfor C4\nendcases\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"The dependence on the atmospheric CO_2 concentration c_a (mol/mol) and vapor pressure deficit VPD arise in the expression for c_i,","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"beginalign\n    c_i(T c_a VPD) = max(c_a(1-1m(VPD)) Gamma^*(T))\nendalign","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"where and m is the Medlyn factor (see Stomatal Conductance).","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"We also have","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"    Gamma^*(T) = Gamma^*_25expleft(Delta H_Gamma^*fracT - T_oT_o R Tright)","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"where Delta H_Gamma^* is the activation energy per mol for Gamma^*.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/#Light-limited-rate","page":"Farquhar model","title":"Light limited rate","text":"","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"beginequation\na_2 =\nbegincases\n      J(T PAR) (c_i - Gamma^*)4(c_i + 2  Gamma^*)  textfor C3\n      J(T PAR)  textfor C4\nendcases       \nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"where J is the rate of electron transport, which has units of mol photon per m^2 per s. It depends on PAR via APAR, as described below, and on T via the dependence on J_max.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"J is given by the root of the equation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"beginalign\n    theta_j J^2 - (I + J_max) J + I J_max = 0 nonumber \n    I = fracphi2 (APAR) nonumber \n    J_max(T) = V_cmax(T)times e expleft(Delta H_J_maxfracT - T_oT_o R Tright)nonumber \nJ(T PAR) = frac(I + J_max - sqrt(I + J_max)^2 - 4theta_j I times J_max2theta_j\nendalign","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"where phi = 06 and theta_j = 09 are the quantum yield of photosystem II and a curvature function (Bonan's book), and Delta H_J_max is the energy of activation of J_max.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"The total net carbon assimilation (A_n, mol CO_2 m^-2 s^-1) is given by the weighted sum of C3 and C4 net carbon assimilation fractions following:","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"beginalign\nA_n(T PAR VPD c_a) = textmax(0 textmin(a_1 beta a_2) - R_d)\nendalign","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"where beta is the moisture stress factor which is related to the mean soil moisture concentration in the root zone and R_d is the leaf dark respiration calculated as ","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"beginalign\n    R_d25(psi_l) = f V_cmax25beta(psi_l) nonumber \n    R_d (T psi_l)  = R_d25(psi_l)expleft(Delta H_R_dfracT - T_oT_o R Tright)\nendalign","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"where f = 0015 is a constant, Delta H_R_d is the energy of activation for R_d, and finally  Vcmax is calculated as ","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"beginequation\nV_cmax(T) = V_cmax25 expleft(Delta H_VcmaxfracT - T_oT_o R Tright)\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"with V_cmax25 is a parameter (Vcmax at the reference temperature 25 C), and Delta H_Vcmax = 65330 Jmol.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"The moisture stress factor is related to the leaf water potential psi_l as","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"beginalign\n    beta = frac1+ exp(s_c psi_c)1+ exp(s_c(psi_c - psi_l))\nendalign","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"where s_c = 4MPa^-1, psi_c = -2MPa, and psi_l is the leaf water potential computed by the plant hydraulics model.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"GPP is the total canopy photosynthesis calculated as the integral of leaf-level photosynthesis over the entire canopy leaf area index:","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"beginalign\nGPP(T PAR c_a VPD theta_s) = A_n  (1 - exp(-K LAI Omega))K\nendalign","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"This is not currently needed by other components, but is used for offline validation of the model.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"We need to supply the following parameters and “drivers\"","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"K_c25 and K_o25, V_cmax 25, Gamma^*_25phi, theta_j, o_i, s_c, psi_c\npsi_l, to compute beta\nTemperature T, PAR, c_a, VPD, theta_s.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"Output Symbol Unit Range\nTotal net carbon assimilation A_n μmol CO_2 m^-2 s^-1 0–25","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"Drivers Symbol Unit Range\nPhotosynthetically Active Radiation PAR μmol m⁻² s⁻¹ 0–1500\nTemperature T °C 0–50","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"Parameters Symbol Unit Range\nMoisture stress β - 0-1\nLeaf Area Index LAI m² m⁻² 1–10\nCO_2 concentration c_a ppm 300e–500\nVapor pressure deficit VPD kPa 1-10","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/farquhar_model/","page":"Farquhar model","title":"Farquhar model","text":"Constants Symbol Unit Value\nZenith angle θ_s rad 0.6\nLeaf angle distribution l_d - 0.5\nCanopy reflectance ρ_leaf - 0.1\nClumping index Ω - 0.69\nCO_2 compensation at 25°C Γ^*_25 mol/mol 4.275e-5\nEnergy of activation for Γ^* ΔH_Γ^* J/mol 37830\nStandard temperature T_o K 298.15\nUniversal gas constant R J/mol 8.314\nThe maximum rate of carboxylation of Rubisco V_cmax25 mol CO_2 m^-2 s^-1 5e-5\nEnergy of activation for J_max ΔH_J_max J/mol 43540\nCurvature parameter, a fitting constant to compute J θ_j - 0.9\nThe quantum yied of photosystem II phi - 0.6\nEnergy of activation for V_cmax ΔH_V_cmax J/mol 58520\nSlope parameter for stomatal conductance models g_1 - 141\nMichaelis Menten constant for CO_2 and at 25\u000e°C K_c25 mol/mol 4.049e-4\nEnergy of activation for CO_2 ΔH_K_c J/mol 79430\nMichaelis Menten constant for O_2 at 25 °C\u000e K_o25 mmol/mol 0.2874\nEnergy of activation for O_2 ΔH_K_o J/mol 36380\nIntercellular O_2 concentration o_i mol/mol 0.209\nConstant factor appearing the dark respiration term\u000e f - 0.015\nEnergy of activation for R_d ΔH_R_d J/mol 43390","category":"page"},{"location":"APIs/SoilBiogeochemistry/#Soil-Biogeochemistry","page":"Soil Biogeochemistry","title":"Soil Biogeochemistry","text":"","category":"section"},{"location":"APIs/SoilBiogeochemistry/","page":"Soil Biogeochemistry","title":"Soil Biogeochemistry","text":"CurrentModule = ClimaLand.Soil.Biogeochemistry","category":"page"},{"location":"APIs/SoilBiogeochemistry/#Model-Structure","page":"Soil Biogeochemistry","title":"Model Structure","text":"","category":"section"},{"location":"APIs/SoilBiogeochemistry/","page":"Soil Biogeochemistry","title":"Soil Biogeochemistry","text":"ClimaLand.Soil.Biogeochemistry.SoilCO2Model","category":"page"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilCO2Model","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilCO2Model","text":"SoilCO2Model\n\nA model for simulating the production and transport of CO₂ in the soil with dynamic source and diffusion terms.\n\nparameters: the parameter set\ndomain: the soil domain, using ClimaCore.Domains\nboundary_conditions: the boundary conditions, of type NamedTuple\nsources: A tuple of sources, each of type AbstractSource\ndrivers: Drivers\n\n\n\n\n\n","category":"type"},{"location":"APIs/SoilBiogeochemistry/#Parameter-Structure","page":"Soil Biogeochemistry","title":"Parameter Structure","text":"","category":"section"},{"location":"APIs/SoilBiogeochemistry/","page":"Soil Biogeochemistry","title":"Soil Biogeochemistry","text":"ClimaLand.Soil.Biogeochemistry.SoilCO2ModelParameters","category":"page"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilCO2ModelParameters","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilCO2ModelParameters","text":"SoilCO2ModelParameters{FT <: AbstractFloat, PSE}\n\nA struct for storing parameters of the SoilCO2Model.\n\nAll of these parameters are currently treated as global constants.\n\nD_ref: Diffusion coefficient for CO₂ in air at standard temperature and pressure (m² s⁻¹)\nD_liq: Diffusivity of soil C substrate in liquid (unitless)\nα_sx: Pre-exponential factor (kg C m-3 s-1)\nEa_sx: Activation energy (J mol-1)\nkM_sx: Michaelis constant (kg C m-3)\nkM_o2: Michaelis constant for O2 (m3 m-3)\nO2_a: Volumetric fraction of O₂ in the soil air, dimensionless\nD_oa: Diffusion coefficient of oxygen in air, dimensionless\np_sx: Fraction of soil carbon that is considered soluble, dimensionless\nearth_param_set: Physical constants used Clima-wide\n\n\n\n\n\n","category":"type"},{"location":"APIs/SoilBiogeochemistry/#Model-specific-Types","page":"Soil Biogeochemistry","title":"Model-specific Types","text":"","category":"section"},{"location":"APIs/SoilBiogeochemistry/","page":"Soil Biogeochemistry","title":"Soil Biogeochemistry","text":"ClimaLand.Soil.Biogeochemistry.MicrobeProduction\nClimaLand.Soil.Biogeochemistry.SoilCO2FluxBC\nClimaLand.Soil.Biogeochemistry.SoilCO2StateBC\nClimaLand.Soil.Biogeochemistry.AtmosCO2StateBC\nClimaLand.Soil.Biogeochemistry.AbstractSoilDriver\nClimaLand.Soil.Biogeochemistry.SoilDrivers\nClimaLand.Soil.Biogeochemistry.PrescribedMet","category":"page"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.MicrobeProduction","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.MicrobeProduction","text":"MicrobeProduction{FT} <: AbstractCarbonSource{FT}\n\nStruct for the microbe production of CO2, appearing as a source term in the differential equation.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilCO2FluxBC","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilCO2FluxBC","text":"SoilCO2FluxBC <: ClimaLand.AbstractBC\n\nA container holding the CO2 flux boundary condition, which is a function f(p,t), where p is the auxiliary state vector.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilCO2StateBC","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilCO2StateBC","text":"SoilCO2StateBC <: ClimaLand.AbstractBC\n\nA container holding the CO2 state boundary condition (kg CO2 m−3), which is a function f(p,t), where p is the auxiliary state vector.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.AtmosCO2StateBC","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.AtmosCO2StateBC","text":"AtmosCO2StateBC <: ClimaLand.AbstractBC\n\nSet the CO2 concentration to the atmospheric one.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.AbstractSoilDriver","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.AbstractSoilDriver","text":"AbstractSoilDriver\n\nAn abstract type for drivers of soil CO2 production and diffusion. These are soil temperature, soil moisture, root carbon, soil organic matter and microbe carbon, and atmospheric pressure. Soil temperature and moisture, as well as soc, vary in space (horizontally and vertically) and time. Atmospheric pressure vary in time (defined at the surface only, not with depth).\n\n\n\n\n\n","category":"type"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.SoilDrivers","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.SoilDrivers","text":"SoilDrivers\n\nA container which passes in the soil drivers to the biogeochemistry model. These drivers are either of type Prescribed (for standalone mode) or Prognostic (for running with a prognostic model for soil temp and moisture).\n\nmet: Soil temperature and moisture drivers - Prescribed or Prognostic\nsoc: Soil SOM driver - Prescribed only\natmos: Prescribed atmospheric variables\n\n\n\n\n\n","category":"type"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.PrescribedMet","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.PrescribedMet","text":"PrescribedMet <: AbstractSoilDriver\n\nA container which holds the prescribed functions for soil temperature and moisture.\n\nThis is meant for use when running the biogeochemistry model in standalone mode, without a prognostic soil model.\n\ntemperature: The temperature of the soil, of the form f(z::FT,t) where FT <: AbstractFloat\nvolumetric_liquid_fraction: Soil moisture, of the form f(z::FT,t) FT <: AbstractFloat\nν: Soil porosity (m³ m⁻³)\nθ_a100: Air-filled porosity at soil water potential of -100 cm H₂O (~ 10 Pa)\nb: Absolute value of the slope of the line relating log(ψ) versus log(S) (unitless)\n\n\n\n\n\n","category":"type"},{"location":"APIs/SoilBiogeochemistry/#Functions-of-State","page":"Soil Biogeochemistry","title":"Functions of State","text":"","category":"section"},{"location":"APIs/SoilBiogeochemistry/","page":"Soil Biogeochemistry","title":"Soil Biogeochemistry","text":"ClimaLand.Soil.Biogeochemistry.volumetric_air_content\nClimaLand.Soil.Biogeochemistry.co2_diffusivity\nClimaLand.Soil.Biogeochemistry.microbe_source","category":"page"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.volumetric_air_content","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.volumetric_air_content","text":"volumetric_air_content(θ_w::FT,\n                       ν::FT,\n                       ) where {FT}\n\nComputes the volumetric air content (θ_a) in the soil, which is related to the total soil porosity (ν) and volumetric soil water content (θ_w = θ_l+θ_i).\n\n\n\n\n\n","category":"function"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.co2_diffusivity","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.co2_diffusivity","text":"co2_diffusivity(\n                T_soil::FT,\n                θ_w::FT,\n                P_sfc::FT,\n                θ_a100::FT,\n                b::FT,\n                ν::FT,\n                params::SoilCO2ModelParameters{FT},\n                ) where {FT}\n\nComputes the diffusivity of CO₂ within the soil (D).\n\nFirst, D0 is computed using the temperature within the soil (T_soil in K) and pressure at the surface of the soil (P_sfc in Pa), using reference values of T_ref and P_ref (273 K and 101325 Pa). Here, θ_a is the volumetric air content and θ_a100 is the volumetric air content at a soil water potential of 100cm, and b is the pore size distribution of the soil.\n\nThis parameterization is from Ryan et al., GMD 11, 1909-1928, 2018, https://doi.org/10.5194/gmd-11-1909-2018.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.microbe_source","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.microbe_source","text":"microbe_source(T_soil::FT,\n               θ_l::FT,\n               Csom::FT,\n               ν::FT,\n               params::SoilCO2ModelParameters{FT}\n               ) where {FT}\n\nComputes the CO₂ production in the soil by microbes, in depth and time (kg C / m^3/s), using the Dual Arrhenius Michaelis Menten model (Davidson et al., 2012).\n\n\n\n\n\n","category":"function"},{"location":"APIs/SoilBiogeochemistry/#Extendible-Functions","page":"Soil Biogeochemistry","title":"Extendible Functions","text":"","category":"section"},{"location":"APIs/SoilBiogeochemistry/","page":"Soil Biogeochemistry","title":"Soil Biogeochemistry","text":"ClimaLand.Soil.Biogeochemistry.soil_moisture\nClimaLand.Soil.Biogeochemistry.soil_temperature\nClimaLand.Soil.Biogeochemistry.soil_SOM_C","category":"page"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.soil_moisture","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.soil_moisture","text":"soil_moisture(driver::PrognosticSoil, p, Y, t, z)\n\nReturns the volumetric liquid fraction, computed by the soil model from the prognostic liquid and ice fractions.\n\n\n\n\n\nsoil_moisture(driver::PrescribedMet, p, Y, t, z)\n\nReturns the soil moisture at location (z) and time (t) for the prescribed soil case.\n\n\n\n\n\n","category":"function"},{"location":"APIs/SoilBiogeochemistry/#ClimaLand.Soil.Biogeochemistry.soil_temperature","page":"Soil Biogeochemistry","title":"ClimaLand.Soil.Biogeochemistry.soil_temperature","text":"soil_temperature(driver::PrognosticSoil, p, Y, t, z)\n\nReturns the prognostic soil temperature.\n\n\n\n\n\nsoil_temperature(driver::PrescribedMet, p, Y, t, z)\n\nReturns the soil temperature at location (z) and time (t) for the prescribed soil case.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/users_diagnostics/#Using-ClimaLand-Diagnostics-when-running-a-simulation","page":"For users","title":"Using ClimaLand Diagnostics when running a simulation","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"When running a ClimaLand simulations, you have multiple options on how to write the outputs of that simulation. You may want all variables, or just a selected few. You may want instantaneous values, at the highest temporal and spatial resolution, or you may want to get averages at hourly or monthly time scale, and integrate in space (for example soil moisture from 0 to 1 meter depth). You may want to get more specific reductions, such as 10 days maximums, or compute a new variables that is a function of others. You may want to get your outputs in memory in a Julia Dict, or write them in a NetCDF file.","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"This is where ClimaLand Diagnostics comes in for users.","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"In this documentation page, we first explain how to use default diagnostics and what are the defaults, and then explain how to define your own diagnostics for more advanced users.","category":"page"},{"location":"diagnostics/users_diagnostics/#Default-Diagnostics","page":"For users","title":"Default Diagnostics","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Once you have defined your model and are ready to run a simulation, and after adding ClimaDiagnostics (using ClimaDiagnostics),  you can add default diagnostics to it by doing the following steps:","category":"page"},{"location":"diagnostics/users_diagnostics/#define-an-output-folder","page":"For users","title":"define an output folder","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"output_dir = ClimaUtilities.OutputPathGenerator.generate_output_path(\"base_output_dir/\")","category":"page"},{"location":"diagnostics/users_diagnostics/#define-a-space","page":"For users","title":"define a space","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Your diagnostics will be written in time and space. These may be defined in your model, but usually land model space is a sphere with no vertical dimension. You may have variables varying with soil depth, and so you will need:","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"space = bucket_domain.space.subsurface","category":"page"},{"location":"diagnostics/users_diagnostics/#define-your-writter","page":"For users","title":"define your writter","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Your diagnostics will be written in a Julia Dict or a netcdf file, for example. This is up to you. For a netcdf file, you define your writter like this:","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"nc_writer = ClimaDiagnostics.Writers.NetCDFWriter(space, output_dir)","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"providing the space and output_dir defined in steps 1. and 2.","category":"page"},{"location":"diagnostics/users_diagnostics/#make-your-diagnostics-on-your-model,-using-your-writter,-and-define-a-callback","page":"For users","title":"make your diagnostics on your model, using your writter, and define a callback","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Now that you defined your model and your writter, you can create a callback function to be called when solving your model. For example:","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"t0 = 0 # the start date of your simulation\n\nstart_date = DateTime(2024) # start_date is the DateTime of your start date\n\ndiags = ClimaLand.default_diagnostics(model, start_date; output_writer = nc_writer)\n\ndiagnostic_handler =\n    ClimaDiagnostics.DiagnosticsHandler(diags, Y, p, t0; dt = Δt)\n\ndiag_cb = ClimaDiagnostics.DiagnosticsCallback(diagnostic_handler)\n\nsol = SciMLBase.solve(prob, ode_algo; dt = Δt, callback = diag_cb)","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Your diagnostics have now been written in netcdf files in your output folder.","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Note that by default, default_diagnostics assign two optional kwargs: output_vars = :long and average_period = :daily. output_vars = :long will write all available diagnostics, whereas output_vars = :short will only write essentials diagnostics. average_period defines the period over which diagnostics are averaged, it can be set to :hourly, :daily and :monthly.","category":"page"},{"location":"diagnostics/users_diagnostics/#Custom-Diagnostics","page":"For users","title":"Custom Diagnostics","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"When defining a custom diagnostic, follow these steps:","category":"page"},{"location":"diagnostics/users_diagnostics/#Define-how-to-compute-your-diagnostic-variable-from-your-model-state-and-cache.","page":"For users","title":"Define how to compute your diagnostic variable from your model state and cache.","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"For example, let's say you want the bowen ratio (ratio between sensible heat and latent heat) in the Bucket model.","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"function compute_bowen_ratio!(out, Y, p, t, land_model::BucketModel)\n    if isnothing(out)\n        return copy(p.bucket.turbulent_fluxes.shf / p.bucket.turbulent_fluxes.lhf)\n    else\n        out .= p.bucket.turbulent_fluxes.shf / p.bucket.turbulent_fluxes.lhf\n    end\nend","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Or, for convenience, you can use the @diagnostic_compute macro which generates the same function. However, it is better to use that macro only if you are getting a defined variable, such as latent heat flux. (without an operation like the bowen ratio above). For example,","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"@diagnostic_compute \"latent_heat_flux\" BucketModel p.bucket.turbulent_fluxes.lhf","category":"page"},{"location":"diagnostics/users_diagnostics/#Add-that-diagnostic(s)-variable-to-your-list-of-variables","page":"For users","title":"Add that diagnostic(s) variable to your list of variables","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":" add_diagnostic_variable!(\n    short_name = \"bor\",\n    long_name = \"Bowen ratio\",\n    standard_name = \"bowen_ratio\",\n    units = \"\",\n    comments = \"Ratio of sensible to latent heat flux.\",\n    compute! = (out, Y, p, t) -> compute_bowen_ratio!(out, Y, p, t, land_model),\n)\n\nadd_diagnostic_variable!(\n    short_name = \"lhf\",\n    long_name = \"Latent Heat Flux\",\n    standard_name = \"latent_heat_flux\",\n    units = \"W m^-2\",\n    comments = \"Exchange of energy at the land-atmosphere interface due to water evaporation or sublimation.\",\n    compute! = (out, Y, p, t) ->\n    compute_latent_heat_flux!(out, Y, p, t, land_model),\n)","category":"page"},{"location":"diagnostics/users_diagnostics/#Define-how-to-schedule-your-variables.-For-example,-you-want-the-seasonal-maximum-of-your-variables,-where-season-is-defined-as-90-days.","page":"For users","title":"Define how to schedule your variables. For example, you want the seasonal maximum of your variables, where season is defined as 90 days.","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"seasonal_maxs(FT, short_names...; output_writer) = common_diagnostics(\n    90 * 24 * 60 * 60 * one(FT),\n    max,\n    output_writer,\n    short_names...,\n)","category":"page"},{"location":"diagnostics/users_diagnostics/#Define-a-function-to-return-your-ScheduledDiagnostics","page":"For users","title":"Define a function to return your ScheduledDiagnostics","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Now, you can call your schedule with your variables.","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"my_custom_diagnostics = [\"lhf\", \"bor\"]\n\ndiags = seasonal_maxs(FT, my_custom_diagnostics...; output_writer)","category":"page"},{"location":"diagnostics/users_diagnostics/#Analyze-your-simulation-output","page":"For users","title":"Analyze your simulation output","text":"","category":"section"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Once you've run your simulation and created an output folder (e.g., output_dir) with diagnostics, you can use ClimaAnalysis to access and analyze your data. For in depth documentation about ClimaAnalysis, see its documentation.","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"Here is an example of how to plot a variable:","category":"page"},{"location":"diagnostics/users_diagnostics/","page":"For users","title":"For users","text":"import ClimaAnalysis\n\nimport ClimaAnalysis.Visualize as viz\n\nimport CairoMakie # the plotting package used by ClimaAnalysis\n\nsimdir = ClimaAnalysis.SimDir(output_dir) # where output_dir is where you saved your diagnostics.\n\nvar = get(simdir; \"lhf\") # assuming lhf, latent_heat_flux used as an example above, is one of your diagnostics variables.\n\nfig = CairoMakie.Figure() # creates an empty figure object\n\nviz.plot!(fig, var) # creates an axis inside fig, and plot your var in it.\n\nCairoMakie.save(fig) # saves the figure in current working directory","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/#Optimality-Model","page":"Optimality model","title":"Optimality Model","text":"","category":"section"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"Photosynthetic coordination theory, originally proposed by Von Caemmerer & Farquhar (1981), provides an approach to predict dynamic responses of photosynthetic capacity to environmental constraints. It primarily focuses on how leaf nitrogen (N) affects the photosynthetic capacity. Photosynthetic capacity varies both among plant types and over time and space, and a major determinant of photosynthetic capacity is the maximum rate of Rubisco carboxylation (V_textcmax). ","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"In this optimality model, Smith et al. (2019) assumes that plants are able to acquire the N necessary to build leaves that can photosynthesize at the fastest possible rate given light availability and biophysical constraints. The Vcmax model estimates V_textcmax and J_textmax as a function of environmental variables as follows:","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    V_textcmax^* = varphi I left(fracmm_cright)left(fracoverlineomega^*8thetaright)\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"where","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    overlineomega^* = 1 + overlineomega - sqrt(1 + overlineomega)^2 - 4thetaoverlineomega\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"and","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    overlineomega = -(1 - 2theta) + sqrt(1 - theta)left(frac1frac4cmleft(1 - thetafrac4cmright) - 4thetaright)\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"and","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    c = fracm8thetaleft(1 - fracvarphi I + J_textmax - 2thetavarphi Isqrt(varphi I + J_textmax)^2 - 4thetavarphi I J_textmaxright)\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"and","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    J_textmax = varphi I overlineomega\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    m = fracC_i - Gamma^*C_i + 2Gamma^*\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    C_i = Gamma^* + (C_a - Gamma^*)fracxixi + sqrtD_g\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    xi = sqrtbeta fracK + Gamma^*16eta^*\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    K = K_cleft(1 + fracO_iK_oright)\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    m_c = fracC_i - Gamma^*C_i + K\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"Gamma^*","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"is the CO_2 compensation point in the absence of mitochondrial respiration","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"beginequation\n    Gamma^* = Gamma^*_0 f(T Delta H_a) pp_0\nendequation","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"where Gamma^*_0 = 4332 Pa, p is the atmospheric pressure, p_0 = 101325 Pa, and Delta H_a = 37830 J/mol.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"The model has the following parameters:","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"varphi is the realized quantum yield of photosynthetic electron transport (dimensionless). Estimated at 0.257.\ntheta is the curvature of the light response curve (dimensionless). Estimated at 0.85.\nbeta is the ratio of the carbon cost of maintaining photosynthetic proteins to the carbon cost of maintaining a transpiration stream (dimensionless). Estimated at 146.","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"For Smith et al. (2019) Vcmax model:","category":"page"},{"location":"standalone/pages/vegetation/photosynthesis/optimality_model/","page":"Optimality model","title":"Optimality model","text":"Altitude\nD_g is the vapor pressure deficit (VPD) at altitude\nC_a is the CO_2 partial pressure\nI is the incident photosynthetically active photon flux (PAR)\nT is the temperature","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/#Introduction-to-the-Canopy-Model","page":"Standalone Canopy","title":"Introduction to the Canopy Model","text":"","category":"section"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"This tutorial shows how to instantiate and run a simulation of the canopy biophysics model in ClimaLand. A CanopyModel including all component models is initialized, then an example simulation is run. The initial conditions, atmospheric and radiative flux conditions, and canopy properties are set up to match those observed at the US-MOz flux tower, a flux tower located within an oak-hickory forest in Ozark, Missouri, USA. See Wang et al. 2021 for details on the site and canopy parameters.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"The canopy biophysics model in ClimaLand combines a photosynthesis model with a canopy radiative transfer scheme, plant hydraulics model, and stomatal conductance model, placing them under either prescribed or simulated (as in a full Earth System Model) atmospheric and radiative flux conditions.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"ClimaLand supports either Beer-Lambert law or a Two-Stream model for radiative transfer. For this tutorial, we will use the Beer-Lambert law, in which the intensity of light absorbed is a negative exponential function of depth in the canopy and an exinction coefficient determined by optical depth.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"The model of photosynthesis in Clima Land is the Farquar Model in which GPP is calculated based on C3 and C4 photosynthesis, which determines potential leaf-level photosynthesis.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"The plant hydraulics model in ClimaLand solves for the water content within bulk root-stem-canopy system using Richards equation discretized into an arbitrary number of layers. The water content is related to the water potential using a retention curve relationship, and the water potential is used to simulate the effect moisture stress has on transpiration and GPP.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/#Preliminary-Setup","page":"Standalone Canopy","title":"Preliminary Setup","text":"","category":"section"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Load External Packages:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"import SciMLBase\nusing Plots\nusing Statistics\nusing Dates\nusing Insolation","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Load CliMA Packages and ClimaLand Modules:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"using ClimaCore\nimport ClimaParams as CP\nimport ClimaTimeSteppers as CTS\nusing StaticArrays\nusing ClimaLand\nusing ClimaLand.Domains: Point\nusing ClimaLand.Canopy\nusing ClimaLand.Canopy.PlantHydraulics\nimport ClimaLand\nimport ClimaLand.Parameters as LP","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Define the floating point precision desired (64 or 32 bit), and get the parameter set holding constants used across CliMA Models:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"const FT = Float32;\nearth_param_set = LP.LandParameters(FT);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/#Setup-the-Canopy-Model","page":"Standalone Canopy","title":"Setup the Canopy Model","text":"","category":"section"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"We want to simulate a vegetative canopy in standalone mode, without coupling the canopy to atmospheric or soil physics models, so we choose a CanopyModel. From the linked documentation, we can see that we need to provide shared parameters, a domain, a radiative transfer model, photosynthesis model, plant hydraulics model, stomatal conductance model, and atmospheric and radiative flux conditions which may be either prescribed or simulated.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"First, define the parameters of the model domain. These values are needed by some of the component models. Here we are performing a 1-dimensional simulation in a Point domain and will use single stem and leaf compartments, but for 2D simulations, the parameters of the domain would change.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"nelements = 10\nzmin = FT(-2)\nzmax = FT(0)\nf_root_to_shoot = FT(3.5)\nSAI = FT(0.00242)\nmaxLAI = FT(4.2)\nplant_ν = FT(2.46e-4) # kg/m^2\nn_stem = Int64(1)\nn_leaf = Int64(1)\nh_stem = FT(9)\nh_leaf = FT(9.5)\ncompartment_midpoints = [h_stem / 2, h_stem + h_leaf / 2]\ncompartment_surfaces = [zmax, h_stem, h_stem + h_leaf]\nland_domain = Point(; z_sfc = FT(0.0))","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"ClimaLand.Domains.Point{Float32}(0.0f0, (surface = ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, Vector{Float32}}}(ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}(ClimaComms.CPUSingleThreaded()), ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, Vector{Float32}}\n  Float32[0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]),))","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"We will be using prescribed atmospheric and radiative drivers from the US-MOz tower, which we read in here. We are using prescribed atmospheric and radiative flux conditions, but it is also possible to couple the simulation with atmospheric and radiative flux models. We also","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"read in the observed LAI and let that vary in time in a prescribed manner.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Use the data tools for reading FLUXNET data sets","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"include(\n    joinpath(pkgdir(ClimaLand), \"experiments/integrated/fluxnet/data_tools.jl\"),\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"First provide some information about the site Timezone (offset from UTC in hrs)","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"time_offset = 7","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"7","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Site latitude and longitude","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"lat = FT(38.7441) # degree\nlong = FT(-92.2000) # degree","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"-92.2f0","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Height of the sensor at the site","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"atmos_h = FT(32)","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"32.0f0","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Provide the site site ID and the path to the data file:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"site_ID = \"US-MOz\"\ndata_link = \"https://caltech.box.com/shared/static/7r0ci9pacsnwyo0o9c25mhhcjhsu6d72.csv\"\n\ninclude(\n    joinpath(\n        pkgdir(ClimaLand),\n        \"experiments/integrated/fluxnet/met_drivers_FLUXNET.jl\",\n    ),\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"[ Info: Warning: Data for TA_F 0.719% poor quality. Returning with no replacement.\n[ Info: Warning: Data for VPD_F 0.719% poor quality. Returning with no replacement.\n[ Info: Warning: Data for PA_F 0.00571% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for P_F 0.0% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for WS_F 0.00571% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for LW_IN_F 0.0% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for SW_IN_F 0.0114% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for G_F_MDS 0.00571% poor quality. Filled with mean value using QC flag\n[ Info: Information: Data for GPP_DT_VUT_REF is complete and no QC flag present\n[ Info: Information: Data for LE_CORR is complete and no QC flag present\n[ Info: Information: Data for H_CORR is complete and no QC flag present\n[ Info: Warning: Data for LW_OUT 0.00571% has value of -9999. Filled with mean value\n[ Info: Warning: Data for SW_OUT 0.131% has value of -9999. Filled with mean value\n[ Info: Warning: Data for SWC_F_MDS_1 0.0571% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for TS_F_MDS_1 0.0% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for CO2_F_MDS 0.0457% poor quality. Filled with mean value using QC flag\n","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Populate the SharedCanopyParameters struct, which holds the parameters shared between all different components of the canopy model.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"z0_m = FT(2)\nz0_b = FT(0.2)\n\nshared_params = SharedCanopyParameters{FT, typeof(earth_param_set)}(\n    z0_m,\n    z0_b,\n    earth_param_set,\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"For this canopy, we are running in standalone mode, which means we need to use a prescribed soil driver, defined as follows:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"ψ_soil0 = FT(0.0)\n\nsoil_driver = PrescribedGroundConditions(\n    FT;\n    root_depths = SVector{10, FT}(-(10:-1:1.0) ./ 10.0 * 2.0 .+ 0.2 / 2.0),\n    ψ = t -> ψ_soil0,\n    α_PAR = FT(0.2),\n    α_NIR = FT(0.4),\n    T = t -> 298.0,\n    ϵ = FT(0.99),\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Now, setup the canopy model by component. Provide arguments to each component, beginning with radiative transfer:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"rt_params = TwoStreamParameters(\n    FT;\n    G_Function = ConstantGFunction(FT(0.5)),\n    α_PAR_leaf = FT(0.1),\n    α_NIR_leaf = FT(0.45),\n    τ_PAR_leaf = FT(0.05),\n    τ_NIR_leaf = FT(0.25),\n    Ω = FT(0.69),\n    λ_γ_PAR = FT(5e-7),\n    λ_γ_NIR = FT(1.65e-6),\n)\n\nrt_model = TwoStreamModel{FT}(rt_params);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Arguments for conductance model:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"cond_params = MedlynConductanceParameters(FT; g1 = FT(141.0))\n\nstomatal_model = MedlynConductanceModel{FT}(cond_params);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Arguments for photosynthesis model:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"is_c3 = FT(1) # set the photosynthesis mechanism to C3\nphoto_params = FarquharParameters(FT, is_c3; Vcmax25 = FT(5e-5))\n\nphotosynthesis_model = FarquharModel{FT}(photo_params);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Arguments for autotrophic respiration model:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"AR_params = AutotrophicRespirationParameters(FT)\nAR_model = AutotrophicRespirationModel{FT}(AR_params);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Arguments for plant hydraulics model are more complicated.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Begin by providing general plant parameters. For the area indices of the canopy, we choose a PrescribedSiteAreaIndex, which supports LAI as a function of time, with RAI and SAI as constant.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"LAI = 4.2\nLAIfunction = (t) -> LAI\nSAI = FT(0.00242)\nf_root_to_shoot = FT(3.5)\nRAI = FT((SAI + LAI) * f_root_to_shoot)\nai_parameterization =\n    PrescribedSiteAreaIndex{FT}(TimeVaryingInput(LAIfunction), SAI, RAI)\nrooting_depth = FT(1.0);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Create the component conductivity and retention models of the hydraulics model. In ClimaLand, a Weibull parameterization is used for the conductivity as a function of potential, and a linear retention curve is used.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"K_sat_plant = FT(1.8e-8)\nψ63 = FT(-4 / 0.0098)\nWeibull_param = FT(4)\na = FT(0.05 * 0.0098)\n\nconductivity_model =\n    PlantHydraulics.Weibull{FT}(K_sat_plant, ψ63, Weibull_param)\n\nretention_model = PlantHydraulics.LinearRetentionCurve{FT}(a);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Use these values to populate the parameters of the PlantHydraulics model:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"ν = FT(0.7)\nS_s = FT(1e-2 * 0.0098)\n\nplant_hydraulics_ps = PlantHydraulics.PlantHydraulicsParameters(;\n    ai_parameterization = ai_parameterization,\n    ν = ν,\n    S_s = S_s,\n    rooting_depth = rooting_depth,\n    conductivity_model = conductivity_model,\n    retention_model = retention_model,\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Define the remaining variables required for the plant hydraulics model.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"plant_hydraulics = PlantHydraulics.PlantHydraulicsModel{FT}(;\n    parameters = plant_hydraulics_ps,\n    n_stem = n_stem,\n    n_leaf = n_leaf,\n    compartment_surfaces = compartment_surfaces,\n    compartment_midpoints = compartment_midpoints,\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Now, instantiate the canopy model, using the atmospheric and radiative drivers included from the external file, as well as the soil driver we instantiated above. This contains every piece of information needed to generate the set of ODEs modeling the canopy biophysics, ready to be passed off to a timestepper.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"canopy = ClimaLand.Canopy.CanopyModel{FT}(;\n    parameters = shared_params,\n    domain = land_domain,\n    autotrophic_respiration = AR_model,\n    radiative_transfer = rt_model,\n    photosynthesis = photosynthesis_model,\n    conductance = stomatal_model,\n    hydraulics = plant_hydraulics,\n    boundary_conditions = Canopy.AtmosDrivenCanopyBC(\n        atmos,\n        radiation,\n        soil_driver,\n    ),\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"[ Info: Using the PrescribedAtmosphere air temperature as the canopy temperature\n","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Initialize the state vectors and obtain the model coordinates, then get the explicit time stepping tendency that updates auxiliary and prognostic variables that are stepped explicitly.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Y, p, coords = ClimaLand.initialize(canopy)\nexp_tendency! = make_exp_tendency(canopy);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Provide initial conditions for the canopy hydraulics model","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"ψ_stem_0 = FT(-1e5 / 9800)\nψ_leaf_0 = FT(-2e5 / 9800)\n\nS_l_ini =\n    inverse_water_retention_curve.(\n        retention_model,\n        [ψ_stem_0, ψ_leaf_0],\n        ν,\n        S_s,\n    )\n\nfor i in 1:2\n    Y.canopy.hydraulics.ϑ_l.:($i) .= augmented_liquid_fraction.(ν, S_l_ini[i])\nend;","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Select a time range to perform time stepping over, and a dt. Also create the saveat Array to contain the data from the model at each time step. As usual, the timestep depends on the problem you are solving, the accuracy of the solution required, and the timestepping algorithm you are using.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"t0 = 0.0\nN_days = 364\ntf = t0 + 3600 * 24 * N_days\ndt = 225.0;","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Initialize the cache variables for the canopy using the initial conditions and initial time.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"set_initial_cache! = make_set_initial_cache(canopy)\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Allocate the struct which stores the saved auxiliary state and create the callback which saves it at each element in saveat.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"n = 16\nsaveat = Array(t0:(n * dt):tf)\nsv = (;\n    t = Array{Float64}(undef, length(saveat)),\n    saveval = Array{NamedTuple}(undef, length(saveat)),\n)\nsaving_cb = ClimaLand.NonInterpSavingCallback(sv, saveat);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Create the callback function which updates the forcing variables, or drivers.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"updateat = Array(t0:1800:tf)\nmodel_drivers = ClimaLand.get_drivers(canopy)\nupdatefunc = ClimaLand.make_update_drivers(model_drivers)\ndriver_cb = ClimaLand.DriverUpdateCallback(updateat, updatefunc)\ncb = SciMLBase.CallbackSet(driver_cb, saving_cb);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Select a timestepping algorithm and setup the ODE problem.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"timestepper = CTS.RK4();\node_algo = CTS.ExplicitAlgorithm(timestepper)\n\nprob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(T_exp! = exp_tendency!, dss! = ClimaLand.dss!),\n    Y,\n    (t0, tf),\n    p,\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Now, we can solve the problem and store the model data in the saveat array, using SciMLBase.jl and ClimaTimeSteppers.jl.","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"sol = SciMLBase.solve(prob, ode_algo; dt = dt, callback = cb, saveat = saveat);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/#Create-some-plots","page":"Standalone Canopy","title":"Create some plots","text":"","category":"section"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"We can now plot the data produced in the simulation. For example, GPP:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"daily = sol.t ./ 3600 ./ 24\nmodel_GPP = [\n    parent(sv.saveval[k].canopy.photosynthesis.GPP)[1] for\n    k in 1:length(sv.saveval)\n]\n\nplt1 = Plots.plot(size = (600, 700));\nPlots.plot!(\n    plt1,\n    daily,\n    model_GPP .* 1e6,\n    label = \"Model\",\n    xlim = [minimum(daily), maximum(daily)],\n    xlabel = \"days\",\n    ylabel = \"GPP [μmol/mol]\",\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Transpiration plot:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"T = [\n    parent(sv.saveval[k].canopy.energy.turbulent_fluxes.transpiration)[1]\n    for k in 1:length(sv.saveval)\n]\nT = T .* (1e3 * 24 * 3600)\n\nplt2 = Plots.plot(size = (500, 700));\nPlots.plot!(\n    plt2,\n    daily,\n    T,\n    label = \"Model\",\n    xlim = [minimum(daily), maximum(daily)],\n    xlabel = \"days\",\n    ylabel = \"Vapor Flux [mm/day]\",\n);","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Show the two plots together:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Plots.plot(plt1, plt2, layout = (2, 1));","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"Save the output:","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"savefig(\"ozark_standalone_canopy_test.png\");","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"(Image: )","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"","category":"page"},{"location":"generated/standalone/Canopy/canopy_tutorial/","page":"Standalone Canopy","title":"Standalone Canopy","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/#Introduction-to-the-Land-Bucket-Model","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"","category":"section"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"The land bucket model implemented in ClimaLand is based off of the models of Manabe (1969)[1], Milly and Shmakin (2002)[2], and the SLIM model (Laguë, Bonan, Swann 2019)[3], with small changes, as noted.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"This tutorial explains in brief the core equations and the necessary parameters of the bucket model, and shows how to set up a simulation in standalone mode. More detail for coupled runs can be found in the ClimaCoupler.jl documentation and in the coupled simulation tutorial.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"At each coordinate point on the surface, we solve ordinary differential equations for the subsurface water storage of land (W, m), the snow water equivalent multiplied by the snow cover fraction (σS, m), and the surface water content of land (Ws, m). We additionally solve a partial differential equation for the land temperature as a function of depth (T, K). The snow cover fraction is given by a heaviside function in the current code.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"In what follows, surface fluxes over soil generally indicate fluxes over non-snow-covered regions. The exception is the albedo of vegetated and non-vegetated surfaces, for which we use the symbol α_sfc.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"All equation variables are defined immediately below. We have:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"fracd Wdt = -I","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"fracd Wsdt = -(P_liq + σM + (1-σ) E_soil - I)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"fracd σSdt = -(P_snow + σE_snow - σM)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"ρc fracpartial Tpartial t = κ_soil fracpartial Tpartial z","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"F_bot = 00 = -κ_soil fracpartial Tpartial z_z = z_bot","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"(1-σ) (R_n+ SHF + LHF)_soil + σG_undersnow = -κ_soil fracpartial Tpartial z_z = z_sfc","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"G_undersnow = (R_n+ SHF + LHF)_snow - F_intosnow","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"F_intosnow = -ρ_l L_f0 (P_snow + E_snow-M)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"R_n = -(1-α)*SW -LW + σ_SB T_sfc^4","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"where the water fluxes are : I the infiltration as defined in [1], P_liq (m/s) the water volume flux of precipitation, P_snow (m/s) the water volume flux in the form of snow, (1-σ)E_soil (m/s) the water volume flux in evaporation, σE_snow the water volume flux in sublimation from snow, and σM (m/s) the water volume flux in melting of snow. The melt rate is defined via the net surface flux when surface temperatures are above freezing. All fluxes are defined to be positive if towards the atmosphere (cooling land or decreasing water mass in land) and negative if towards land (warming land or increasing water mass). Hence the melting flux is negative since it warms land, and precipitation fluxes are negative since they increase water mass on land.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"For heat fluxes, we have R_n the net radiation, SHF the sensible heat flux, LHF the latent heat flux, G_undersnow the heat flux into snow-covered soil, and F_intosnow the heat flux into the snowpack itself. Note that the water balance equation for snow is equivalent to the heat balance equation, since we neglect the sensible heat contribution and only track the latent heat contribution. We neglect the energy in liquid precipitation.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Finally, we have α_bareground_func(lat, lon) the (snow-free) surface albedo, ρc the volumetric heat capacity of the land, σ_SB the Stefan-Boltzmann constant,  and κ_soil the thermal conductivity. The albedo is a linear interpolation between the albedo of surface and snow, as decribed in [3]. The surface temperature is taken to be equal to the temperature T at the first grid point, assumed to be the same for soil and snow. At present the snow cover fraction is a heaviside function, and only one set of surface fluxes is computed per grid point.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Turbulent surface fluxes of sensible heat, latent heat, and water vapor (SHF, LHF, E) are computed using Monin-Obukhov theory; SW↓ and LW↓ are the downward fluxes in short and long wavelength bands. We use the same roughness lengths for snow and soil. Note that with the exception of precipitation and downwelling radiation, all fluxes are defined such that positive is towards the atmosphere.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"As the temperature at the surface of the soil and snow is the same, only the evaporation changes between the two surface coverage types. We have","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"E_soil =  β(W W_f) E(q_sat(T_sfc ρ_sfc liquid)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"where β is the factor used in [1] which accounts for the fact that soil does not evaporate at the potential rate when it is not saturated. This makes use of the field capacity parameter W_f. We also have","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"E_snow = E(q_sat(T_sfc ρ_sfc ice)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/#Simulating-a-standalone-bucket-model","page":"Introduction to the Land Bucket Model","title":"Simulating a standalone bucket model","text":"","category":"section"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"First, we need to import necessary packages. We use SciMLBase.jl and ClimaTimeSteppers.jl for the timestepping.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"import SciMLBase\nimport ClimaTimeSteppers as CTS","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"We use ClimaCore for setting up the domain/coordinate points. While this infrastructure isn't really necessary for standalone simulations, adhering to it makes setting up coupled simulations very easy. It also is nice to rely on ClimaCore utilities because they have been designed in advance for running distributed simulations.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"using ClimaCore","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"We also use ClimaParams, which strives to ensure a common set of parameters across all Clima models, and to make parameter estimation more seamless.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"import ClimaParams as CP","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"We also use Insolation to calculate solar zenith angle and solar insolation.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Lastly, let's bring in the bucket model types (from ClimaLand) that we will need access to.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"using ClimaLand.Bucket:\n    BucketModel, BucketModelParameters, PrescribedBaregroundAlbedo\nusing ClimaLand.Domains: coordinates, Column\nusing ClimaLand:\n    initialize,\n    make_update_aux,\n    make_exp_tendency,\n    make_set_initial_cache,\n    PrescribedAtmosphere,\n    PrescribedRadiativeFluxes\nusing ClimaUtilities.TimeVaryingInputs: TimeVaryingInput","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"We also want to plot the solution","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"using Plots","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"And we need to use the DateTime type to store start dates","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"using Dates\n\nFT = Float32;","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"As mentioned we use ClimaParams for earth parameters that are required across models (e.g. the density of water and ice, the latent heat of fusion at a reference temperature, etc). The land model requires additional parameters as described in the text above. These two sets are combined in the object BucketModelParameters as follows:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"import ClimaLand\nimport ClimaLand.Parameters as LP\nearth_param_set = LP.LandParameters(FT);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Set up the model domain. At every surface coordinate point, we'll solve an ODE for W and Ws, and for every subsurface point, we solve for T. In coupled simulations run at the same resolution as the atmosphere, the bucket horizontal resolution would match the horizontal resolution at the lowest level of the atmosphere model. In general, however, the two resolutions do not need to match. Here we just set up something simple - a Column.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"soil_depth = FT(3.5);\nbucket_domain = Column(; zlim = (-soil_depth, FT(0.0)), nelements = 10);\nsurface_space = bucket_domain.space.surface","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"ClimaCore.Spaces.PointSpace{ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}, ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, SubArray{Float32, 1, Matrix{Float32}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}}(ClimaComms.SingletonCommsContext{ClimaComms.CPUSingleThreaded}(ClimaComms.CPUSingleThreaded()), ClimaCore.DataLayouts.DataF{ClimaCore.Geometry.LocalGeometry{(3,), ClimaCore.Geometry.ZPoint{Float32}, Float32, StaticArraysCore.SMatrix{1, 1, Float32, 1}}, SubArray{Float32, 1, Matrix{Float32}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}\n  Float32[0.0, 0.35, 0.175, 2.85714, 0.35, 2.85714, 8.16327, 0.1225])","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Define our PrescribedBaregroundAlbedo model using a constant bareground surface and snow albedo: The bareground albedo is a function of coordinates, which would be (x,y) on a plane, and (lat,lon) on a sphere. It is also an option to supply a netcdf file with the bareground albedo.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"α_bareground_func = (coordinate_point) -> 0.2;\nα_snow = FT(0.8);\nalbedo =\n    PrescribedBaregroundAlbedo{FT}(α_snow, α_bareground_func, surface_space);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"The critical snow level setting the scale for when we interpolate between snow and surface albedo","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"σS_c = FT(0.2);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"The field capacity of the soil","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"W_f = FT(0.15);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Roughness lengths (meters)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"z_0m = FT(1e-2);\nz_0b = FT(1e-3);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Thermal parameters of soil","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"κ_soil = FT(0.7);\nρc_soil = FT(2e6);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Snow melt timescale","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"τc = FT(3600);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Simulation start date, end time, and timestep","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"t0 = 0.0;\ntf = 7 * 86400;\nΔt = 3600.0;\n\nbucket_parameters = BucketModelParameters(FT; albedo, z_0m, z_0b, τc);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"The PrescribedAtmosphere and PrescribedRadiation need to take in a reference time, the date of the start of the simulation. In this tutorial we will consider this January 1, 2005.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"start_date = DateTime(2005);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"To drive the system in standalone mode, the user must provide prescribed functions of time for the water volume flux in precipitation,  for the net downward shortwave and longwave radiative energy fluxes (SW↓, LW↓, W/m^2), for the atmospheric temperature T_a, wind speed u_a (m/s), specific humidity q_a, and air density ρ_a (kg/m^3) at a reference height h_a (m).","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Here we define the model drivers Prescribed atmospheric variables","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Precipitation:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"precip = (t) -> 0;\nsnow_precip = (t) -> -5e-7 * (t > 3 * 86400) * (t < 4 * 86400);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Diurnal temperature variations:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"T_atmos = (t) -> 275.0 + 5.0 * sin(2.0 * π * t / 86400 - π / 2);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Constant otherwise:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"u_atmos = (t) -> 3.0;\nq_atmos = (t) -> 0.005;\nh_atmos = FT(2);\nP_atmos = (t) -> 101325;","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"We need to warp all these objects in TimeVaryingInputs (this is because in general PrescribedAtmosphere could take numerical data)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"bucket_atmos = PrescribedAtmosphere(\n    TimeVaryingInput(precip),\n    TimeVaryingInput(snow_precip),\n    TimeVaryingInput(T_atmos),\n    TimeVaryingInput(u_atmos),\n    TimeVaryingInput(q_atmos),\n    TimeVaryingInput(P_atmos),\n    start_date,\n    h_atmos,\n    earth_param_set,\n);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Prescribed radiation – a prescribed downwelling SW diurnal cycle, with a peak at local noon, and a prescribed downwelling LW radiative flux, assuming the air temperature is on average 275 degrees K with a diurnal amplitude of 5 degrees K:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"SW_d = (t) -> @. max(1361 * sin(2π * t / 86400 - π / 2));\nLW_d = (t) -> 5.67e-8 * (275.0 + 5.0 * sin(2.0 * π * t / 86400 - π / 2))^4;\nbucket_rad = PrescribedRadiativeFluxes(\n    FT,\n    TimeVaryingInput(SW_d),\n    TimeVaryingInput(LW_d),\n    start_date,\n);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Then, we create the model object, which contains the drivers, parameters, domain, and is associated with the correct differential equations for the bucket model:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"model = BucketModel(\n    parameters = bucket_parameters,\n    domain = bucket_domain,\n    atmosphere = bucket_atmos,\n    radiation = bucket_rad,\n);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Note the holder structs for the radiation and atmosphere functions: they are named Prescribed. In coupled simulations, we would use a different type and rely on multiple dispatch to obtain the atmospheric and radiative quantitites from the coupler.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Like all ClimaLand models, we set up the state vector using initialize:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Y, p, coords = initialize(model);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"We can inspect the prognostic and auxiliary variables of the model:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"ClimaLand.prognostic_vars(model)\nY.bucket |> propertynames","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"(:W, :T, :Ws, :σS)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"The auxiliary variables in this case are the surface temperature, the turbulent fluxes, the net radiation, and the surface specific humidity.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"ClimaLand.auxiliary_vars(model)\np.bucket |> propertynames","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"(:q_sfc, :turbulent_fluxes, :R_n, :T_sfc, :α_sfc, :ρ_sfc, :snow_cover_fraction, :F_sfc, :partitioned_fluxes, :G, :snow_melt, :infiltration, :top_bc_wvec)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Next is to set initial conditions.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Y.bucket.T .= FT(270);\nY.bucket.W .= FT(0.05);\nY.bucket.Ws .= FT(0.0);\nY.bucket.σS .= FT(0.08);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"We also set the initial values of the cache here:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"set_initial_cache! = make_set_initial_cache(model);\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Then to create the entire right hand side (tendency) function for the system of ordinary differential equations:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"exp_tendency! = make_exp_tendency(model);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Now we choose our timestepping algorithm.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"timestepper = CTS.RK4()\node_algo = CTS.ExplicitAlgorithm(timestepper)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"ClimaTimeSteppers.IMEXAlgorithm{ClimaTimeSteppers.Unconstrained, ClimaTimeSteppers.RK4, ClimaTimeSteppers.IMEXTableau{ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}}, Nothing}(ClimaTimeSteppers.Unconstrained(), ClimaTimeSteppers.RK4(), ClimaTimeSteppers.IMEXTableau{ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}, ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}, ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}}(ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}([0.0 0.0 0.0 0.0; 0.5 0.0 0.0 0.0; 0.0 0.5 0.0 0.0; 0.0 0.0 1.0 0.0]), ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.16666666666666666, 0.3333333333333333, 0.3333333333333333, 0.16666666666666666]), ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.0, 0.5, 0.5, 1.0]), ClimaTimeSteppers.SparseCoeffs{(4, 4), (true, false, true, true, true, true, false, true, true, true, true, false, true, true, true, true), StaticArraysCore.SMatrix{4, 4, Float64, 16}}([0.0 0.0 0.0 0.0; 0.5 0.0 0.0 0.0; 0.0 0.5 0.0 0.0; 0.0 0.0 1.0 0.0]), ClimaTimeSteppers.SparseCoeffs{(4,), (false, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.16666666666666666, 0.3333333333333333, 0.3333333333333333, 0.16666666666666666]), ClimaTimeSteppers.SparseCoeffs{(4,), (true, false, false, false), StaticArraysCore.SVector{4, Float64}}([0.0, 0.5, 0.5, 1.0])), nothing)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Then we can set up the simulation and solve it:","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"prob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(T_exp! = exp_tendency!, dss! = ClimaLand.dss!),\n    Y,\n    (t0, tf),\n    p,\n);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"We need a callback to get and store the auxiliary fields, as they are not stored by default. We also need a callback to update the drivers (atmos and radiation)","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"saveat = collect(t0:Δt:tf);\nsaved_values = (;\n    t = Array{Float64}(undef, length(saveat)),\n    saveval = Array{NamedTuple}(undef, length(saveat)),\n);\nsaving_cb = ClimaLand.NonInterpSavingCallback(saved_values, saveat);\nupdateat = copy(saveat)\nmodel_drivers = ClimaLand.get_drivers(model)\nupdatefunc = ClimaLand.make_update_drivers(model_drivers)\ndriver_cb = ClimaLand.DriverUpdateCallback(updateat, updatefunc)\ncb = SciMLBase.CallbackSet(driver_cb, saving_cb)\n\nsol = SciMLBase.solve(prob, ode_algo; dt = Δt, saveat = saveat, callback = cb);","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"Extracting the solution from what is returned by the ODE.jl commands is a bit clunky right now, but we are working on hiding some of this. parent extracts the underlying data from the ClimaCore.Fields.Field object and we loop over the solution sol because of how the data is stored within solutions returned by ODE.jl - indexed by timestep.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"W = [parent(sol.u[k].bucket.W)[1] for k in 1:length(sol.t)];\nWs = [parent(sol.u[k].bucket.Ws)[1] for k in 1:length(sol.t)];\nσS = [parent(sol.u[k].bucket.σS)[1] for k in 1:length(sol.t)];\nT_sfc =\n    [parent(saved_values.saveval[k].bucket.T_sfc)[1] for k in 1:length(sol.t)];\nevaporation = [\n    parent(saved_values.saveval[k].bucket.turbulent_fluxes.vapor_flux)[1]\n    for k in 1:length(sol.t)\n];\nR_n = [parent(saved_values.saveval[k].bucket.R_n)[1] for k in 1:length(sol.t)];","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"The turbulent energy flux is the sum of latent and sensible heat fluxes.","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"LHF = [\n    parent(saved_values.saveval[k].bucket.turbulent_fluxes.lhf)[1] for\n    k in 1:length(sol.t)\n];\nSHF = [\n    parent(saved_values.saveval[k].bucket.turbulent_fluxes.shf)[1] for\n    k in 1:length(sol.t)\n];\nturbulent_energy_flux = SHF .+ LHF\n\nplot(\n    sol.t ./ 86400,\n    W,\n    label = \"\",\n    xlabel = \"time (days)\",\n    ylabel = \"W (m)\",\n    title = \"Land water storage (m)\",\n)\nsavefig(\"w.png\")","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"\"/home/runner/work/ClimaLand.jl/ClimaLand.jl/docs/src/generated/standalone/Bucket/w.png\"","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"(Image: )","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"plot(\n    sol.t ./ 86400,\n    σS,\n    label = \"\",\n    xlabel = \"time (days)\",\n    ylabel = \"σS (m)\",\n    title = \"Area weighted SWE (m) \",\n)\nsavefig(\"swe.png\")","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"\"/home/runner/work/ClimaLand.jl/ClimaLand.jl/docs/src/generated/standalone/Bucket/swe.png\"","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"(Image: )","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"plot(\n    sol.t ./ 86400,\n    snow_precip.(sol.t),\n    label = \"Net precipitation\",\n    xlabel = \"time (days)\",\n    ylabel = \"Flux (m/s)\",\n    title = \"Surface water fluxes\",\n    legend = :bottomright,\n)\nplot!(sol.t ./ 86400, evaporation, label = \"Sublimation/Evaporation\")\nsavefig(\"water_f.png\")","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"\"/home/runner/work/ClimaLand.jl/ClimaLand.jl/docs/src/generated/standalone/Bucket/water_f.png\"","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"(Image: )","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"plot(\n    sol.t ./ 86400,\n    T_sfc,\n    title = \"Surface Temperatures\",\n    label = \"Ground temperature\",\n    xlabel = \"time (days)\",\n    ylabel = \"T_sfc (K)\",\n    legend = :bottomright,\n)\nplot!(sol.t ./ 86400, T_atmos.(sol.t), label = \"Atmospheric Temperature\")\nsavefig(\"t.png\")","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"\"/home/runner/work/ClimaLand.jl/ClimaLand.jl/docs/src/generated/standalone/Bucket/t.png\"","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"(Image: )","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"plot(\n    sol.t ./ 86400,\n    R_n,\n    label = \"Net radiative flux\",\n    xlabel = \"time (days)\",\n    ylabel = \"Flux (W/m^2)\",\n    title = \"Surface energy fluxes\",\n    legend = :bottomright,\n)\nplot!(sol.t ./ 86400, turbulent_energy_flux, label = \"Turbulent fluxes\")\nplot!(sol.t ./ 86400, R_n .+ turbulent_energy_flux, label = \"Net flux\")\nsavefig(\"energy_f.png\")","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"\"/home/runner/work/ClimaLand.jl/ClimaLand.jl/docs/src/generated/standalone/Bucket/energy_f.png\"","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"(Image: )","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/#References","page":"Introduction to the Land Bucket Model","title":"References","text":"","category":"section"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"[1] Manabe, S. (1969) CLIMATE AND THE OCEAN CIRCULATION I: The Atmospheric Circulation and the Hydrology of the Earth's Surface. Monthly Weather Review, Volume 97: Issue 11, p 739-774. [2] Milly, P. C. D. and Shmakin, A.B. (2002) Global Modeling of Land Water and Energy Balances. Part I: The Land Dynamics (LaD) Model Journal of Hydrometeorology, Volume 3: Issue 3, p 283-299. [3] Laguë, M., Bonan, G., and Swann, A. (2019) Seperating the Impact of Individual Land Surface Properties on the Terrestrial Surface Energy Budget in both the Coupled and Uncoupled Land-Atmosphere System Volume 32: Issue 18, p 5725-5744","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"","category":"page"},{"location":"generated/standalone/Bucket/bucket_tutorial/","page":"Introduction to the Land Bucket Model","title":"Introduction to the Land Bucket Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/#The-Two-Stream-Scheme","page":"Two-Stream model","title":"The Two-Stream Scheme","text":"","category":"section"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"In order to treat the effects of multiple scattering by cloud particles, aerosols and air molecules, the two-stream approximations are employed in most shortwave radiation (i.e., solar, 300-2500 nm) schemes presently used in LSMs for numerical weather prediction and climate modelling. In two-stream approximations, the radiation field is divided into the direct solar beam, plus the diffuse solar radiation (i.e., radiation scattered at least once), and in two directions, downward and upward fluxes. The angular distribution of scattered radiation is not computed in any further detail, which means they are considered to be isotropic (Raisaenen, 2002).","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"The two-stream approximation, or scheme has been used to deal with radiative transfer in the atmosphere for many years. The basic procedure in applying it to vegetation is to expand a complex function in the control equations into Legendre functions and then truncate them to the first order closure to get a simple solution (Dai, 2007). After reviewing several variants of the two-stream approximation model in the calculation of atmospheric radiation, Meador (1980) presented a unified form of the variants and introduced a new and improved method.","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"Dickinson 1983 introduced this new two-stream method to estimate radiative transfer in a vegetated canopy, and Sellers 1985 used the two-stream approximation to calculate values of hemispheric canopy reflectance in the visible or photosynthecially active radiation (PAR) and near-infrared (NIR) wavelength intervals. The two-stream approximation treatment has been widely used in land surface process models until nowadays. The approximation assumes that diffuse radiative fluxes are isotropic in the upward and downward directions. Supposing that the upper and lower leaf optical properties are identical, the two-stream approximation used to model radiative transfer in plant canopies is given in the following form:","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"-overlinemu(dI^uparrow)dL + 1 - (1 - beta)omegaI^uparrow - omega beta I^downarrow = omega overlinemu K beta_0 exp(-KL)\n-overlinemu(dI^downarrow)dL + 1 - (1 - beta)omegaI^downarrow - omega beta I^uparrow = omega overlinemu K (1-beta_0) exp(-KL)","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"where I↑ and I↓ are the upward and downward diffuse radiative fluxes normalized by the incident flux respectively, μ is the cosine of the zenith angle of the incident beam, K is the optical depth of direct beam per unit leaf area and is equal to G(μ)/μ, G(μ) is the relative projected area of leaf elements in the direction cos−1μ, μ is the average inverse diffuse optical depth per unit leaf area and is equal to","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"int_0^1mu^primeG(mu^prime)dmu^prime","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"μ′ is the direction of scattered flux, ω is the scattering coefficient and is equal to ρleaf +τleaf , and L is the cumulative LAI. β and β0 are upscattering parameters for the diffuse and direct beams respectively. (See Sellers 1985 for details)","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"These equations can be solved as an exact solution with appropriate boundary conditions. For direct incident radiation, the appropriate top boundary condition is I↓ = 0 for L = 0, and the bottom boundary condition is I↑ = ρs[I↓ + exp (−kLT )] for L = LT , where ρs is the soil reflectance and LT is the total LAI. The corresponding solution yielded is then:","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"I^uparrow = frach_1exp(-KL)sigma + h_2exp(-hL) + h_3exp(hL)\nI^downarrow = frach_4exp(-KL)sigma + h_5exp(-hL) + h_6exp(hL)","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"For diffuse radiation, the appropriate top boundary condition is I↓ = 1 for L = 0, and the bottom boundary condition is I↑ = ρsI↓ for L = LT. Then, the corresponding solution is:","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"I^uparrow = h_7exp(-hL) + h_8exp(hL)\nI^downarrow = h_9exp(-hL) + h_10exp(hL)","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"where coefficients such as σ and h1 to h10 are given in Sellers 1985. Note that there is an error in the expression for h4 in the appendix of Sellers 1985. The correct expression may be found in Sellers 1996.","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"The model has the following parameters:","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"Output Symmbol Unit Range\nAbsorbed Photosynthetically Active Radiation APAR μmol m⁻² s⁻¹ 0-1500\nAbsorbed Near-Infrared Radiation ANIR μmol m⁻² s⁻¹ 0-1500","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"Drivers Symbol Unit Range\nPhotosynthetically Active Radiation PAR μmol m⁻² s⁻¹ 0–1500\nLeaf Area Index LAI m² m⁻² 0–10","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"Parameters Symbol Unit Range\nCanopy PAR Reflectance alpha_PAR_leaf - 0.0–1.0\nCanopy NIR Reflectance alpha_NIR_leaf - 0.0–1.0\nCanopy PAR Transmittance tau_PAR_leaf - 0.0–1.0\nCanopy NIR Transmittance tau_NIR_leaf - 0.0–1.0\nCanopy Emissivity ϵ_canopy - 0.0–1.0\nClumping index Ω - 0.0–1.0\nZenith angle θ_s rad 0–π","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/twostream_model/","page":"Two-Stream model","title":"Two-Stream model","text":"Constants Symbol Unit Value\nLeaf angle distribution l_d - 0.5\nTypical wavelength per photon PAR lambda_gamma_PAR m 5e-7\nTypical wavelength per photon NIR lambda_gamma_NIR m 1.65e-6","category":"page"},{"location":"APIs/Bucket/#Bucket","page":"Bucket Model","title":"Bucket","text":"","category":"section"},{"location":"APIs/Bucket/","page":"Bucket Model","title":"Bucket Model","text":"CurrentModule = ClimaLand.Bucket","category":"page"},{"location":"APIs/Bucket/#Types","page":"Bucket Model","title":"Types","text":"","category":"section"},{"location":"APIs/Bucket/","page":"Bucket Model","title":"Bucket Model","text":"ClimaLand.Bucket.BucketModelParameters\nClimaLand.Bucket.PrescribedBaregroundAlbedo\nClimaLand.Bucket.PrescribedSurfaceAlbedo\nClimaLand.Bucket.BucketModel","category":"page"},{"location":"APIs/Bucket/#ClimaLand.Bucket.BucketModelParameters","page":"Bucket Model","title":"ClimaLand.Bucket.BucketModelParameters","text":"struct BucketModelParameters{\n    FT <: AbstractFloat,\n    PSE,\n}\n\nContainer for holding the parameters of the bucket model.\n\nκ_soil: Conductivity of the soil (W/K/m); constant\nρc_soil: Volumetric heat capacity of the soil (J/m^3/K); constant\nalbedo: Albedo Model\nσS_c: Critical σSWE amount (m) where surface transitions from to snow-covered\nf_snow: Fraction of critical amount of snow at which sublimation β begins to decay to zero (unitless)\nW_f: Capacity of the land bucket (m)\nf_bucket: Fraction of bucket capacity at which evaporation β begins to decay to zero (unitless)\np: Exponent used in β decay (unitless)\nz_0m: Roughness length for momentum (m)\nz_0b: Roughness length for scalars (m)\nτc: τc timescale on which snow melts\nearth_param_set: Earth Parameter set; physical constants, etc\n\n\n\n\n\n","category":"type"},{"location":"APIs/Bucket/#ClimaLand.Bucket.PrescribedBaregroundAlbedo","page":"Bucket Model","title":"ClimaLand.Bucket.PrescribedBaregroundAlbedo","text":"PrescribedBaregroundAlbedo{FT, F <: ClimaCore.Fields.Field} <: AbstractBucketAlbedoModel\n\nAn albedo model where the static snow-free bareground albedo is prescribed as a function of space or using data from a file, and the land surface albedo is computed each timestep as a linear combination of the snow albedo and the bareground albedo, following the SLIM model (Lague et al 2019).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Bucket/#ClimaLand.Bucket.PrescribedSurfaceAlbedo","page":"Bucket Model","title":"ClimaLand.Bucket.PrescribedSurfaceAlbedo","text":"PrescribedSurfaceAlbedo{FT, TV <: AbstractTimeVaryingInput}\n                   <: AbstractBucketAlbedoModel\n\nAn albedo model where the albedo of different surface types is specified. Albedo is specified via a NetCDF file which is a function of time and covers all surface types (soil, vegetation, snow, etc). This albedo type changes over time according to the input file.\n\nNote that this option should only be used with global simulations, i.e. with a ClimaLand.LSMSphericalShellDomain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Bucket/#ClimaLand.Bucket.BucketModel","page":"Bucket Model","title":"ClimaLand.Bucket.BucketModel","text":"struct BucketModel{\n     FT,\n     PS <: BucketModelParameters{FT},\n     ATM <: AbstractAtmosphericDrivers{FT},\n     RAD <: AbstractRadiativeDrivers{FT},\n     D,\n } <: AbstractBucketModel{FT}\n\nConcrete type for the BucketModel, which store the model domain and parameters, as well as the necessary atmosphere and radiation fields for driving the model.\n\nparameters: Parameters required by the bucket model\natmos: The atmospheric drivers: Prescribed or Coupled\nradiation: The radiation drivers: Prescribed or Coupled\ndomain: The domain of the model\n\n\n\n\n\n","category":"type"},{"location":"APIs/Bucket/#Misc-Functions","page":"Bucket Model","title":"Misc Functions","text":"","category":"section"},{"location":"APIs/Bucket/","page":"Bucket Model","title":"Bucket Model","text":"ClimaLand.Bucket.surface_albedo\nClimaLand.Bucket.beta_factor","category":"page"},{"location":"APIs/Bucket/#ClimaLand.surface_albedo","page":"Bucket Model","title":"ClimaLand.surface_albedo","text":"ClimaLand.surface_albedo(\n    model::EnergyHydrology{FT},\n    Y,\n    p,\n) where {FT}\n\nReturns the surface albedo field of the EnergyHydrology soil model.\n\n\n\n\n\nsurface_albedo(model::SnowModel, Y, p)\n\nA helper function which computes and returns the snow albedo.\n\n\n\n\n\nsurface_albedo(model::BucketModel, Y, p)\n\nReturns the bulk surface albedo, which gets updated in update_aux via next_albedo.\n\n\n\n\n\nsurface_albedo(model::AbstractModel, Y, p)\n\nA helper function which returns the surface albedo for a given model, needed because different models compute and store α_sfc in different ways and places.\n\nExtending this function for your model is only necessary if you need to compute surface fluxes and radiative fluxes at the surface using the functions in this file.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Bucket/#ClimaLand.Bucket.beta_factor","page":"Bucket Model","title":"ClimaLand.Bucket.beta_factor","text":"beta_factor(W::FT, σS::FT, fW_f::FT, fσS_c::FT, p::FT) where {FT}\n\nComputes the beta factor which scales the evaporation/sublimation from the potential rate. The beta factor is given by:\n\nβ = (x/xc)^p x < xc     1         otherwise\n\nwhere x = W and xc = fbucket * Wf for the bucket, and x = σS and xc = fsnow *σSc for snow.\n\n\n\n\n\n","category":"function"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#Coupled-heat-and-water-equations-tending-towards-equilibrium","page":"Energy and Hydrology","title":"Coupled heat and water equations tending towards equilibrium","text":"","category":"section"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"The Richards equation tutorial demonstrates how to solve for water flow in soil, without considering heat transfer, phase changes, or the effect of temperature and the effect of ice on the hydraulic properties of the soil.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Here we show how to solve the interacting heat and water equations, in sand, but without phase changes. This allows us to capture behavior that is not present in Richards equation alone.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"The equations are:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"frac ρe_int t =    κ(θ_l θ_i ν ) T +   ρe_int_liq K (Tθ_l θ_i ν ) nabla h( ϑ_l z ν )","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"frac  ϑ_l t =   K (Tθ_l θ_i ν ) h( ϑ_l z ν )","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Here","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"t is the time (s),","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"z is the location in the vertical (m),","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"ρe_int is the volumetric internal energy of the soil (J/m^3),","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"T is the temperature of the soil (K),","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"κ is the thermal conductivity (W/m/K),","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"ρe_int_liq is the volumetric internal energy of liquid water (J/m^3),","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"K is the hydraulic conductivity (m/s),","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"h is the hydraulic head (m),","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"ϑ_l is the augmented volumetric liquid water fraction,","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"θ_i is the volumetric ice fraction, and","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"ν  denotes parameters relating to soil type, such as porosity.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We will solve this equation in an effectively 1-d domain with z  -10, and with the following boundary and initial conditions:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"- κ T(t z = 0) = 0 ẑ","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"-κ T(t z = -1) = 0 ẑ","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"T(t = 0 z) = T_min + (T_max-T_min) e^Cz","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"- K h(t z = 0) = 0 ẑ","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"-K h(t z = -1) = 0 ẑ","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"ϑ(t = 0 z) = ϑ_min + (ϑ_max-ϑ_min) e^Cz","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"where C T_min T_max ϑ_min and ϑ_max are constants.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"If we evolve this system for times long compared to the dynamical timescales of the system, we expect it to reach an equilibrium where the LHS of these equations tends to zero. Assuming zero fluxes at the boundaries, the resulting equilibrium state should satisfy hz = 0 and Tz = 0. Physically, this means that the water settles into a vertical profile in which the resulting pressure balances gravity and that the temperature is constant across the domain.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We verify that the system is approaching this equilibrium, and we also sketch out an analytic calculation for the final temperature in equilibrium.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#Import-necessary-modules","page":"Energy and Hydrology","title":"Import necessary modules","text":"","category":"section"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"External (non - CliMA) modules","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"import SciMLBase\nusing Statistics\nusing Plots","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"CliMA packages and ClimaLand modules","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"using ClimaCore\nimport ClimaParams as CP\nimport ClimaTimeSteppers as CTS\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\n\nimport ClimaLand\nimport ClimaLand.Parameters as LP","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Choose a floating point precision, and get the parameter set, which holds constants used across CliMA models:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"FT = Float32\nearth_param_set = LP.LandParameters(FT);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#Create-the-model","page":"Energy and Hydrology","title":"Create the model","text":"","category":"section"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Set the values of other parameters required by the model:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"ν = FT(0.395)","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"0.395f0","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Soil solids are the components of soil besides water, ice, gases, and air. We specify the soil component fractions, relative to all soil solids. These do not sum to unity; the remainder is νssminerals (=0.08, in this case).","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"ν_ss_quartz = FT(0.92)\nν_ss_om = FT(0.0)\nν_ss_gravel = FT(0.0)","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"0.0f0","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Other parameters include the hydraulic conductivity at saturation, the specific storage, and the van Genuchten parameters for sand. We recommend Chapter 8 of Bonan (2019) for finding parameters for other soil types.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Ksat = FT(4.42 / 3600 / 100) # m/s\nS_s = FT(1e-3) #inverse meters\nvg_n = FT(1.89)\nvg_α = FT(7.5) # inverse meters\nhydrology_cm = vanGenuchten{FT}(; α = vg_α, n = vg_n)\nθ_r = FT(0.0)\nparams = Soil.EnergyHydrologyParameters(\n    FT;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm,\n    K_sat = Ksat,\n    S_s,\n    θ_r,\n);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We also need to pick a domain on which to solve the equations:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"zmax = FT(0)\nzmin = FT(-1.0)\nnelems = 50\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"The boundary value problem in this case requires a boundary condition at the top and the bottom of the domain for each equation being solved. We support conditions on the state (ϑ_l or T), or on the fluxes (-K∇h or -κ∇T). In the case of fluxes, we return the magnitude of the flux, assumed to point along ẑ. And, in each case, the boundary conditions are supplied in the form of a function of auxiliary variables p and time t.  Here we choose flux boundary conditions. The flux boundary condition requires a function of the cache and simulation time which returns the boundary flux.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Water boundary conditions:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"surface_water_flux = WaterFluxBC((p, t) -> 0.0)\nbottom_water_flux = WaterFluxBC((p, t) -> 0.0);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"The boundary conditions for the heat equation:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"surface_heat_flux = HeatFluxBC((p, t) -> 0.0)\nbottom_heat_flux = HeatFluxBC((p, t) -> 0.0);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We wrap up all of those in a WaterHeatBC struct:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"boundary_fluxes = (;\n    top = WaterHeatBC(; water = surface_water_flux, heat = surface_heat_flux),\n    bottom = WaterHeatBC(; water = bottom_water_flux, heat = bottom_heat_flux),\n);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We aren't using any sources or sinks in the equations here, but this is where freeze/thaw terms, runoff, root extraction, etc. would go.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"sources = ();","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Lastly, we can create the EnergyHydrology model. As always, the model encodes and stores all of the information (parameters, continous equations, prognostic variables, etc) which are needed to turn the PDE system into a set of ODEs, properly spatially discretized for the domain of interest.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"soil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Here we create the explicit and implicit tendencies, which update prognostic variable components that are stepped explicitly and implicitly, respectively. We also create the function which is used to update our Jacobian.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"exp_tendency! = make_exp_tendency(soil);\nimp_tendency! = make_imp_tendency(soil);\njacobian! = ClimaLand.make_jacobian(soil);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#Set-up-the-simulation","page":"Energy and Hydrology","title":"Set up the simulation","text":"","category":"section"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We can now initialize the prognostic and auxiliary variable vectors, and take a peek at what those variables are:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Y, p, coords = initialize(soil);\nY.soil |> propertynames\n\np.soil |> propertynames\n\ncoords |> propertynames","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"(:surface, :subsurface)","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Note that the variables are nested into Y and p in a hierarchical way. Since we have the vectors handy, we can now set them to the desired initial conditions.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"function init_soil!(Y, z, params)\n    ν = params.ν\n    θ_r = params.θ_r\n    FT = eltype(Y.soil.ϑ_l)\n    zmax = FT(0)\n    zmin = FT(-1)\n\n    theta_max = FT(ν * 0.5)\n    theta_min = FT(ν * 0.4)\n    T_max = FT(289.0)\n    T_min = FT(288.0)\n\n    c = FT(20.0)\n    @. Y.soil.ϑ_l =\n        theta_min +\n        (theta_max - theta_min) * exp(-(z - zmax) / (zmin - zmax) * c)\n    Y.soil.θ_i .= FT(0.0)\n\n    T = @.(T_min + (T_max - T_min) * exp(-(z - zmax) / (zmin - zmax) * c))\n\n    θ_l = Soil.volumetric_liquid_fraction.(Y.soil.ϑ_l, ν, θ_r)\n    ρc_s =\n        Soil.volumetric_heat_capacity.(\n            θ_l,\n            Y.soil.θ_i,\n            params.ρc_ds,\n            params.earth_param_set,\n        )\n    Y.soil.ρe_int .=\n        Soil.volumetric_internal_energy.(\n            Y.soil.θ_i,\n            ρc_s,\n            T,\n            params.earth_param_set,\n        )\nend\n\ninit_soil!(Y, coords.subsurface.z, soil.parameters);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We choose the initial and final simulation times:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"t0 = Float64(0)\ntf = Float64(60 * 60 * 72);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We set the cache values corresponding to the initial conditions of the state Y:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"set_initial_cache! = make_set_initial_cache(soil);\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We use ClimaTimesteppers.jl for carrying out the time integration.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Choose a timestepper and set up the ODE problem:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"dt = Float64(1000.0);\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\n\njac_kwargs = (; jac_prototype = ImplicitEquationJacobian(Y), Wfact = jacobian!);\n\nprob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"By default, it only returns Y and t at each time we request output (saveat, below). We use a callback in order to also get the auxiliary vector p back:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"saveat = collect(t0:FT(30000):tf)\nsaved_values = (;\n    t = Array{Float64}(undef, length(saveat)),\n    saveval = Array{NamedTuple}(undef, length(saveat)),\n);\ncb = ClimaLand.NonInterpSavingCallback(saved_values, saveat);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Now we can solve the problem.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"sol = SciMLBase.solve(prob, ode_algo; dt = dt, saveat = saveat, callback = cb);","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Extract output","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"z = parent(coords.subsurface.z)\nt = parent(sol.t)\nϑ_l = [parent(sol.u[k].soil.ϑ_l) for k in 1:length(t)]\nT = [parent(saved_values.saveval[k].soil.T) for k in 1:length(t)];","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Let's look at the initial and final times:","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"plot(ϑ_l[1], z, xlabel = \"ϑ_l\", ylabel = \"z (m)\", label = \"t = 0d\")\nplot!(ϑ_l[4], z, label = \"t = 1.5d\")\nplot!(ϑ_l[end], z, label = \"t = 3d\")\nsavefig(\"eq_moisture_plot.png\");","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"plot(T[1], z, xlabel = \"T (K)\", ylabel = \"z (m)\", label = \"t = 0d\")\nplot!(T[4], z, xlabel = \"T (K)\", ylabel = \"z (m)\", label = \"t = 1.5d\")\nplot!(T[end], z, xlabel = \"T (K)\", ylabel = \"z (m)\", label = \"t = 3d\")\nsavefig(\"eq_temperature_plot.png\");","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#Analytic-Expectations","page":"Energy and Hydrology","title":"Analytic Expectations","text":"","category":"section"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"We can determine a priori what we expect the final temperature to be in equilibrium.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Regardless of the final water profile in equilibrium, we know that the final temperature T_f will be a constant across the domain. All water that began with a temperature above this point will cool to T_f, and water that began with a temperature below this point will warm to T_f. The initial function T(z) is equal to T_f at a value of z = z̃. This is the location in space which divides these two groups (water that warms over time and water that cools over time) spatially. We can solve for z̃(T_f) using T_f = T(z̃).","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Next, we can determine the change in energy required to cool the water above z̃ to T_f: it is the integral from z̃ to the surface at z = 0 of c θ(z) T(z), where c is the volumetric heat capacity - a constant here - and θ(z) is the initial water profile. Compute the energy required to warm the water below z̃ to T_f in a similar way, set equal, and solve for T_f. This results in T_f = 288.056, which is very close to the mean T we observe after 3 days, of 288.054.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"One could also solve the equation for ϑ_l specified by  h z = 0 to determine the functional form of the equilibrium profile of the liquid water.","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/#References","page":"Energy and Hydrology","title":"References","text":"","category":"section"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"Bonan, G.  Climate change and terrestrial ecosystem modeling. Cambridge University Press, 2019.\nBalland and Arp, J. Environ. Eng. Sci. 4: 549–558 (2005)","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"","category":"page"},{"location":"generated/standalone/Soil/soil_energy_hydrology/","page":"Energy and Hydrology","title":"Energy and Hydrology","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"This shows how to run single column soil model, in standalone mode with spatially varying properties. We are mimicking the experiment carried out in Huang et. al. Can. J. Soil Sci. (2011) 91: 169\u0001183 doi:10.4141/CJSS09118, which measured the infiltration of layered soil in Fort McMurray, Alberta, Canada. We thank Mingbin Huang and S. Lee Barbour for correspondence and support, including sharing of data, with us. Note that all data used in this tutorial is available in their publication.","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"using Plots\nimport ClimaUtilities.SpaceVaryingInputs: SpaceVaryingInput\nimport SciMLBase\nimport ClimaTimeSteppers as CTS\nusing ClimaCore\nimport ClimaParams as CP\nusing DelimitedFiles: readdlm\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\nimport ClimaLand\nFT = Float64;","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Define simulation times","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"t0 = Float64(0)\ntf = Float64(60 * 60)\ndt = Float64(30);","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Define the domain","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"zmax = FT(0)\nzmin = FT(-1.1)\nnelems = 75\nΔ = FT((zmax - zmin) / nelems / 2)\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Download the parameter data. This has been obtained from Table 1b of Infiltration and drainage processes in multi-layered coarse soils Mingbin Huang et. al. Can. J. Soil Sci. (2011) 91: 169\u0001183 doi:10.4141/CJSS09118","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"data_file = ClimaLand.Artifacts.huang_et_al2011_soil_van_genuchten_data();\nparameter_data = readdlm(data_file, ',');","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Our model treats z as increasing in the upwards direction. Values below the surface are negative. Because of this, we convert the (positive-valued) depth of the data into a monotonically increasing z coordinate value. using a negative sign and the reverse function.","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"depth = reverse(-parameter_data[1, :] .* 0.01) # convert to m\nksat = reverse(parameter_data[6, :] .* 1 / 100.0 / 60.0) # convert cm/min to m/s\nvgα = reverse(parameter_data[4, :] .* 100 * 2) # they report αᵈ; αʷ = 2αᵈ. This experiment is for infiltration (wetting).\nvgn = reverse(parameter_data[5, :])\nresidual_frac = reverse(parameter_data[2, :])\nporosity = reverse(parameter_data[3, :]);","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Create fields corresponding to the parameter","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"ν = SpaceVaryingInput(depth, porosity, soil_domain.space.subsurface)\nK_sat = SpaceVaryingInput(depth, ksat, soil_domain.space.subsurface)\nθ_r = SpaceVaryingInput(depth, residual_frac, soil_domain.space.subsurface);","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"The specific storativity is not something we have data on, so we approximate it as being constant in depth, and create the parameter field directly:","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"S_s = ClimaCore.Fields.zeros(soil_domain.space.subsurface) .+ 1e-3;","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"The retention model is a vanGenuchten model with α and n as a function of depth, read from the data:","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"hcm = SpaceVaryingInput(\n    depth,\n    (; α = vgα, n = vgn),\n    soil_domain.space.subsurface,\n    vanGenuchten{FT},\n);","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"The parameter struct:","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"params = ClimaLand.Soil.RichardsParameters(;\n    ν = ν,\n    hydrology_cm = hcm,\n    K_sat = K_sat,\n    S_s = S_s,\n    θ_r = θ_r,\n);","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"From here on out, everything should look familiar if you've already gone through the other soil tutorials. Set Boundary conditions: At the top, we use the observed value of Ksat at the top of the domain. Setting the flux to be -Ksat is approximating the top as saturated.","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"function top_flux_function(p, t)\n    return -0.0001033\nend\ntop_bc = ClimaLand.Soil.WaterFluxBC(top_flux_function)\nbottom_bc = ClimaLand.Soil.FreeDrainage()\nboundary_fluxes = (; top = top_bc, bottom = bottom_bc)\nsoil = Soil.RichardsModel{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = (),\n);","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Initial the state vectors, and set initial conditions","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Y, p, cds = initialize(soil);","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Initial conditions","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Y.soil.ϑ_l .= 0.0353; # read from Figure 4 of Huang et al.","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"We also set the initial conditions of the auxiliary state here:","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"set_initial_cache! = make_set_initial_cache(soil)\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"Timestepping:","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"stepper = CTS.ARS111()\n@assert FT in (Float32, Float64)\nerr = (FT == Float64) ? 1e-8 : 1e-4\nconvergence_cond = CTS.MaximumError(err)\nconv_checker = CTS.ConvergenceChecker(norm_condition = convergence_cond)\node_algo = CTS.IMEXAlgorithm(\n    stepper,\n    CTS.NewtonsMethod(\n        max_iters = 10,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n        convergence_checker = conv_checker,\n    ),\n)\nexp_tendency! = make_exp_tendency(soil)\nimp_tendency! = make_imp_tendency(soil)\njacobian! = make_jacobian(soil)\n\njac_kwargs = (; jac_prototype = ImplicitEquationJacobian(Y), Wfact = jacobian!)\nprob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n)\nsaveat = [0.0, 8.0, 16.0, 24.0, 32.0, 40.0, 60.0] .* 60 # chosen to compare with data in plots in paper\nsol = SciMLBase.solve(prob, ode_algo; dt = dt, saveat = saveat);\n\nz = parent(ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z)\nϑ_l = [parent(sol.u[k].soil.ϑ_l) for k in 1:length(sol.t)]\nplot(ϑ_l[1], z, label = \"initial\", color = \"grey\", aspect_ratio = 0.8)\nplot!(ϑ_l[2], z, label = \"8min\", color = \"orange\")\nplot!(ϑ_l[3], z, label = \"16min\", color = \"red\")\nplot!(ϑ_l[4], z, label = \"24min\", color = \"teal\")\nplot!(ϑ_l[5], z, label = \"32min\", color = \"blue\")\nplot!(ϑ_l[6], z, label = \"40min\", color = \"purple\")\nplot!(ϑ_l[7], z, label = \"60min\", color = \"green\")\nscatter!(porosity, depth, label = \"Porosity\")\nplot!(legend = :bottomright)\n\nplot!(xlim = [0, 0.7])\n\nplot!(\n    ylim = [-1.1, 0],\n    yticks = [-1.1, -1, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1],\n)\n\nplot!(ylabel = \"Depth (m)\")\n\nplot!(xlabel = \"Volumeteric Water Content\")\n\nsavefig(\"./sv62_alpha_2_inf_updated_data_climaland.png\")","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"\"/home/runner/work/ClimaLand.jl/ClimaLand.jl/docs/src/generated/standalone/Soil/sv62_alpha_2_inf_updated_data_climaland.png\"","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"","category":"page"},{"location":"generated/standalone/Soil/layered_soil/","page":"Layered Soil","title":"Layered Soil","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/canopy/Canopy/#Canopy","page":"Canopy Models","title":"Canopy","text":"","category":"section"},{"location":"APIs/canopy/Canopy/","page":"Canopy Models","title":"Canopy Models","text":"CurrentModule = ClimaLand.Canopy","category":"page"},{"location":"APIs/canopy/Canopy/#Canopy-Model-Structs","page":"Canopy Models","title":"Canopy Model Structs","text":"","category":"section"},{"location":"APIs/canopy/Canopy/","page":"Canopy Models","title":"Canopy Models","text":"ClimaLand.Canopy.CanopyModel\nClimaLand.Canopy.SharedCanopyParameters","category":"page"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.CanopyModel","page":"Canopy Models","title":"ClimaLand.Canopy.CanopyModel","text":" CanopyModel{FT, AR, RM, PM, SM, PHM, EM, SM, A, R, S, PS, D} <: ClimaLand.AbstractImExModel{FT}\n\nThe model struct for the canopy, which contains\n\nthe canopy model domain (a point for site-level simulations, or\n\nan extended surface (plane/spherical surface) for regional or global simulations.\n\nsubcomponent model type for radiative transfer. This is of type\n\nAbstractRadiationModel.\n\nsubcomponent model type for photosynthesis. This is of type\n\nAbstractPhotosynthesisModel, and currently only the FarquharModel is supported.\n\nsubcomponent model type for stomatal conductance. This is of type\n\nAbstractStomatalConductanceModel and currently only the MedlynModel is supported\n\nsubcomponent model type for plant hydraulics. This is of type\n\nAbstractPlantHydraulicsModel and currently only a version which prognostically solves Richards equation in the plant is available.\n\nsubcomponent model type for canopy energy. This is of type\n\nAbstractCanopyEnergyModel and currently we support a version where   the canopy temperature is prescribed, and one where it is solved for   prognostically.\n\nsubcomponent model type for canopy SIF. prognostically.\ncanopy model parameters, which include parameters that are shared\n\nbetween canopy model components or those needed to compute boundary fluxes.\n\nThe boundary conditions, which contain:\nThe atmospheric conditions, which are either prescribed (of type PrescribedAtmosphere) or computed via a coupled simulation (of type CoupledAtmosphere).\nThe radiative flux conditions, which are either prescribed (of type PrescribedRadiativeFluxes) or computed via a coupled simulation (of type CoupledRadiativeFluxes).\nThe ground conditions, which are either prescribed or prognostic\n\nNote that the canopy height is specified as part of the PlantHydraulicsModel, along with the area indices of the leaves, roots, and stems. Eventually, when plant biomass becomes a prognostic variable (by integrating with a carbon model), some parameters specified here will be treated differently.\n\nautotrophic_respiration: Autotrophic respiration model, a canopy component model\nradiative_transfer: Radiative transfer model, a canopy component model\nphotosynthesis: Photosynthesis model, a canopy component model\nconductance: Stomatal conductance model, a canopy component model\nhydraulics: Plant hydraulics model, a canopy component model\nenergy: Energy balance model, a canopy component model\nsif: SIF model, a canopy component model\nboundary_conditions: Boundary Conditions\nparameters: Shared canopy parameters between component models\ndomain: Canopy model domain\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.SharedCanopyParameters","page":"Canopy Models","title":"ClimaLand.Canopy.SharedCanopyParameters","text":"SharedCanopyParameters{FT <: AbstractFloat, PSE}\n\nA place to store shared parameters that are required by multiple canopy components.\n\nz_0m: Roughness length for momentum (m)\nz_0b: Roughness length for scalars (m)\nearth_param_set: Earth param set\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Canopy/#Canopy-Model-Fluxes","page":"Canopy Models","title":"Canopy Model Fluxes","text":"","category":"section"},{"location":"APIs/canopy/Canopy/","page":"Canopy Models","title":"Canopy Models","text":"ClimaLand.Canopy.DiagnosticTranspiration","category":"page"},{"location":"APIs/canopy/Canopy/#ClimaLand.Canopy.PlantHydraulics.DiagnosticTranspiration","page":"Canopy Models","title":"ClimaLand.Canopy.PlantHydraulics.DiagnosticTranspiration","text":"DiagnosticTranspiration{FT} <: AbstractTranspiration{FT}\n\nA concrete type used for dispatch in the case where transpiration is computed diagnostically, as a function of prognostic variables and parameters, and stored in p during the update_aux! step.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Canopy/#Canopy-Model-Soil-Drivers","page":"Canopy Models","title":"Canopy Model Soil Drivers","text":"","category":"section"},{"location":"APIs/canopy/Canopy/","page":"Canopy Models","title":"Canopy Models","text":"ClimaLand.Canopy.AbstractSoilDriver\nClimaLand.Canopy.PrescribedSoil","category":"page"},{"location":"generated/standalone/Soil/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Soil/boundary_conditions/#Boundary-conditions-for-the-soil-model","page":"Boundary conditions","title":"Boundary conditions for the soil model","text":"","category":"section"},{"location":"generated/standalone/Soil/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"In general, you must supply two boundary conditions for each PDE being solved. These are passed to the model as a NamedTuple of the form (; top = top_bc, bottom = bottom_bc), where both top_bc and bottom_bc are of type ClimaLand.AbstractBC.","category":"page"},{"location":"generated/standalone/Soil/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Flux boundary conditions are always passed as the (scalar) z-component of the flux f, i.e. F⃗ = f ẑ.","category":"page"},{"location":"generated/standalone/Soil/boundary_conditions/#Boundary-conditions-for-Richards-equation","page":"Boundary conditions","title":"Boundary conditions for Richards equation","text":"","category":"section"},{"location":"generated/standalone/Soil/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"FreeDrainage <: AbstractWaterBC: this only can be used at the bottom of the domain.\nWaterFluxBC <: AbstractWaterBC: this accepts a prescribed analytic function of the cache p and simulation time t which returns the flux value. e.g: WaterFluxBC((p,t) -> 0.0).\nMoistureStateBC <: AbstractWaterBC: this accepts a prescribed analytic function of the cache p and simulation time t which returns the value of ϑ_l at the boundary . e.g: MoistureStateBC((p,t) -> 0.2).\nRichardsAtmosDrivenFluxBC <: AbstractWaterBC: this requires a single argument of abstract type AbstractTimeVaryingInput. Under the hood, this specifies the precipitation as a function of space and time (using data read in from a file, or an analytic function) and applies this a flux BC, optionally accounting for surface/subsurface runoff.","category":"page"},{"location":"generated/standalone/Soil/boundary_conditions/#Boundary-conditions-for-the-soil-heat-equation","page":"Boundary conditions","title":"Boundary conditions for the soil heat equation","text":"","category":"section"},{"location":"generated/standalone/Soil/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"HeatFluxBC <: AbstractHeatBC: this accepts a prescribed analytic function of the cache p and simulation time t which returns the flux value. e.g: HeatFluxBC((p,t) -> 0.0).\nTemperatureStateBC <: AbstractHeatBC: this accepts a prescribed analytic function of the cache p and simulation time t which returns the value of T at the boundary . e.g: TemperatureStateBC((p,t) -> 273.15).","category":"page"},{"location":"generated/standalone/Soil/boundary_conditions/#Boundary-conditions-for-the-soil-heat-water-equations-(EnergyHydrology-model)","page":"Boundary conditions","title":"Boundary conditions for the soil heat + water equations (EnergyHydrology model)","text":"","category":"section"},{"location":"generated/standalone/Soil/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The full soil model requires boundary conditions for both Richards equation and the soil heat equation.","category":"page"},{"location":"generated/standalone/Soil/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"WaterHeatBC <: AbstractEnergyHydrologyBC: In many cases, the two boundary conditions can be treated independently. The WaterHeatBC requires a boundary condition of abstract type AbstractWaterBC and one of type AbstractHeatBC, for example, top = WaterHeatBC(; water = MoistureBC(ϑ_l(p,t)), heat = TemperatureBC(T(p,t))).\nAtmosDrivenFluxBC <: AbstractEnergyHydrologyBC: This is an example of a set of boundary conditions for the full soil model which cannot be decomposed into two independent boundary conditions for water and heat. In this case, we compute the turbulent surface fluxes with the atmosphere, obtaining a sensible heat, latent heat, and water vapor flux. We also take into account the net radiation at the surface and any precipitation or runoff. This is the BC type used in most land simulations.","category":"page"},{"location":"generated/standalone/Soil/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"page"},{"location":"generated/standalone/Soil/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"folderstructure/#ClimaLand-folder-structure","page":"Repository structure","title":"ClimaLand folder structure","text":"","category":"section"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"ClimaLand home directory has 5 main folders:","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"docs: contains files to generate the documentation website.\nexperiments: contains simple runs of ClimaLand models. \nparameters: contains a file to retrieve constants such as avogadro's number, the speed of light, etc. \nsrc: contains the code of ClimaLand models. \ntest: contains unit tests, which are meant to ensure small pieces of ClimaLand source code work as intended before merging pull requests.","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"and 3 GitHub actions folders. GitHub actions are .yml files, which are bash scripts that runs on a remote computer on each git push. ","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":".buildkite: contains a script building outputs such as figures from experiments and tests folders. These runs are carried out as part of CI and must run without error in order to merge a PR. \n.dev: contains useful tools for developers, such as a format checker for Julia (which is run as part of CI and must pass before a PR can be merged into main). \n.github: contains various scripts, for example, this documentation website is built each time a change is push to ClimaLand. ","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"as well as 5 files:","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":".gitignore: commonly used git file, contains files, files type, and folders that should be ignored by git. \nLICENSE: License file of ClimaLand, you can read it to learn about legal practice regarding use of ClimaLand open source code. \nProject.toml: The Julia programming language requires a Project.toml file to create an environment, which specify dependencies of a project as well as its version, name, authors and a unique identifier number (uuid). Every Julia registered package has a Project.toml file. \nREADME.md: This markdown file contains the info that you can read on ClimaLand GitHub web page","category":"page"},{"location":"folderstructure/#/docs-folder","page":"Repository structure","title":"/docs folder","text":"","category":"section"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"Julia packages are recommended to have a \\docs folder that builds a standardised documentation following the official documentation generator for Julia: Documenter.jl.","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"The folder /docs contains:","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"a /src folder: It is recommended to put your markdown pages inside this folder. Each markdown file (.md extension text file) is a page accessible through the menu of the documentation. For example, docs/src/Contributing.md contains the text you can read on the documentation \"contribution guide\" menu. The path to this .md file and the name of the menu is set in the docs/make.jl file. \na make.jl file: This Julia file contains your documentation website structure. Running this file will build your website pages, you can run it locally, but it is commonly built remotely via .github/workflows/docs.yml to generate the github static page hosted on the gh-pages branch. ","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"Note: the documentation can have submenu. For example, APIs have submenu ClimaLand which has many submenu... This structure is built in our current framework via a file docs/list_of_apis.jl in that example, which is then included in docs/make.jl.   ","category":"page"},{"location":"folderstructure/#/experiments-folder","page":"Repository structure","title":"/experiments folder","text":"","category":"section"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"The experiments folder contains scripts to run ClimaLand models. It contains a folder for integrated models and a folder for standalone models. It is meant to provide users with simple examples of ClimaLand runs. The files contains meteorological inputs (such as precipitation), values for every parameters, and the domains and timestepper are specified. ","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"For example, /experiments/LSM/ozark/ contains:","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"ozark_domain.jl: Describes the soil domain (depth, number of layer), and the canopy (number and height of stems and leaves).\nozarkmetdrivers_FLUXNET.jl: This files load meteorological input data from the ozark FLUXNET file, and does additional things such as spline interpolation of these drivers.\nozark_parameters.jl: In this file, parameters values are defined. \nozark_simulation.jl: In this file, initial and final time are set, as well as time resolution and time stepper algorithm. \nozark.jl: running this script will include all the above scripts, and run ClimaLand for the single-site ozark. It will produce output in a text file as well as some figures comparing data and simulation.","category":"page"},{"location":"folderstructure/#/src-folder","page":"Repository structure","title":"/src folder","text":"","category":"section"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"The /src folder contains the source code of ClimaLand models. It contains 3 folders:","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"sharedutilities: This is a core folder that defines functions and data structures used across all modules and models types of ClimaLand. For example, `sharedutilities/models.jldefines and export the functionmakeupdateauxwhich will be used to create a function which updates the auxiliary parameters, stored in the vectorp,sharedutilities/boundaryconditions.jl` defines functions for setting boundary condition for PDE domains, etc.\nstandalone: This folder contains standalone models, which are submodels that can be run independently of each other. This is an important aspect of ClimaLand code design: to maximize modularity, sub-models can be run alone, and many different methods of the same sub-model can be defined via Julia multiple dispatch. The standalone folder is independent from the integrated folder. \nintegrated: This folder contains integrated models. It assembles standalone models together, as one would assemble pieces of a puzzle. Thanks to the modularity of ClimaLand design, many configuration of LSM can be assembled in integrated models. The same functions (update_aux!, exp_tendency!, etc.) can be used for standalone and integrated models, and an can be stepped  in the same way.","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"As well as one file:","category":"page"},{"location":"folderstructure/","page":"Repository structure","title":"Repository structure","text":"ClimaLand.jl: This file is the main Julia module of ClimaLand.jl repository. It contains all functions defined in /src in a nested way, for example ClimaLand.X, ClimaLand.Soil.X, 'ClimaLand.Canopy.X, etc. When a Julia user install and uses ClimaLand via]add ClimaLand, using ClimaLand`, they are loading those functions, and are ready to use ClimaLand codebase. ","category":"page"},{"location":"APIs/canopy/StomatalConductance/#Stomatal-Conductance","page":"Canopy Stomatal Conductance","title":"Stomatal Conductance","text":"","category":"section"},{"location":"APIs/canopy/StomatalConductance/","page":"Canopy Stomatal Conductance","title":"Canopy Stomatal Conductance","text":"CurrentModule = ClimaLand.Canopy","category":"page"},{"location":"APIs/canopy/StomatalConductance/#Parameters","page":"Canopy Stomatal Conductance","title":"Parameters","text":"","category":"section"},{"location":"APIs/canopy/StomatalConductance/","page":"Canopy Stomatal Conductance","title":"Canopy Stomatal Conductance","text":"ClimaLand.Canopy.MedlynConductanceParameters","category":"page"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.MedlynConductanceParameters","page":"Canopy Stomatal Conductance","title":"ClimaLand.Canopy.MedlynConductanceParameters","text":"MedlynConductanceParameters{FT <: AbstractFloat}\n\nThe required parameters for the Medlyn stomatal conductance model.\n\nDrel: Relative diffusivity of water vapor (unitless)\ng0: Minimum stomatal conductance mol/m^2/s\ng1: Slope parameter, inversely proportional to the square root of marginal water use efficiency (Pa^{1/2})\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/StomatalConductance/#Methods","page":"Canopy Stomatal Conductance","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/StomatalConductance/","page":"Canopy Stomatal Conductance","title":"Canopy Stomatal Conductance","text":"ClimaLand.Canopy.medlyn_term\nClimaLand.Canopy.medlyn_conductance\nClimaLand.Canopy.upscale_leaf_conductance\nClimaLand.Canopy.penman_monteith","category":"page"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.medlyn_term","page":"Canopy Stomatal Conductance","title":"ClimaLand.Canopy.medlyn_term","text":"medlyn_term(g1::FT, T_air::FT, P_air::FT, q_air::FT, thermo_params) where {FT}\n\nComputes the Medlyn term, equal to 1+g1/sqrt(VPD), by first computing the VPD, where VPD is the vapor pressure deficit in the atmosphere (Pa), and g_1 is a constant with units of sqrt(Pa).\n\nthermo_params is the Thermodynamics.jl parameter set.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.medlyn_conductance","page":"Canopy Stomatal Conductance","title":"ClimaLand.Canopy.medlyn_conductance","text":"medlyn_conductance(g0::FT,\n                   Drel::FT,\n                   medlyn_term::FT,\n                   An::FT,\n                   ca::FT) where {FT}\n\nComputes the stomatal conductance according to Medlyn, as a function of the minimum stomatal conductance (g0), the relative diffusivity of water vapor with respect to CO2 (Drel), the Medlyn term (unitless), the biochemical demand for CO2 (An), and the atmospheric concentration of CO2 (ca).\n\nThis returns the conductance in units of mol/m^2/s. It must be converted to m/s using the molar density of water prior to use in SurfaceFluxes.jl.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.upscale_leaf_conductance","page":"Canopy Stomatal Conductance","title":"ClimaLand.Canopy.upscale_leaf_conductance","text":"upscale_leaf_conductance(gs::FT, LAI::FT, T::FT, R::FT, P::FT) where {FT}\n\nThis currently takes a leaf conductance (moles per leaf area per second) and (1) converts it to m/s, (2) upscales to the entire canopy, by assuming the leaves in the canopy are in parallel and hence multiplying by LAI.\n\nTODO: Check what CLM does, and check if we can use the same function for GPP from An, and make more general.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/StomatalConductance/#ClimaLand.Canopy.penman_monteith","page":"Canopy Stomatal Conductance","title":"ClimaLand.Canopy.penman_monteith","text":"penman_monteith(\n    Δ::FT, # Rate of change of saturation vapor pressure with air temperature. (Pa K−1)\n    Rn::FT, # Net irradiance (W m−2)\n    G::FT, # Ground heat flux (W m−2)\n    ρa::FT, # Dry air density (kg m−3)\n    cp::FT, # Specific heat capacity of air (J kg−1 K−1)\n    VPD::FT, # vapor pressure deficit (Pa)\n    ga::FT, # atmospheric conductance (m s−1)\n    γ::FT, # Psychrometric constant (γ ≈ 66 Pa K−1)\n    gs::FT, # surface or stomatal conductance (m s−1)\n    Lv::FT, # Volumetric latent heat of vaporization (J m-3)\n    ) where {FT}\n\nComputes the evapotranspiration in m/s using the Penman-Monteith equation.\n\n\n\n\n\n","category":"function"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/#Domain-Tutorial","page":"Intro to ClimaLand Domains","title":"Domain Tutorial","text":"","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/#Goals-of-the-tutorial","page":"Intro to ClimaLand Domains","title":"Goals of the tutorial","text":"","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"The goal of this is to outline what is currently implemented in ClimaLand and to serve as a software design document for future development involving the underlying domains.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/#Background","page":"Intro to ClimaLand Domains","title":"Background","text":"","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"In both the atmosphere and the ocean, all variables are defined at all locations in the region of interest, or domain.  For example, the air density, temperature, pressure, and wind speed are defined everywhere in the domain. After choosing a resolution and discretizing space, the numerical problem is to advance a system of differential equations, where at each coordinate point a value of ρ, T, P, and u⃗ are solved for at each step. The choice of domain is a question \"only\" of geometry: you may be interested in a large eddy simulation (using a box domain), or in a global model (where you would need a spherical shell domain representing the atmosphere or ocean from some depth to z_sfc = 0).","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"For land surface models, each variable is not defined everywhere in space. For example, the soil water content θ is only defined below ground. Snow water equivalent (S) is only defined on the surface itself. Canopy variables are only defined above ground. Once we have discretized the land surface region into a set of points, the numerical problem is to advance a system of ODEs, where at each coordinate point a different subset of (θ, S, ...) are solved for.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"In other words, different variables in land surface models exist in different, overlapping, domains. We need to decide on the geometry of interest (e.g. single column vs a global simulation), but we also need to specify where each variable of the model is defined.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"ClimaLand Domains were designed with this in mind. The domains are defined so that","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"the user can easily switch geometries, e.g. single column to global model,\nindividual component models can be run by themselves, using a single domain,\nthe same domains can be used to set up multi-component models (LSMs),\ndifferent variables can exist on different parts of the domain.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/#What-is-a-ClimaLand-Domain?","page":"Intro to ClimaLand Domains","title":"What is a ClimaLand Domain?","text":"","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"A domain represents a region of space. In ClimaLand, domains are simply structs containing parameters that define these regions - for example an x-range and y-range that define a plane. In addition, ClimaLand domains store the ClimaCore function spaces for the physical domain as a NamedTuple. When solving partial differential equations, the spatial discretization is tied to a set of basis functions you wish to use to represent the prognostic variable as a function of space. The nodal points - the locations in space where the variable is solved for - are arranged in space in a manner which depends on these basis functions. Note that these spaces are only mathematically needed when your variables satisfy PDEs[1], but that they still exist when your variables do not, because we are using the same underlying infrastructure in both cases.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/#Domain-types","page":"Intro to ClimaLand Domains","title":"Domain types","text":"","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"All ClimaLand domains are subtypes of abstract type ClimaLand.Domains.AbstractDomain. A variety of concrete domain types are supported:","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"0D: Domains.Point\n1D: Domains.Column\n2D: Domains.Plane, Domains.SphericalSurface\n3D: Domains.HybridBox, Domains.SphericalShell.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"As discussed above, our modeling requires that variables of a model can be defined on different subsets of the domain. Because of that, we define the concept of a surface domain, and a subsurface domain. Not all domains have a surface and subsurface; some only have surface domains, as shown in the Table below.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"Domain Surface Domain Subsurface Domain\nColumn Point Column\nHybridBox Plane HybridBox\nSphericalShell SphericalSurface SphericalShell","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"There is a single key method which take a ClimaLand domain as an argument.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"coordinates(domain): under the hood, this function  uses","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"the NamedTuple of function spaces (domain.space) to create the coordinate field for the surface and subsurface domains (as applicable), stored in a NamedTuple. Depending on the domain, the returned coordinate field will have elements of different names and types. For example, the SphericalShell domain has subsurface coordinates of latitude, longitude, and depth, while the surface coordinates are latitude and longitude. A Plane domain has coordinates of x and y (surface only), and a Point domain only has a coordinate zsfc (surface only). Column domains have a surface coordinate of zsfc, and subsurface coordinates of z.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"It is important to note that the horizontal domain used for the surface and subsurface domains are identical in all simulations. This ensures that we can use the same indexing of surface and subsurface domains and variables. Otherwise we would need to develop additional infrastructure in order to, for example, select the correct subsurface column corresponding to a particular surface location.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/#How-variable-initialization-depends-on-domains","page":"Intro to ClimaLand Domains","title":"How variable initialization depends on domains","text":"","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"Single component models (soil, snow, vegetation, canopy...) must have an associated domain in order to solve the their equations.  Which domain is appropriate depends on the model equations and on the configuration of interest (single column or global, etc.). For example, the soil model is a vertically resolved model, so only domains with a vertical extent (Column, HybridBox, or SphericalShell) make sense to use. A single layer snow model does not require vertical resolution - and so the domains that make sense to use are a Point, Plane, or SphericalSurface.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"When a developer first defines a model, they need to specify the symbols used for the prognostic variables, via prognostic_vars, and the types of those variables,  via prognostic_types.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"They additionally need to define which subset of the domain the variables are defined on, using prognostic_domain_names.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"The initialize function (which calls both initialize_prognostic  and initialize_auxiliary) creates the prognostic state vector Y (a ClimaCore.Fields.FieldVector). Each field (ClimaCore.Fields.Field) stored within the field vector corresponds to a prognostic variable (identified with the symbol specified). If the prognostic type for that variable is a float, the field will be a field of float values (a scalar field)[4].","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"How do domains tie into this? The field of a prognostic variable corresponds in a 1-1 fashion with the coordinate field of the subset of the domain associated with that variable via prognostic_domain_name.  For example, the bucket model has a vertically resolved temperature T, but the bucket water content W is not vertically resolved. If your domain is a Column, the subsurface coordinates may be [-4.5,-3.5,-2.5,-1.5, -0.5], and the surface coordinate would be [-0.0]. Your prognostic variable field for T will be [T[-4.5], T[-3.5]; T[-2.5], T[-1.5], T[-0.5]], and for W  it will be [W[0.0],]. Your variable always has the same spatial resolution as the associated subset of the domain.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"This functionality is not required for every standalone component model. For example, a single layer snow model will only have variables on the surface of the domain (which in this case, would be the entire Point, Plane, or SphericalShell domain). The user still must define the prognosticdomainnames method. This functionality is required for most multi-component models.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/#Future-work","page":"Intro to ClimaLand Domains","title":"Future work","text":"","category":"section"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"Almost all interactions between variables in land surface models are within column - that is, there is only vertical transport and exchanges. The exception to this is the horizontal flow of water on the surface and within the soil. The tendency (produced by make_exp_tendency and make_imp_tendency) functions (the ODE functions) can be split into \"vertical\" and \"horizontal\" pieces.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"We envision each step of the land surface model simulation to be solved  in two steps: (1) the vertical tendency evaluations are carried out (and can be parallelized), and (2) the horizontal tendency functions are then evaluated (possibly less frequently?) and require communication between columns. In this case, tendency functions will need to be aware of the domain. In general, tendencies reflecting horizontal flow will be treated explicitly and include in the explicit tendency function. Tendencies reflecting vertical flow may be treated explicitly or implicitly depending on the use case. To solve the problem, we then use IMEX (mixed explicit/implicit) methods.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"[1]: finite differencing is used in the vertical, and spectral elements are used in the horizontal.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"[2]: a suprasurface region may also be necessary - for example if the canopy airspace model involves PDEs.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"[3]: We also will support having an array-like type of variable.","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"","category":"page"},{"location":"generated/standalone/Usage/domain_tutorial/","page":"Intro to ClimaLand Domains","title":"Intro to ClimaLand Domains","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../..\"","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/#Coupling-the-CliMA-Canopy-and-Soil-Hydraulics-Models","page":"Coupled Canopy and Soil","title":"Coupling the CliMA Canopy and Soil Hydraulics Models","text":"","category":"section"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"In the previous tutorial, we demonstrated how to run the canopy model in standalone mode using prescribed values for the inputs of soil hydraulics into the canopy hydraulics model. However, ClimaLand has the built-in capacity to couple the canopy model with a soil physics model and timestep the two simulations together to model a canopy-soil system. This tutorial demonstrates how to setup and run a coupled simulation, again using initial conditions, atmospheric and radiative flux conditions, and canopy properties observed at the US-MOz flux tower, a flux tower located within an oak-hickory forest in Ozark, Missouri, USA. See Wang et al. 2021 for details on the site and parameters.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"In ClimaLand, the coupling of the canopy and soil models is done by pairing the inputs and outputs which between the two models so that they match. For example, the root extraction of the canopy hydraulics model, which acts as a boundary flux for the plant system, is paired with a source term for root extraction in the soil model, so that the flux of water from the soil into the roots is equal and factored into both models. This pairing is done automatically in the constructor for a SoilCanopyModel so that a user needs only specify the necessary arguments for each of the component models, and the two models will automatically be paired into a coupled simulation.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/#Preliminary-Setup","page":"Coupled Canopy and Soil","title":"Preliminary Setup","text":"","category":"section"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Load External Packages:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"import SciMLBase\nusing Plots\nusing Statistics\nusing Dates\nusing Insolation","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Load CliMA Packages and ClimaLand Modules:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"using ClimaCore\nimport ClimaParams as CP\nimport ClimaTimeSteppers as CTS\nusing ClimaLand\nusing ClimaLand.Domains: Column, obtain_surface_domain\nusing ClimaLand.Soil\nusing ClimaLand.Soil.Biogeochemistry\nusing ClimaLand.Canopy\nusing ClimaLand.Canopy.PlantHydraulics\nimport ClimaLand\nimport ClimaLand.Parameters as LP","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Define the floating point precision desired (64 or 32 bit), and get the parameter set holding constants used across CliMA Models:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"const FT = Float32;\nearth_param_set = LP.LandParameters(FT);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Setup the domain for the model:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"nelements = 10\nzmin = FT(-2)\nzmax = FT(0)\nf_root_to_shoot = FT(3.5)\nSAI = FT(0.00242)\nmaxLAI = FT(4.2)\nplant_ν = FT(2.46e-4)\nn_stem = Int64(1)\nn_leaf = Int64(1)\nh_stem = FT(9)\nh_leaf = FT(9.5)\ncompartment_midpoints = [h_stem / 2, h_stem + h_leaf / 2]\ncompartment_surfaces = [zmax, h_stem, h_stem + h_leaf]\nland_domain = Column(; zlim = (zmin, zmax), nelements = nelements);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"We will be using prescribed atmospheric and radiative drivers from the US-MOz tower, which we read in here. We are using prescribed atmospheric and radiative flux conditions, but it is also possible to couple the simulation with atmospheric and radiative flux models. We also","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"read in the observed LAI and let that vary in time in a prescribed manner.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Use the data tools for reading FLUXNET data sets","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"include(\n    joinpath(pkgdir(ClimaLand), \"experiments/integrated/fluxnet/data_tools.jl\"),\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"First provide some information about the site Timezone (offset from UTC in hrs)","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"time_offset = 7","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"7","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Site latitude and longitude","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"lat = FT(38.7441) # degree\nlong = FT(-92.2000) # degree","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"-92.2f0","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Height of the sensor at the site","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"atmos_h = FT(32) # m","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"32.0f0","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Provide the site site ID and the path to the data file:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"site_ID = \"US-MOz\"\ndata_link = \"https://caltech.box.com/shared/static/7r0ci9pacsnwyo0o9c25mhhcjhsu6d72.csv\"\n\ninclude(\n    joinpath(\n        pkgdir(ClimaLand),\n        \"experiments/integrated/fluxnet/met_drivers_FLUXNET.jl\",\n    ),\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"[ Info: Warning: Data for TA_F 0.719% poor quality. Returning with no replacement.\n[ Info: Warning: Data for VPD_F 0.719% poor quality. Returning with no replacement.\n[ Info: Warning: Data for PA_F 0.00571% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for P_F 0.0% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for WS_F 0.00571% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for LW_IN_F 0.0% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for SW_IN_F 0.0114% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for G_F_MDS 0.00571% poor quality. Filled with mean value using QC flag\n[ Info: Information: Data for GPP_DT_VUT_REF is complete and no QC flag present\n[ Info: Information: Data for LE_CORR is complete and no QC flag present\n[ Info: Information: Data for H_CORR is complete and no QC flag present\n[ Info: Warning: Data for LW_OUT 0.00571% has value of -9999. Filled with mean value\n[ Info: Warning: Data for SW_OUT 0.131% has value of -9999. Filled with mean value\n[ Info: Warning: Data for SWC_F_MDS_1 0.0571% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for TS_F_MDS_1 0.0% poor quality. Filled with mean value using QC flag\n[ Info: Warning: Data for CO2_F_MDS 0.0457% poor quality. Filled with mean value using QC flag\n","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/#Setup-the-Coupled-Canopy-and-Soil-Physics-Model","page":"Coupled Canopy and Soil","title":"Setup the Coupled Canopy and Soil Physics Model","text":"","category":"section"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"We want to simulate the canopy-soil system together, so the model type SoilCanopyModel is chosen. From the linked documentation, we see that we need to provide the soil model type and arguments as well as the canopy model component types, component arguments, and the canopy model arguments, so we first need to initialize all of these.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"For our soil model, we will choose the EnergyHydrology and set up all the necessary arguments. See the tutorial on the model for a more detailed explanation of the soil model.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Define the parameters for the soil model and provide them to the model parameters struct:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Soil parameters","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"soil_ν = FT(0.5) # m3/m3\nsoil_K_sat = FT(4e-7) # m/s\nsoil_S_s = FT(1e-3) # 1/m\nsoil_vg_n = FT(2.05) # unitless\nsoil_vg_α = FT(0.04) # inverse meters\nθ_r = FT(0.067); # m3/m3","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Soil heat transfer parameters","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"ν_ss_quartz = FT(0.1)\nν_ss_om = FT(0.1)\nν_ss_gravel = FT(0.0);\nz_0m_soil = FT(0.1)\nz_0b_soil = FT(0.1)\nsoil_ϵ = FT(0.98)\nsoil_α_PAR = FT(0.2)\nsoil_α_NIR = FT(0.4)\n\nsoil_domain = land_domain\nsoil_ps = Soil.EnergyHydrologyParameters(\n    FT;\n    ν = soil_ν,\n    ν_ss_om = ν_ss_om,\n    ν_ss_quartz = ν_ss_quartz,\n    ν_ss_gravel = ν_ss_gravel,\n    hydrology_cm = vanGenuchten{FT}(; α = soil_vg_α, n = soil_vg_n),\n    K_sat = soil_K_sat,\n    S_s = soil_S_s,\n    θ_r = θ_r,\n    earth_param_set = earth_param_set,\n    z_0m = z_0m_soil,\n    z_0b = z_0b_soil,\n    emissivity = soil_ϵ,\n    PAR_albedo = soil_α_PAR,\n    NIR_albedo = soil_α_NIR,\n);\n\nsoil_args = (domain = soil_domain, parameters = soil_ps)\nsoil_model_type = Soil.EnergyHydrology{FT}","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"ClimaLand.Soil.EnergyHydrology{Float32}","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"For the heterotrophic respiration model, see the documentation to understand the parameterisation. The domain is defined similarly to the soil domain described above.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"soilco2_type = Soil.Biogeochemistry.SoilCO2Model{FT}\n\nsoilco2_ps = SoilCO2ModelParameters(FT);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"soil microbes args","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Csom = ClimaLand.PrescribedSoilOrganicCarbon{FT}(TimeVaryingInput((t) -> 5))\n\nsoilco2_top_bc = Soil.Biogeochemistry.AtmosCO2StateBC()\nsoilco2_bot_bc = Soil.Biogeochemistry.SoilCO2StateBC((p, t) -> 0.0);\nsoilco2_sources = (MicrobeProduction{FT}(),);\n\nsoilco2_boundary_conditions = (; top = soilco2_top_bc, bottom = soilco2_bot_bc);\n\nsoilco2_args = (;\n    boundary_conditions = soilco2_boundary_conditions,\n    sources = soilco2_sources,\n    domain = soil_domain,\n    parameters = soilco2_ps,\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Next we need to set up the CanopyModel. For more details on the specifics of this model see the previous tutorial.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Begin by declaring the component types of the canopy model. Unlike in the previous tutorial, collect the arguments to each component into tuples and do not instantiate the component models yet. The constructor for the SoilPlantHydrologyModel will use these arguments and internally instatiate the component CanopyModel and RichardsModel instances. This is done so that the constructor may enforce consistency constraints between the two models, and this must be done internally from the constructor.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"canopy_component_types = (;\n    autotrophic_respiration = Canopy.AutotrophicRespirationModel{FT},\n    radiative_transfer = Canopy.TwoStreamModel{FT},\n    photosynthesis = Canopy.FarquharModel{FT},\n    conductance = Canopy.MedlynConductanceModel{FT},\n    hydraulics = Canopy.PlantHydraulicsModel{FT},\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Then provide arguments to the canopy radiative transfer, stomatal conductance, and photosynthesis models as was done in the previous tutorial.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"autotrophic_respiration_args =\n    (; parameters = AutotrophicRespirationParameters(FT))\n\nradiative_transfer_args = (;\n    parameters = TwoStreamParameters(\n        FT;\n        G_Function = ConstantGFunction(FT(0.5)),\n        α_PAR_leaf = 0.1,\n        α_NIR_leaf = 0.45,\n        τ_PAR_leaf = 0.05,\n        τ_NIR_leaf = 0.25,\n        Ω = 0.69,\n    )\n)\n\nconductance_args = (; parameters = MedlynConductanceParameters(FT; g1 = 141))\n\nis_c3 = FT(1) # set the photosynthesis mechanism to C3\nphotosynthesis_args =\n    (; parameters = FarquharParameters(FT, is_c3; Vcmax25 = FT(5e-5)));\n\nK_sat_plant = FT(1.8e-8)\nRAI = (SAI + maxLAI) * f_root_to_shoot;","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Note: LAIfunction was determined from data in the script we included above.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"ai_parameterization = PrescribedSiteAreaIndex{FT}(LAIfunction, SAI, RAI)\n\nψ63 = FT(-4 / 0.0098)\nWeibull_param = FT(4)\na = FT(0.05 * 0.0098)\n\nconductivity_model =\n    PlantHydraulics.Weibull{FT}(K_sat_plant, ψ63, Weibull_param)\n\nretention_model = PlantHydraulics.LinearRetentionCurve{FT}(a)\n\nplant_ν = FT(0.7)\nplant_S_s = FT(1e-2 * 0.0098)\n\nplant_hydraulics_ps = PlantHydraulics.PlantHydraulicsParameters(;\n    ai_parameterization = ai_parameterization,\n    ν = plant_ν,\n    S_s = plant_S_s,\n    rooting_depth = FT(1.0),\n    conductivity_model = conductivity_model,\n    retention_model = retention_model,\n)\n\nplant_hydraulics_args = (\n    parameters = plant_hydraulics_ps,\n    n_stem = n_stem,\n    n_leaf = n_leaf,\n    compartment_midpoints = compartment_midpoints,\n    compartment_surfaces = compartment_surfaces,\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"We may now collect all of the canopy component argument tuples into one arguments tuple for the canopy component models.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"canopy_component_args = (;\n    autotrophic_respiration = autotrophic_respiration_args,\n    radiative_transfer = radiative_transfer_args,\n    photosynthesis = photosynthesis_args,\n    conductance = conductance_args,\n    hydraulics = plant_hydraulics_args,\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"We also need to provide the shared parameter struct to the canopy.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"z0_m = FT(2)\nz0_b = FT(0.2)\n\nshared_params = SharedCanopyParameters{FT, typeof(earth_param_set)}(\n    z0_m,\n    z0_b,\n    earth_param_set,\n)\ncanopy_domain = obtain_surface_domain(land_domain)\ncanopy_model_args = (; parameters = shared_params, domain = canopy_domain);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"We may now instantiate the integrated plant and soil model. In this example, we will compute transpiration diagnostically, and work with prescribed atmospheric and radiative flux conditions from the observations at the Ozark site as was done in the previous tutorial.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"land_input = (atmos = atmos, radiation = radiation, soil_organic_carbon = Csom)\n\nland = SoilCanopyModel{FT}(;\n    soilco2_type = soilco2_type,\n    soilco2_args = soilco2_args,\n    land_args = land_input,\n    soil_model_type = soil_model_type,\n    soil_args = soil_args,\n    canopy_component_types = canopy_component_types,\n    canopy_component_args = canopy_component_args,\n    canopy_model_args = canopy_model_args,\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"[ Info: Using the PrescribedAtmosphere air temperature as the canopy temperature\n","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Now we can initialize the state vectors and model coordinates, and initialize the explicit/implicit tendencies as usual. The Richard's equation time stepping is done implicitly, while the canopy model may be explicitly stepped, so we use an IMEX (implicit-explicit) scheme for the combined model.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Y, p, coords = initialize(land);\nexp_tendency! = make_exp_tendency(land);\nimp_tendency! = make_imp_tendency(land);\njacobian! = make_jacobian(land);\njac_kwargs =\n    (; jac_prototype = ClimaLand.ImplicitEquationJacobian(Y), Wfact = jacobian!);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"We need to provide initial conditions for the soil and canopy hydraulics models:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Y.soil.ϑ_l = FT(0.4)\nY.soil.θ_i = FT(0.0)\nT_0 = FT(288.7)\nρc_s =\n    volumetric_heat_capacity.(\n        Y.soil.ϑ_l,\n        Y.soil.θ_i,\n        land.soil.parameters.ρc_ds,\n        earth_param_set,\n    )\nY.soil.ρe_int =\n    volumetric_internal_energy.(Y.soil.θ_i, ρc_s, T_0, earth_param_set)\n\nY.soilco2.C .= FT(0.000412) # set to atmospheric co2, mol co2 per mol air\n\nψ_stem_0 = FT(-1e5 / 9800)\nψ_leaf_0 = FT(-2e5 / 9800)\n\nS_l_ini =\n    inverse_water_retention_curve.(\n        retention_model,\n        [ψ_stem_0, ψ_leaf_0],\n        plant_ν,\n        plant_S_s,\n    )\n\nfor i in 1:2\n    Y.canopy.hydraulics.ϑ_l.:($i) .=\n        augmented_liquid_fraction.(plant_ν, S_l_ini[i])\nend;","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Select the timestepper and solvers needed for the specific problem. Specify the time range and dt value over which to perform the simulation.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"t0 = Float64(150 * 3600 * 24)# start mid year\nN_days = 100\ntf = t0 + Float64(3600 * 24 * N_days)\ndt = Float64(30)\nn = 120\nsaveat = Array(t0:(n * dt):tf)\n\ntimestepper = CTS.ARS343()\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Now set the initial values for the cache variables for the combined soil and plant model.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"set_initial_cache! = make_set_initial_cache(land)\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Set the callbacks, which govern how often we save output, and how often we update the forcing data (\"drivers\")","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"sv = (;\n    t = Array{Float64}(undef, length(saveat)),\n    saveval = Array{NamedTuple}(undef, length(saveat)),\n)\nsaving_cb = ClimaLand.NonInterpSavingCallback(sv, saveat)\nmodel_drivers = ClimaLand.get_drivers(land)\nupdatefunc = ClimaLand.make_update_drivers(model_drivers)\nupdateat = Array(t0:1800:tf)\ndriver_cb = ClimaLand.DriverUpdateCallback(updateat, updatefunc)\ncb = SciMLBase.CallbackSet(driver_cb, saving_cb);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Carry out the simulation","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"prob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n);\nsol = SciMLBase.solve(\n    prob,\n    ode_algo;\n    dt = dt,\n    callback = cb,\n    adaptive = false,\n    saveat = saveat,\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/#Plotting","page":"Coupled Canopy and Soil","title":"Plotting","text":"","category":"section"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Now that we have both a soil and canopy model incorporated together, we will show how to plot some model data demonstrating the time series produced from each of these models. As before, we may plot the GPP of the system as well as transpiration showing fluxes in the canopy.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"daily = sol.t ./ 3600 ./ 24\nmodel_GPP = [\n    parent(sv.saveval[k].canopy.photosynthesis.GPP)[1] for\n    k in 1:length(sv.saveval)\n]\n\nplt1 = Plots.plot(size = (600, 700));\nPlots.plot!(\n    plt1,\n    daily,\n    model_GPP .* 1e6,\n    label = \"Model\",\n    xlim = [minimum(daily), maximum(daily)],\n    xlabel = \"days\",\n    ylabel = \"GPP [μmol/mol]\",\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Transpiration plot:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"T = [\n    parent(sv.saveval[k].canopy.energy.turbulent_fluxes.transpiration)[1]\n    for k in 1:length(sv.saveval)\n]\nT = T .* (1e3 * 24 * 3600)\n\nplt2 = Plots.plot(size = (500, 700));\nPlots.plot!(\n    plt2,\n    daily,\n    T,\n    label = \"Model\",\n    xlim = [minimum(daily), maximum(daily)],\n    xlabel = \"days\",\n    ylabel = \"Vapor Flux [mm/day]\",\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Show the two plots together:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Plots.plot(plt1, plt2, layout = (2, 1));","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Save the output:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"savefig(\"ozark_canopy_flux_test.png\");","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"(Image: )","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Now, we will plot the augmented volumetric liquid water fraction at different depths in the soil over the course of the simulation.","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"plt1 = Plots.plot(size = (500, 700));\nϑ_l_10 = [parent(sol.u[k].soil.ϑ_l)[end] for k in 1:1:length(sol.t)]\nplt1 = Plots.plot(\n    daily,\n    ϑ_l_10,\n    label = \"10 cm\",\n    xlabel = \"Days\",\n    ylabel = \"SWC [m/m]\",\n    xlim = [minimum(daily), maximum(daily)],\n    size = (500, 700),\n    margins = 10Plots.mm,\n    color = \"blue\",\n);\n\nplot!(\n    plt1,\n    daily,\n    [parent(sol.u[k].soil.ϑ_l)[end - 1] for k in 1:1:length(sol.t)],\n    label = \"20cm\",\n    color = \"red\",\n);\n\nplot!(\n    plt1,\n    daily,\n    [parent(sol.u[k].soil.ϑ_l)[end - 2] for k in 1:1:length(sol.t)],\n    label = \"30cm\",\n    color = \"purple\",\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"Save the output:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"savefig(\"ozark_soil_test.png\");","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"(Image: )","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"And now to demonstrate the coupling of the soil and canopy models we will plot the water fluxes from the soil up into the plant hydraulic system:","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"root_stem_flux = [\n    sum(sv.saveval[k].root_extraction) .* (1e3 * 3600 * 24) for\n    k in 1:length(sol.t)\n]\nplt1 = Plots.plot(\n    daily,\n    root_stem_flux,\n    label = \"soil-root-stem water flux\",\n    ylabel = \"Water flux[mm/day]\",\n    xlim = [minimum(daily), maximum(daily)],\n    size = (500, 700),\n    margins = 10Plots.mm,\n);","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"And save the output","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"savefig(\"ozark_soil_plant_flux.png\");","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"(Image: )","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"","category":"page"},{"location":"generated/integrated/soil_canopy_tutorial/","page":"Coupled Canopy and Soil","title":"Coupled Canopy and Soil","text":"This page was generated using Literate.jl.","category":"page"},{"location":"diagnostics/developers_diagnostics/#ClimaLand-Diagnostics:-why-and-how","page":"For developers","title":"ClimaLand Diagnostics: why and how","text":"","category":"section"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"ClimaLand simulations generates variables in the integrator state (Y) and cache (p) at each time step. A user will need to use these variables in some form, i.e., access them from a file that contains variables at a given temporal and spatial resolution. The user will also want to retrieve metadata about those variables, such as name and units. This is where ClimaLand diagnostics comes in, it writes simulations variables (in a file, such as NetCDF or HDF5, or in Julia Dict), at a specified spatio-temporal reduction (e.g., hourly averages, monthly max, instantaneous, integrated through soil depth...), along with metadata (e.g., soil temperature short name is t_soil, expressed in \"K\" units). We want to provide users with default options, but also the possibility to define their own variables and reductions.","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"Internally, this is done by using the ClimaDiagnostics.jl package, that provides the functionality to produce a ClimaLand.Diagnostics module in the src/Diagnostics.jl folder. In this folder,","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"Diagnostics.jl defines the module,\ndiagnostic.jl defines ALL_DIAGNOSTICS, a Dict containing all diagnostics variables defined in define_diagnostics.jl, it also defines the function","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"add_diagnostic_variable! which defines a method to add diagnostic variables to ALL_DIAGNOSTICS, finally it contains a function get_diagnostic_variable which returns a  DiagnosticVariable from its short_name, if it exists.","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"define_diagnostics.jl, mentioned above, contains a function define_diagnostics!(land_model) which contains all default diagnostic variables by calling.","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"add_diagnostic_variable!, and dispatch off the type of land_model to define how to compute a diagnostic (for example, surface temperature is computed in p.bucket.T_sfc in the bucket model).","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"compute methods are defined in a separate file, for example, bucket_compute_methods.jl.\nstandard_diagnostic_frequencies.jl defines standard functions to schedule diagnostics, for example, hourly average or monthly max, these functions are called on a list of diagnostic variables. As developers, we can add more standard functions that users may want to have access to easily in this file.\ndefault_diagnostics.jl defines default diagnostics functions to use on a model simulation. For example, default_diagnostics(land_model::BucketModel, output_writer).","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"will return a ScheduledDiagnostics that computes hourly averages for all Bucket variables, along with their metadata, ready to be written on a NetCDF file when running a Bucket simulation.","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"The following section give more details on these functions, along with examples. As developers, we want to extand these functionality as ClimaLand progresses.","category":"page"},{"location":"diagnostics/developers_diagnostics/#Compute-methods","page":"For developers","title":"Compute methods","text":"","category":"section"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"Each model defines all its compute methods in a file (bucket_compute_methods.jl for the bucket model, for example). The structure of a diagnostic variable compute method is, for example:","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"@with_error function compute_albedo!(out, Y, p, t, land_model::BucketModel)\n    if isnothing(out)\n        return copy(p.bucket.α_sfc)\n    else\n        out .= p.bucket.α_sfc\n    end\nend","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"It defines how to access your diagnostic (here, p.bucket.α_sfc) with the land_model BucketModel. Note that you can also use the @diagnostic_compute macro to do the same thing:","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"@diagnostic_compute \"albedo\" BucketModel p.bucket.α\\_sfc","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"The @with_error macro define helper functions returning error messages if a user tries to compute a diagnostic variable that doesn't exist in their model type.","category":"page"},{"location":"diagnostics/developers_diagnostics/#Define-diagnostics","page":"For developers","title":"Define diagnostics","text":"","category":"section"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"Once the compute functions have been defined, they are added to define_diagnostics!(land_model), which adds diagnostics variables to ALL_DIAGNOSTICS dict, defined in diagnostic.jl. In these functions, you also define a short_name, long_name, standard_name, units and comment. For example:","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"add_diagnostic_variable!(\n        short_name = \"alpha\",\n        long_name = \"Albedo\",\n        standard_name = \"albedo\",\n        units = \"\",\n        compute! = (out, Y, p, t) -> compute_albedo!(out, Y, p, t, land_model),\n    )","category":"page"},{"location":"diagnostics/developers_diagnostics/#Default-diagnostics","page":"For developers","title":"Default diagnostics","text":"","category":"section"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"For each model, we define a function default_diagnostics which will define what diagnostic variables to compute by default for a specific model, and on what schedule (for example, hourly average). For example,","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"function default_diagnostics(land_model::BucketModel{FT}; output_writer) where {FT}\n\n    define_diagnostics!(land_model)\n\n    bucket_diagnostics = [\n        \"alpha\",\n        \"rn\",\n        \"tsfc\",\n        \"qsfc\",\n        \"lhf\",\n        \"rae\",\n        \"shf\",\n        \"vflux\",\n        \"rhosfc\",\n        \"t\",\n        \"w\",\n        \"ws\",\n        \"sigmas\",\n    ]\n\n    default_outputs =\n        hourly_averages(FT, bucket_diagnostics...; output_writer)\n    return [default_outputs...]\nend","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"is the default for the BucketModel, it will return hourly averages for the variables listed in bucket_diagnostics (which are all variables in the BucketModel).","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"For the SoilCanopyModel and the SoilModel, we added two keyword arguments: output_vars (can be :long or :short) and average_period (can be :hourly, :daily, or :monthly). If output_vars = :long (the default), then soilcanopy_diagnostics is an Array of all short_name, if output_vars = :short, then soilcanopy_diagnostics = [\"gpp\", \"ct\", \"lai\", \"swc\", \"si\"]. If average_period = :hourly, default_outputs calls hourly_averages, et cetera.","category":"page"},{"location":"diagnostics/developers_diagnostics/#Standard-diagnostic-frequencies","page":"For developers","title":"Standard diagnostic frequencies","text":"","category":"section"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"We defined some functions of diagnostic schedule that may often be used in standard_diagnostic_frequencies.jl, for example","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"hourly_averages(FT, short_names...; output_writer) = common_diagnostics(\n    60 * 60 * one(FT),\n    (+),\n    output_writer,\n    short_names...;\n    pre_output_hook! = average_pre_output_hook!,\n)","category":"page"},{"location":"diagnostics/developers_diagnostics/","page":"For developers","title":"For developers","text":"will return a list of ScheduledDiagnostics that compute the hourly average for the given variables listed in short_names. We also, so far, provide functions for mins, maxs and averages aggregated monthly, over ten days, daily, and hourly. As a developer, you may want to add more standard diagnostics here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nio = IOBuffer()\nv = Pkg.installed()[\"ClimaLand\"]\nprint(io, \"\"\"\n    # ClimaLand.jl Documentation (v$(v))\n\n    \"\"\")\nimport Markdown\nMarkdown.parse(String(take!(io)))","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaLand is the Land model of the Climate Modeling Alliance (CliMA) Earth System Model, which also contains other components (atmosphere, ocean, sea-ice).","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaLand can be run coupled (or \"online\") with these other components via ClimaCoupler, or it can be run as a standalone, via prescribed meteorological data (\"offline\").","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaLand library, described in this documentation, is written in the Julia programming language. It aims to be fast and have a clear syntax. ClimaLand can run on CPU or GPU, it has a modular design, and is flexible in many ways. This documentation will expand on each of these elements.","category":"page"},{"location":"#Important-Links","page":"Home","title":"Important Links","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CliMA Homepage\nCliMA GitHub Organisation\nClimaCoupler\nClimaAnalysis\nJulia Homepage","category":"page"},{"location":"#Documentation-for-Users-and-Developers","page":"Home","title":"Documentation for Users and Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaLand has documentation for both users and developers. The documentation for users is aimed at scientists who wants to run simulations using ClimaLand, whereas the documentation for developers is aimed at contributors of the ClimaLand code library. As such, users can skip reading the docs for developers, and vice-versa.","category":"page"},{"location":"#Physical-units","page":"Home","title":"Physical units","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Note that CliMA, in all its repositories, uses Standard Units, reminded below","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantity Unit Name SI Symbol SI Unit Equivalent\nLength Meter m 1 m\nMass Kilogram kg 1 kg\nTime Second s 1 s\nTemperature Kelvin K 1 K\nAmount of Substance Mole mol 1 mol\nEnergy Joule J 1 J = 1 N·m\nPower Watt W 1 W = 1 J/s\nPressure Pascal Pa 1 Pa = 1 N/m²\nFrequency Hertz Hz 1 Hz = 1 s⁻¹","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../..\"","category":"page"},{"location":"generated/calibration/minimal_working_example/#Calibration:-\"perfect-model\"-experiment.","page":"Single site perfect model","title":"Calibration: \"perfect model\" experiment.","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"In this tutorial, we demonstrate that we can recover the parameters of a previous model run via our calibration framework, by calibrating a single site (Ozark) latent heat flux (LHF).","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"First, we run a simulation of Ozark with known values of parameters g1 and g0, which control the stomatal behavior of leaves and therefore the canopy transpiration, and retrieve latent heat flux (transpiration expressed in energy).","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"Then, we use EnsembleKalmanProcesses.jl to perform a calibration by giving a prior distribution of the parameters g1 and g0, different from the known parameters used in the first \"perfect model\" run. Our goal is that, after calibraton on the perfect model latent heat flux, the parameters will be close to the original ones, therefore demonstrating that we can recover the parameters of the perfect model.","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"To perform this calibration we will need:","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"A function returning our model LHF output given the parameters we want to calibrate.\nThe \"truth\" target data, to calibrate on.\nThe prior distribution of these parameters.","category":"page"},{"location":"generated/calibration/minimal_working_example/#Import-required-packages:","page":"Single site perfect model","title":"Import required packages:","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"import ClimaLandSimulations.Fluxnet as CLS # to run the model\nimport EnsembleKalmanProcesses as EKP # to perform the calibration\nimport Random # to use the same seed each run in the tutorial, optional\nimport Logging\nLogging.disable_logging(Logging.Warn); # hide julia warnings","category":"page"},{"location":"generated/calibration/minimal_working_example/#Write-a-function-returning-our-model-LHF-output-given-the-parameters-to-calibrate","page":"Single site perfect model","title":"Write a function returning our model LHF output given the parameters to calibrate","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"function Ozark_LatentHeatFlux(params) # params is a 2 element Array\n    g1, g0 = params\n    sv = CLS.run_fluxnet(\n        \"US-MOz\";\n        params = CLS.ozark_default_params(;\n            conductance = CLS.conductance_ozark(; g1 = g1, g0 = g0),\n        ),\n    )[1]\n    inputs = CLS.make_inputs_df(\"US-MOz\")[1]\n    simulation_output = CLS.make_output_df(\"US-MOz\", sv, inputs)\n    LHF_soil =\n        [parent(sv.saveval[k].soil.turbulent_fluxes.lhf)[1] for k in 1:1441]\n    LHF_canopy = [\n        parent(sv.saveval[k].canopy.energy.turbulent_fluxes.lhf)[1] for\n        k in 1:1441\n    ]\n    LHF = LHF_soil + LHF_canopy\n    return LHF\nend;","category":"page"},{"location":"generated/calibration/minimal_working_example/#\"Truth\"-target-data-to-calibrate-on","page":"Single site perfect model","title":"\"Truth\" target data to calibrate on","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"Our default for Ozark, g1 in sqrt(Pa). This is equal to 4.46 sqrt(kPa).","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"LHF_target = Ozark_LatentHeatFlux([141.0, 0.0001]);","category":"page"},{"location":"generated/calibration/minimal_working_example/#Parameters-prior","page":"Single site perfect model","title":"Parameters prior","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"We choose the prior for each parameter distribution to be a Gaussian distribution, for example for g1, with a mean of 221 sqrt(Pa) = 7 sqrt(kPa), std of 100 (3 kPa). Returns μ=5.3, σ=0.4 (values are transformed).","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"prior_g1 = EKP.constrained_gaussian(\"g1\", 221, 100, 0, Inf);\nprior_g0 = EKP.constrained_gaussian(\"g0\", 0.00015, 0.01, 0, Inf);\nprior = EKP.combine_distributions([prior_g1, prior_g0]);","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"To use the same seed each run, optional","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"rng_seed = 2\nrng = Random.MersenneTwister(rng_seed)","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"Random.MersenneTwister(2)","category":"page"},{"location":"generated/calibration/minimal_working_example/#Calibration","page":"Single site perfect model","title":"Calibration","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"Generate the initial ensemble and set up the ensemble Kalman inversion","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"N_ensemble = 3 # should be 10\nN_iterations = 3 # should be 10\nΓ = 5.0 * EKP.I # Γ adds random noise. About 10% of output average.\ninitial_ensemble = EKP.construct_initial_ensemble(rng, prior, N_ensemble);\nensemble_kalman_process = EKP.EnsembleKalmanProcess(\n    initial_ensemble,\n    LHF_target,\n    Γ,\n    EKP.Inversion();\n    rng = rng,\n);","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"We are now ready to carry out the inversion. At each iteration, we get the ensemble from the last iteration, apply Ozark_LatentHeatFlux(params) to each ensemble member, and apply the Kalman update to the ensemble.","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"Can be multithreaded, see https://clima.github.io/EnsembleKalmanProcesses.jl/dev/parallel_hpc/","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"ClimaLand_out = []\nfor i in 1:N_iterations # This will run the model N_ensemble * N_iterations times\n    params_i = EKP.get_ϕ_final(prior, ensemble_kalman_process)\n    push!(\n        ClimaLand_out,\n        [Ozark_LatentHeatFlux(params_i[:, i]) for i in 1:N_ensemble],\n    )\n    ClimaLand_ens = hcat(ClimaLand_out[i]...)\n    EKP.update_ensemble!(ensemble_kalman_process, ClimaLand_ens)\nend;","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"Done! Here are the parameters:","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"final_ensemble = EKP.get_ϕ_final(prior, ensemble_kalman_process)","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"2×3 Matrix{Float64}:\n 145.49        145.497       145.501\n   7.41325e-6    7.41287e-6    7.40882e-6","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"As you can see, they are close to the perfect model parameter values, which were 141 and 0.0001.","category":"page"},{"location":"generated/calibration/minimal_working_example/#Plotting","page":"Single site perfect model","title":"Plotting","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"using CairoMakie\nCairoMakie.activate!()\nfig = Figure()\nax = Axis(fig[1, 1], ylabel = \"Latent heat flux (W m^-2)\", xlabel = \"Half-hour\")\nrange = 1:1:length(LHF_target)\n\nl1 = lines!(ax, range, LHF_target, color = :black, linewidth = 4)\nl2 = [\n    lines!(ax, range, ClimaLand_out[1][i], color = :red) for i in 1:N_ensemble\n][1]\nl3 = [\n    lines!(ax, range, ClimaLand_out[3][i], color = :blue) for i in 1:N_ensemble\n][1]\naxislegend(\n    ax,\n    [l1, l2, l3],\n    [\"Perfect model (target)\", \"Before calibration\", \"After calibration\"],\n)\nxlims!(ax, (0, 48))\nsave(\"fig.png\", fig);","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"(Image: )","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"Note that the figure contains one black line, 10 red and 10 blue lines, drawn from the prior and posterior distribution of parameters. EKI is an interative process that, when successful, leads to the convergence in the ensemble members to a small region of parameter space.","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"","category":"page"},{"location":"generated/calibration/minimal_working_example/","page":"Single site perfect model","title":"Single site perfect model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../..\"","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/#Calibration:-single-site-(Ozark)-latent-heat-flux-observations.","page":"Single site observations","title":"Calibration: single site (Ozark) latent heat flux observations.","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"We calibrate observations of latent heat flux (LHF) retrieved from Ozark eddy-covariance data. We calibrate three parameters: g1, which is a core parameters of stomatal conductance, and two parameters controling plant sensitivity to moisture stress, sc and pc.","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"We use EnsembleKalmanProcess.jl to perform this calibration, detailed step by step below:","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"We will need:","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"A function returning our model LHF output given the parameters we want to calibrate.\nThe \"truth\" target data, to calibrate on.\nThe prior distribution of these parameters.","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/#Load-packages","page":"Single site observations","title":"Load packages","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"import ClimaLandSimulations.Fluxnet as CLS # to run the model\nimport EnsembleKalmanProcesses as EKP # to perform the calibration\nimport Random # to use the same seed each run in the tutorial, optional\nimport Logging\nLogging.disable_logging(Logging.Warn); # hide julia warnings","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/#Write-a-function-returning-our-model-LHF-output-given-the-parameters-to-calibrate","page":"Single site observations","title":"Write a function returning our model LHF output given the parameters to calibrate","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"function Ozark_LHF(params) # params is a 2 element Array\n    g1, sc, pc = params\n    sv = CLS.run_fluxnet(\n        \"US-MOz\";\n        params = CLS.ozark_default_params(;\n            conductance = CLS.conductance_ozark(; g1 = g1),\n            photosynthesis = CLS.photosynthesis_ozark(; sc = sc, pc = pc),\n        ),\n    )[1]\n\n    inputs = CLS.make_inputs_df(\"US-MOz\")[1]\n\n    simulation_output = CLS.make_output_df(\"US-MOz\", sv, inputs)\n\n    LHF_soil =\n        [parent(sv.saveval[k].soil.turbulent_fluxes.lhf)[1] for k in 1:1441]\n    LHF_canopy = [\n        parent(sv.saveval[k].canopy.energy.turbulent_fluxes.lhf)[1] for\n        k in 1:1441\n    ]\n    LHF = LHF_soil + LHF_canopy\n\n    return LHF\nend;","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/#\"Truth\"-target-data-to-calibrate-on","page":"Single site observations","title":"\"Truth\" target data to calibrate on","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"t0 = Float64(120 * 3600 * 24);\nN_spinup_days = 30;\nN_days_sim = 30;\nN_days = N_spinup_days + N_days_sim;\nindex_t_start = Int(t0 / (3600 * 24) * 48);\nindex_t_end = Int(index_t_start + (N_days - N_spinup_days) * 48);\ninputs = CLS.make_inputs_df(\"US-MOz\")[1];\nLHF_target = Float64.(inputs.LE)[index_t_start:index_t_end];","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/#Parameters-prior","page":"Single site observations","title":"Parameters prior","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"prior_g1 = EKP.constrained_gaussian(\"g1\", 141, 100, 0, Inf); # mean of 221 sqrt(Pa) = 7 sqrt(kPa), std of 100 (3 kPa)\nprior_sc = EKP.constrained_gaussian(\"sc\", 5e-6, 5e-4, 0, Inf);\nprior_pc = EKP.constrained_gaussian(\"pc\", -2e6, 1e6, -Inf, Inf);\nprior = EKP.combine_distributions([prior_g1, prior_sc, prior_pc]);","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"To use the same seed each run, optional","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"rng_seed = 2\nrng = Random.MersenneTwister(rng_seed)","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"Random.MersenneTwister(2)","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/#Calibration","page":"Single site observations","title":"Calibration","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"Generate the initial ensemble and set up the ensemble Kalman inversion Note that we use a small number ensemble and iterations in this tutorial.","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"N_ensemble = 3 # EKP.jl recommends 10 per parameters.\nN_iterations = 3 # EKP.jl recommends at least 10 iterations.\nΓ = 5.0 * EKP.I\n\ninitial_ensemble = EKP.construct_initial_ensemble(rng, prior, N_ensemble);\n\nensemble_kalman_process = EKP.EnsembleKalmanProcess(\n    initial_ensemble,\n    LHF_target,\n    Γ,\n    EKP.Inversion();\n    rng = rng,\n);","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"We are now ready to carry out the inversion. At each iteration, we get the ensemble from the last iteration, apply Ozark_LHF(params) to each ensemble member, and apply the Kalman update to the ensemble. Note that saving the model output for each iteration and ensemble is not required in this loop.","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"params_i = [] # initialize empty array\nClimaLand_out = [] # we chose to save outputs in memory for plotting. (optional)\nfor i in 1:N_iterations\n    push!(params_i, EKP.get_ϕ_final(prior, ensemble_kalman_process))\n    push!(ClimaLand_out, [Ozark_LHF(params_i[i][:, j]) for j in 1:N_ensemble])\n    ClimaLand_ens = hcat(ClimaLand_out[i]...)\n    EKP.update_ensemble!(ensemble_kalman_process, ClimaLand_ens)\nend;","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"Done! Here are the parameters:","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"final_ensemble = EKP.get_ϕ_final(prior, ensemble_kalman_process)","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"3×3 Matrix{Float64}:\n      59.1361      59.4742      59.5617\n       1.12816e-6   1.14131e-6   9.46374e-7\n -244782.0         -2.85847e5   -2.04754e5","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/#Plot","page":"Single site observations","title":"Plot","text":"","category":"section"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"using CairoMakie\nCairoMakie.activate!()\nfig = Figure()\nax = Axis(fig[1, 1], ylabel = \"Latent heat flux (W m^-2)\", xlabel = \"Half-hour\")\ntrange = 1:1:length(LHF_target)\n\nl2 = [\n    lines!(ax, trange, ClimaLand_out[1][i], color = :red) for i in 1:N_ensemble\n][1]\nl3 = [\n    lines!(ax, trange, ClimaLand_out[3][i], color = :green) for\n    i in 1:N_ensemble\n][1]\nl1 = lines!(ax, trange, LHF_target, color = :black)\naxislegend(\n    ax,\n    [l1, l2, l3],\n    [\"Observations (target)\", \"Before calibration\", \"After calibration\"],\n)\nxlims!(ax, (48 * 6, 48 * 11))\n\nsave(\"fig_lhf_obs.png\", fig);","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"(Image: )","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"The figure contains one black line, and 3 red and blue lines, drawn from the prior and posterior distribution of parameters. EKI process is an iterative process that, when successful, leads to the convergence in the ensemble members to a small region of parameter space.","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"","category":"page"},{"location":"generated/calibration/minimal_working_example_obs/","page":"Single site observations","title":"Single site observations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Eventually this will be a bare soil site experiment, showing how to set up the soil model in a column with prescribed forcing and comparing to data.","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"using CairoMakie\nimport SciMLBase\nimport ClimaTimeSteppers as CTS\nusing Thermodynamics\n\nusing ClimaCore\nimport ClimaParams as CP\nusing SurfaceFluxes\nusing StaticArrays\nusing Dates\nusing DelimitedFiles: readdlm\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\nimport ClimaLand\nimport ClimaLand.Parameters as LP\nimport SurfaceFluxes.Parameters as SFP\n\nFT = Float64;\nearth_param_set = LP.LandParameters(FT)\nthermo_params = LP.thermodynamic_parameters(earth_param_set);\n\nstart_date = DateTime(2005)\nSW_d = (t) -> 0\nLW_d = (t) -> 270.0^4 * 5.67e-8\nradiation = PrescribedRadiativeFluxes(\n    FT,\n    TimeVaryingInput(SW_d),\n    TimeVaryingInput(LW_d),\n    start_date,\n);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Set up atmospheric conditions that result in the potential evaporation rate obsereved in the experiment. Some of these conditions are reported in the paper.","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"T_air = FT(270.0)\nrh = FT(0.38)\nesat = Thermodynamics.saturation_vapor_pressure(\n    thermo_params,\n    T_air,\n    Thermodynamics.Liquid(),\n)\ne = rh * esat\nq = FT(0.622 * e / (101325 - 0.378 * e))\nprecip = (t) -> 0.0\nT_atmos = (t) -> T_air\nu_atmos = (t) -> 1.0\nq_atmos = (t) -> q\nh_atmos = FT(0.1)\nP_atmos = (t) -> 101325\ngustiness = FT(1e-2)\natmos = PrescribedAtmosphere(\n    TimeVaryingInput(precip),\n    TimeVaryingInput(precip),\n    TimeVaryingInput(T_atmos),\n    TimeVaryingInput(u_atmos),\n    TimeVaryingInput(q_atmos),\n    TimeVaryingInput(P_atmos),\n    start_date,\n    h_atmos,\n    earth_param_set;\n    gustiness = gustiness,\n);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Define the boundary conditions","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"top_bc = ClimaLand.Soil.AtmosDrivenFluxBC(atmos, radiation)\nzero_water_flux = WaterFluxBC((p, t) -> 0)\nzero_heat_flux = HeatFluxBC((p, t) -> 0)\nboundary_fluxes = (;\n    top = top_bc,\n    bottom = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"[ Info: Warning: No runoff model was provided; zero runoff generated.\n","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Define the parameters n and alpha estimated by matching vG curve.","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"K_sat = FT(225.1 / 3600 / 24 / 1000)\nvg_n = FT(10.0)\nvg_α = FT(6.0)\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n)\nν = FT(0.43)\nθ_r = FT(0.045)\nS_s = FT(1e-3)\nν_ss_om = FT(0.0)\nν_ss_quartz = FT(1.0)\nν_ss_gravel = FT(0.0)\nemissivity = FT(1.0)\nPAR_albedo = FT(0.2)\nNIR_albedo = FT(0.4)\nz_0m = FT(1e-3)\nz_0b = FT(1e-4)\nd_ds = FT(0.01)\nparams = ClimaLand.Soil.EnergyHydrologyParameters(\n    FT;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm = hcm,\n    K_sat,\n    S_s,\n    θ_r,\n    PAR_albedo,\n    NIR_albedo,\n    emissivity,\n    z_0m,\n    z_0b,\n    earth_param_set,\n    d_ds,\n);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Domain - single column","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"zmax = FT(0)\nzmin = FT(-0.35)\nnelems = 12\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);\nz = ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z;","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Soil model, and create the prognostic vector Y and cache p:","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"sources = (PhaseChange{FT}(),);\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n)\n\nY, p, cds = initialize(soil);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Set initial conditions","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"function hydrostatic_equilibrium(z, z_interface, params)\n    (; ν, S_s, hydrology_cm) = params\n    (; α, n, m) = hydrology_cm\n    if z < z_interface\n        return -S_s * (z - z_interface) + ν\n    else\n        return ν * (1 + (α * (z - z_interface))^n)^(-m)\n    end\nend\nfunction init_soil!(Y, z, params)\n    FT = eltype(Y.soil.ϑ_l)\n    Y.soil.ϑ_l .= hydrostatic_equilibrium.(z, FT(-0.1), params)\n    Y.soil.θ_i .= 0\n    T = FT(275.0)\n    ρc_s = @. Soil.volumetric_heat_capacity(\n        Y.soil.ϑ_l,\n        FT(0),\n        params.ρc_ds,\n        params.earth_param_set,\n    )\n    Y.soil.ρe_int =\n        Soil.volumetric_internal_energy.(FT(0), ρc_s, T, params.earth_param_set)\nend\ninit_soil!(Y, z, soil.parameters);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Timestepping:","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"t0 = Float64(0)\ntf = Float64(24 * 3600 * 4)\ndt = Float64(5)","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"5.0","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"We also set the initial conditions of the cache here:","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"set_initial_cache! = make_set_initial_cache(soil)\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Timestepping functions:","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"exp_tendency! = make_exp_tendency(soil)\nimp_tendency! = make_imp_tendency(soil)\njacobian! = ClimaLand.make_jacobian(soil)\njac_kwargs = (; jac_prototype = ImplicitEquationJacobian(Y), Wfact = jacobian!)\n\ntimestepper = CTS.ARS111()\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n)","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"ClimaTimeSteppers.IMEXAlgorithm{ClimaTimeSteppers.Unconstrained, ClimaTimeSteppers.ARS111, ClimaTimeSteppers.IMEXTableau{ClimaTimeSteppers.SparseCoeffs{(2, 2), (true, false, true, true), StaticArraysCore.SMatrix{2, 2, Int64, 4}}, ClimaTimeSteppers.SparseCoeffs{(2,), (false, true), StaticArraysCore.SVector{2, Int64}}, ClimaTimeSteppers.SparseCoeffs{(2,), (true, false), StaticArraysCore.SVector{2, Int64}}, ClimaTimeSteppers.SparseCoeffs{(2, 2), (true, true, true, false), StaticArraysCore.SMatrix{2, 2, Int64, 4}}, ClimaTimeSteppers.SparseCoeffs{(2,), (true, false), StaticArraysCore.SVector{2, Int64}}, ClimaTimeSteppers.SparseCoeffs{(2,), (true, false), StaticArraysCore.SVector{2, Int64}}}, ClimaTimeSteppers.NewtonsMethod{ClimaTimeSteppers.UpdateEvery{ClimaTimeSteppers.NewNewtonIteration}, Nothing, Nothing, ClimaTimeSteppers.Silent}}(ClimaTimeSteppers.Unconstrained(), ClimaTimeSteppers.ARS111(), ClimaTimeSteppers.IMEXTableau{ClimaTimeSteppers.SparseCoeffs{(2, 2), (true, false, true, true), StaticArraysCore.SMatrix{2, 2, Int64, 4}}, ClimaTimeSteppers.SparseCoeffs{(2,), (false, true), StaticArraysCore.SVector{2, Int64}}, ClimaTimeSteppers.SparseCoeffs{(2,), (true, false), StaticArraysCore.SVector{2, Int64}}, ClimaTimeSteppers.SparseCoeffs{(2, 2), (true, true, true, false), StaticArraysCore.SMatrix{2, 2, Int64, 4}}, ClimaTimeSteppers.SparseCoeffs{(2,), (true, false), StaticArraysCore.SVector{2, Int64}}, ClimaTimeSteppers.SparseCoeffs{(2,), (true, false), StaticArraysCore.SVector{2, Int64}}}(ClimaTimeSteppers.SparseCoeffs{(2, 2), (true, false, true, true), StaticArraysCore.SMatrix{2, 2, Int64, 4}}([0 0; 1 0]), ClimaTimeSteppers.SparseCoeffs{(2,), (false, true), StaticArraysCore.SVector{2, Int64}}([1, 0]), ClimaTimeSteppers.SparseCoeffs{(2,), (true, false), StaticArraysCore.SVector{2, Int64}}([0, 1]), ClimaTimeSteppers.SparseCoeffs{(2, 2), (true, true, true, false), StaticArraysCore.SMatrix{2, 2, Int64, 4}}([0 0; 0 1]), ClimaTimeSteppers.SparseCoeffs{(2,), (true, false), StaticArraysCore.SVector{2, Int64}}([0, 1]), ClimaTimeSteppers.SparseCoeffs{(2,), (true, false), StaticArraysCore.SVector{2, Int64}}([0, 1])), ClimaTimeSteppers.NewtonsMethod{ClimaTimeSteppers.UpdateEvery{ClimaTimeSteppers.NewNewtonIteration}, Nothing, Nothing, ClimaTimeSteppers.Silent}(1, ClimaTimeSteppers.UpdateEvery{ClimaTimeSteppers.NewNewtonIteration}(), nothing, nothing, ClimaTimeSteppers.Silent()))","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Define the problem and callbacks:","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"prob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n)\nsaveat = Array(t0:3600.0:tf)\nsv = (;\n    t = Array{Float64}(undef, length(saveat)),\n    saveval = Array{NamedTuple}(undef, length(saveat)),\n)\nsaving_cb = ClimaLand.NonInterpSavingCallback(sv, saveat)\nupdateat = deepcopy(saveat)\nmodel_drivers = ClimaLand.get_drivers(soil)\nupdatefunc = ClimaLand.make_update_drivers(model_drivers)\ndriver_cb = ClimaLand.DriverUpdateCallback(updateat, updatefunc)\ncb = SciMLBase.CallbackSet(driver_cb, saving_cb);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Solve","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"sol = SciMLBase.solve(prob, ode_algo; dt = dt, callback = cb, saveat = saveat);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Figures","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"Extract the evaporation at each saved step","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"evap = [\n    parent(sv.saveval[k].soil.turbulent_fluxes.vapor_flux_liq)[1] for\n    k in 1:length(sol.t)\n]\nsub = [\n    parent(sv.saveval[k].soil.turbulent_fluxes.vapor_flux_ice)[1] for\n    k in 1:length(sol.t)\n]\n\nsavepath = joinpath(pkgdir(ClimaLand), \"docs/tutorials/standalone/Soil/\")\n\nfig = Figure(size = (400, 400))\nax = Axis(\n    fig[1, 1],\n    xlabel = \"Day\",\n    ylabel = \"Rate (mm/d)\",\n    title = \"Vapor Fluxes\",\n)\nCairoMakie.lines!(\n    ax,\n    sol.t ./ 3600 ./ 24,\n    sub .* (1000 * 3600 * 24),\n    label = \"Sublimation\",\n    color = :blue,\n)\nCairoMakie.lines!(\n    ax,\n    sol.t ./ 3600 ./ 24,\n    evap .* (1000 * 3600 * 24),\n    label = \"Evaporation\",\n    color = :black,\n)\nCairoMakie.axislegend(ax)\n\nsave(\"water_fluxes.png\", fig);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"fig2 = Figure(size = (800, 1200))\nax1 = Axis(fig2[1, 1], title = \"Temperature\")\nCairoMakie.ylims!(-0.35, 0)\nCairoMakie.xlims!(260, 280)\nlinestyles = [:solid, :dash, :dashdot, :dashdotdot, :dot]\ndays = [0, 1, 2, 3, 4]\nfor i in 1:length(days)\n    CairoMakie.lines!(\n        ax1,\n        parent(sv.saveval[Int(days[i] * 24 + 1)].soil.T)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\nax2 = Axis(fig2[2, 1], title = \"Ice\", ylabel = \"Depth(cm)\")\n\nCairoMakie.ylims!(-0.35, 0)\nCairoMakie.xlims!(0.0, 0.5)\nfor i in 1:length(days)\n    CairoMakie.lines!(\n        ax2,\n        parent(sol.u[Int(days[i] * 24 + 1)].soil.θ_i)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\nax3 = Axis(fig2[3, 1], title = \"Liquid Water\", xlabel = \"\")\nCairoMakie.ylims!(-0.35, 0)\nCairoMakie.xlims!(0.0, 0.5)\nfor i in 1:length(days)\n    CairoMakie.lines!(\n        ax3,\n        parent(sol.u[Int(days[i] * 24 + 1)].soil.ϑ_l)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\n\nCairoMakie.axislegend(ax3, position = :lt)\nCairoMakie.axislegend(ax2, position = :lt)\nCairoMakie.axislegend(ax1, position = :lt)\nsave(\"profiles.png\", fig2);","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"","category":"page"},{"location":"generated/standalone/Soil/sublimation/","page":"Bare soil site","title":"Bare soil site","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Soil/#Soil-Models","page":"Soil Energy and Hydrology","title":"Soil Models","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Energy and Hydrology","title":"Soil Energy and Hydrology","text":"CurrentModule = ClimaLand.Soil","category":"page"},{"location":"APIs/Soil/#Soil-Models-2","page":"Soil Energy and Hydrology","title":"Soil Models","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Energy and Hydrology","title":"Soil Energy and Hydrology","text":"ClimaLand.Soil.AbstractSoilModel\nClimaLand.Soil.RichardsModel\nClimaLand.Soil.EnergyHydrology","category":"page"},{"location":"APIs/Soil/#ClimaLand.Soil.AbstractSoilModel","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.AbstractSoilModel","text":"AbstractSoilModel{FT} <: ClimaLand.AbstractImExModel{FT}\n\nThe abstract type for all soil models.\n\nCurrently, we only have plans to support a RichardsModel, simulating the flow of liquid water through soil via the Richardson-Richards equation, and a fully integrated soil heat and water model, with phase change.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.RichardsModel","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.RichardsModel","text":"RichardsModel\n\nA model for simulating the flow of water in a porous medium by solving the Richardson-Richards Equation.\n\nA variety of boundary condition types are supported, including FluxBC, RichardsAtmosDrivenFluxBC, MoistureStateBC, and FreeDrainage (only for the bottom of the domain).\n\nIf you wish to simulate soil hydrology under the context of a prescribed precipitation volume flux (m/s) as a function of time, the RichardsAtmosDrivenFluxBC type should be chosen. Please see the documentation for more details.\n\nparameters: the parameter set\ndomain: the soil domain, using ClimaCore.Domains\nboundary_conditions: the boundary conditions, of type AbstractSoilBoundaryConditions\nsources: A tuple of sources, each of type AbstractSoilSource\nlateral_flow: A boolean flag which, when false, turns off the horizontal flow of water\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.EnergyHydrology","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.EnergyHydrology","text":"EnergyHydrology <: AbstractSoilModel\n\nA model for simulating the flow of water and heat in a porous medium by solving the Richardson-Richards equation and the heat equation, including terms for phase change.\n\nA variety of boundary condition types are supported, including FluxBC, MoistureStateBC/TemperatureStateBC, FreeDrainage (only for the bottom of the domain), and an AtmosDrivenFluxBC (under which radiative fluxes and turbulent surface fluxes are computed and used as boundary conditions). Please see the documentation for this boundary condition type for more details.\n\nparameters: The parameter sets\ndomain: the soil domain, using ClimaCore.Domains\nboundary_conditions: the boundary conditions for RRE and heat, of type AbstractSoilBoundaryConditions\nsources: A tuple of sources, each of type AbstractSoilSource\nlateral_flow: A boolean flag which, when false, turns off the horizontal flow of water and heat\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#Soil-Parameter-Structs","page":"Soil Energy and Hydrology","title":"Soil Parameter Structs","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Energy and Hydrology","title":"Soil Energy and Hydrology","text":"ClimaLand.Soil.RichardsParameters\nClimaLand.Soil.EnergyHydrologyParameters","category":"page"},{"location":"APIs/Soil/#ClimaLand.Soil.RichardsParameters","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.RichardsParameters","text":"RichardsParameters{F <: Union{<: AbstractFloat, ClimaCore.Fields.Field}, C <: AbstractSoilHydrologyClosure}\n\nA struct for storing parameters of the RichardsModel.\n\nν: The porosity of the soil (m^3/m^3)\nhydrology_cm: The hydrology closure model: vanGenuchten or BrooksCorey\nK_sat: The saturated hydraulic conductivity (m/s)\nS_s: The specific storativity (1/m)\nθ_r: The residual water fraction (m^3/m^3\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.EnergyHydrologyParameters","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.EnergyHydrologyParameters","text":"EnergyHydrologyParameters{\n        FT <: AbstractFloat,\n        F <: Union{<:AbstractFloat, ClimaCore.Fields.Field},\n        SF <: Union{<:AbstractFloat, ClimaCore.Fields.Field},\n        C,\n        PSE,\n    }\n\nA parameter structure for the integrated soil water and energy  equation system.\n\nNote that we require two different parameter types F and SF; these are for parameters that are defined on the surface only and those defined in the interior of the soil domain:\n\nSurface parameters: albedo in each wavelength band (SF)\nScalar parameters: emissivity, α, β, γ, γT_ref, Ω,\n\nroughness lengths z0, dds ) (FT)\n\nParameters defined in the interior: all else (F)\n\nκ_dry: The dry soil thermal conductivity, W/m/K\nκ_sat_frozen: The saturated thermal conductivity of frozen soil, W/m/K\nκ_sat_unfrozen: The saturated thermal conductivity of unfrozen soil, W/m/K\nρc_ds: The volumetric heat capacity of dry soil, J/m^3/K (per volume dry soil, not per volume soil solids)\nν: The porosity of the soil (m^3/m^3)\nν_ss_om: The volumetric fraction of the soil solids in organic matter (m^3/m^3)\nν_ss_quartz: The volumetric fraction of the soil solids in quartz (m^3/m^3)\nν_ss_gravel: The volumetric fraction of the soil solids in gravel (m^3/m^3)\nα: The parameter α used in computing Kersten number, unitless\nβ: The parameter β used in computing Kersten number, unitless\nhydrology_cm: The soil hydrology closure model: van Genuchten or Brooks and Corey\nK_sat: The saturated hydraulic conductivity (m/s)\nS_s: The specific storativity (1/m)\nθ_r: The residual water fraction (m^3/m^3\nΩ: Ice impedance factor for the hydraulic conductivity\nγ: Coefficient of viscosity factor for the hydraulic conductivity\nγT_ref: Reference temperature for the viscosity factor\nPAR_albedo: Soil PAR Albedo\nNIR_albedo: Soil NIR Albedo\nemissivity: Soil Emissivity\nz_0m: Roughness length for momentum\nz_0b: Roughness length for scalars\nd_ds: Maximum dry soil layer thickness under evaporation (m)\nearth_param_set: Physical constants and clima-wide parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#Soil-Hydrology-Parameterizations","page":"Soil Energy and Hydrology","title":"Soil Hydrology Parameterizations","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Energy and Hydrology","title":"Soil Energy and Hydrology","text":"ClimaLand.Soil.volumetric_liquid_fraction\nClimaLand.Soil.pressure_head\nClimaLand.Soil.hydraulic_conductivity\nClimaLand.Soil.impedance_factor\nClimaLand.Soil.viscosity_factor\nClimaLand.Soil.effective_saturation\nClimaLand.Soil.matric_potential\nClimaLand.Soil.dψdϑ\nClimaLand.Soil.inverse_matric_potential\nClimaLand.Soil.AbstractSoilHydrologyClosure\nClimaLand.Soil.vanGenuchten\nClimaLand.Soil.BrooksCorey","category":"page"},{"location":"APIs/Soil/#ClimaLand.Soil.volumetric_liquid_fraction","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.volumetric_liquid_fraction","text":"volumetric_liquid_fraction(ϑ_l::FT, ν_eff::FT, θ_r::FT) where {FT}\n\nA pointwise function returning the volumetric liquid fraction given the augmented liquid fraction and the effective porosity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.pressure_head","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.pressure_head","text":"pressure_head(\n    cm::vanGenuchten{FT},\n    θ_r::FT,\n    ϑ_l::FT,\n    ν_eff::FT,\n    S_s::FT,\n) where {FT}\n\nA point-wise function returning the pressure head in variably saturated soil, using the van Genuchten matric potential  if the soil is not saturated, and an approximation of the positive pressure in the soil if the soil is saturated.\n\n\n\n\n\npressure_head(\n    cm::BrooksCorey{FT},\n    θ_r::FT,\n    ϑ_l::FT,\n    ν_eff::FT,\n    S_s::FT,\n) where {FT}\n\nA point-wise function returning the pressure head in variably saturated soil, using the Brooks and Corey matric potential  if the soil is not saturated, and an approximation of the positive pressure in the soil if the soil is saturated.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.hydraulic_conductivity","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.hydraulic_conductivity","text":" hydraulic_conductivity(cm::vanGenuchten{FT}, K_sat::FT, S::FT) where {FT}\n\nA point-wise function returning the hydraulic conductivity, using the van Genuchten formulation.\n\n\n\n\n\n hydraulic_conductivity(cm::BrooksCorey{FT}, K_sat::FT, S::FT) where {FT}\n\nA point-wise function returning the hydraulic conductivity, using the Brooks and Corey formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.impedance_factor","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.impedance_factor","text":"impedance_factor(\n    f_i::FT,\n    Ω::FT\n) where {FT}\n\nReturns the multiplicative factor reducing conductivity when  a fraction of ice f_i is present.\n\nOnly for use with the EnergyHydrology model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.viscosity_factor","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.viscosity_factor","text":"viscosity_factor(\n    T::FT,\n    γ::FT,\n    γT_ref::FT,\n) where {FT}\n\nReturns the multiplicative factor which accounts for the temperature dependence of the conductivity.\n\nOnly for use with the EnergyHydrology model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.effective_saturation","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.effective_saturation","text":"effective_saturation(porosity::FT, ϑ_l::FT, θr::FT) where {FT}\n\nA point-wise function computing the effective saturation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.matric_potential","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.matric_potential","text":" matric_potential(cm::vanGenuchten{FT}, S::FT) where {FT}\n\nA point-wise function returning the matric potential, using the van Genuchten formulation.\n\n\n\n\n\n matric_potential(cm::BrooksCorey{FT}, S::FT) where {FT}\n\nA point-wise function returning the matric potential, using the Brooks and Corey formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.dψdϑ","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.dψdϑ","text":"dψdϑ(cm::vanGenuchten{FT}, ϑ, ν, θr, Ss)\n\nComputes and returns the derivative of the pressure head  with respect to ϑ for the van Genuchten formulation.\n\n\n\n\n\ndψdϑ(cm::BrooksCorey{FT}, ϑ, ν, θr, Ss)\n\nComputes and returns the derivative of the pressure head  with respect to ϑ for the Brooks and Corey formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.inverse_matric_potential","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.inverse_matric_potential","text":" inverse_matric_potential(cm::vanGenuchten{FT}, ψ::FT) where {FT}\n\nA point-wise function returning the effective saturation, given the matric potential, using the van Genuchten formulation.\n\n\n\n\n\n inverse_matric_potential(cm::BrooksCorey{FT}, ψ::FT) where {FT}\n\nA point-wise function returning the effective saturation, given the matric potential, using the Brooks and Corey formulation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.AbstractSoilHydrologyClosure","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.AbstractSoilHydrologyClosure","text":"AbstractSoilHydrologyClosure{FT <: AbstractFloat}\n\nThe abstract type of soil hydrology closure, of which vanGenuchten{FT} and BrooksCorey{FT} are the two supported  concrete types.\n\nTo add a new parameterization, methods are required for:\n\nmatric_potential,\ninversematricpotential,\npressure_head,\ndψdϑ,\nhydraulic_conductivity.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.vanGenuchten","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.vanGenuchten","text":"vanGenuchten{FT} <: AbstractSoilHydrologyClosure{FT}\n\nThe van Genuchten soil hydrology closure, chosen when the  hydraulic conductivity and matric potential are modeled using the van Genuchten parameterization (van Genuchten 1980; see also Table 8.2 of G. Bonan 2019).\n\nα: The inverse of the air entry potential (1/m)\nn: The van Genuchten pore-size distribution index (unitless)\nm: The van Genuchten parameter m = 1 - 1/n (unitless)\nS_c: A derived parameter: the critical saturation at which capillary flow no longer replenishes the surface\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.BrooksCorey","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.BrooksCorey","text":"BrooksCorey{FT} <: AbstractSoilHydrologyClosure{FT}\n\nThe Brooks and Corey soil hydrology closure, chosen when the  hydraulic conductivity and matric potential are modeled using the Brooks and Corey parameterization (Brooks and Corey, 1964, 1966; see also Table 8.2 of G. Bonan 2019).\n\nc: The pore-size distribution index (unitless)\nψb: The air entry matric potential, when S=1 (m)\nS_c: A derived parameter: the critical saturation at which capillary flow no longer replenishes the surface\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#Soil-Heat-Parameterizations","page":"Soil Energy and Hydrology","title":"Soil Heat Parameterizations","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Energy and Hydrology","title":"Soil Energy and Hydrology","text":"ClimaLand.Soil.volumetric_heat_capacity\nClimaLand.Soil.κ_solid\nClimaLand.Soil.κ_sat_frozen\nClimaLand.Soil.κ_sat_unfrozen\nClimaLand.Soil.κ_sat\nClimaLand.Soil.κ_dry\nClimaLand.Soil.kersten_number\nClimaLand.Soil.relative_saturation\nClimaLand.Soil.volumetric_internal_energy\nClimaLand.Soil.volumetric_internal_energy_liq\nClimaLand.Soil.temperature_from_ρe_int\nClimaLand.Soil.thermal_conductivity\nClimaLand.Soil.phase_change_source\nClimaLand.Soil.thermal_time","category":"page"},{"location":"APIs/Soil/#ClimaLand.Soil.volumetric_heat_capacity","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.volumetric_heat_capacity","text":"volumetric_heat_capacity(\n    θ_l::FT,\n    θ_i::FT,\n    ρc_ds::FT,\n    earth_param_set::EP,\n) where {FT,EP}\n\nCompute the expression for volumetric heat capacity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.κ_solid","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_solid","text":"κ_solid(ν_ss_om::FT,\n        ν_ss_quartz::FT,\n        κ_om::FT,\n        κ_quartz::FT,\n        κ_minerals::FT) where {FT}\n\nComputes the thermal conductivity of the solid material in soil. The _ss_ subscript denotes that the volumetric fractions of the soil components are referred to the soil solid components, not including the pore space.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.κ_sat_frozen","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_sat_frozen","text":"function κ_sat_frozen(\n    κ_solid::FT,\n    ν::FT,\n    κ_ice::FT\n) where {FT}\n\nComputes the thermal conductivity for saturated frozen soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.κ_sat_unfrozen","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_sat_unfrozen","text":"function κ_sat_unfrozen(\n    κ_solid::FT,\n    ν::FT,\n    κ_l::FT\n) where {FT}\n\nComputes the thermal conductivity for saturated unfrozen soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.κ_sat","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_sat","text":"κ_sat(\n    θ_l::FT,\n    θ_i::FT,\n    κ_sat_unfrozen::FT,\n    κ_sat_frozen::FT\n) where {FT}\n\nCompute the expression for saturated thermal conductivity of soil matrix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.κ_dry","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.κ_dry","text":"function κ_dry(ρp::FT,\n               ν::FT,\n               κ_solid::FT,\n               κ_air::FT;\n               a = FT(0.053)) where {FT}\n\nComputes the thermal conductivity of dry soil according to the model of Balland and Arp.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.kersten_number","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.kersten_number","text":"kersten_number(\n    θ_i::FT,\n    S_r::FT,\n    α::FT,\n    β::FT,\n    ν_ss_om::FT,\n    ν_ss_quartz::FT,\n    ν_ss_gravel::FT,\n    ) where {FT}\n\nCompute the expression for the Kersten number, using the Balland and Arp model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.relative_saturation","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.relative_saturation","text":"relative_saturation(\n        θ_l::FT,\n        θ_i::FT,\n        ν::FT\n) where {FT}\n\nCompute the expression for relative saturation.  This is referred to as θ_sat in Balland and Arp's paper.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.volumetric_internal_energy","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.volumetric_internal_energy","text":"volumetric_internal_energy(θ_i::FT, ρc_s::FT, T::FT,\n                             earth_param_set::EP) where {FT, EP}\n\nA pointwise function for computing the volumetric internal energy of the soil, given the volumetric ice content, volumetric heat capacity, and temperature.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.volumetric_internal_energy_liq","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.volumetric_internal_energy_liq","text":"volumetric_internal_energy_liq(T::FT, earth_param_set::EP) where {FT, EP}\n\nA pointwise function for computing the volumetric internal energy of the liquid water in the soil, given the temperature T.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.temperature_from_ρe_int","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.temperature_from_ρe_int","text":"temperature_from_ρe_int(ρe_int::FT, θ_i::FT, ρc_s::FT\n                        earth_param_set::EP) where {FT, EP}\n\nA pointwise function for computing the temperature from the volumetric internal energy, volumetric ice content, and volumetric heat capacity of the soil.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.thermal_conductivity","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.thermal_conductivity","text":"thermal_conductivity(\n    κ_dry::FT,\n    K_e::FT,\n    κ_sat::FT\n) where {FT}\n\nCompute the expression for thermal conductivity of soil matrix.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.phase_change_source","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.phase_change_source","text":"phase_change_source(\n    θ_l::FT,\n    θ_i::FT,\n    T::FT,\n    τ::FT,\n    ν::FT,\n    θ_r::FT,\n    hydrology_cm::C,\n    earth_param_set::EP,\n) where {FT, EP, C}\n\nReturns the source term (1/s) used for converting liquid water and ice into each other during phase changes. Note that there are unitless prefactors multiplying this term in the  equations.\n\nNote that these equations match what is in Dall'Amico (for θstar, ψ(T), ψw0). We should double check them in the case where we have ϑl > θl, but they should be very close to the form we want regardless.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.thermal_time","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.thermal_time","text":"thermal_time(ρc::FT, Δz::FT, κ::FT) where {FT}\n\nReturns the thermal timescale for temperature differences across a typical thickness Δz to equilibrate.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#Soil-Runoff-Types-and-Methods","page":"Soil Energy and Hydrology","title":"Soil Runoff Types and Methods","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Energy and Hydrology","title":"Soil Energy and Hydrology","text":"ClimaLand.Soil.NoRunoff\nClimaLand.Soil.SurfaceRunoff\nClimaLand.Soil.TOPMODELRunoff\nClimaLand.Soil.TOPMODELSubsurfaceRunoff\nClimaLand.Soil.subsurface_runoff_source\nClimaLand.Soil.update_runoff!","category":"page"},{"location":"APIs/Soil/#ClimaLand.Soil.Runoff.NoRunoff","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.Runoff.NoRunoff","text":"NoRunoff <: AbstractRunoffModel\n\nA concrete type of soil runoff model; the  default choice, which does not include any runoff.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.Runoff.SurfaceRunoff","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.Runoff.SurfaceRunoff","text":"SurfaceRunoff <: AbstractRunoffModel\n\nA simple model for runoff appropriate for single column runs.\n\nOnly surface runoff is computed, using a combination of Dunne  and Hortonian runoff.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.Runoff.TOPMODELRunoff","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.Runoff.TOPMODELRunoff","text":"TOPMODELRunoff{FT <: AbstractFloat, F <: ClimaCore.Fields.Field} <: AbstractRunoffModel\n\nThe TOPMODEL surface runoff parameterization, which is affects the surface boundary condition of the soil model.\n\nThe runoff flux is given by Equation 8 of with fsat given by Equation (11), of Niu et al. (2005), \"A simple TOPMODEL-based runoff parameterization (SIMTOP) for use in global climate models\".\n\nf_over: A calibrated parameter defining how subsurface runoff decays with depth to water table (1/m ; calibrated)\nf_max: The maximum saturated fraction of a grid cell, computed from the topographic index CDF per grid cell.\nsubsurface_source: The subsurface source term corresponding to this implementation of TOPMODEL.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.Runoff.TOPMODELSubsurfaceRunoff","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.Runoff.TOPMODELSubsurfaceRunoff","text":"TOPMODELSubsurfaceRunoff{FT} <: AbstractSoilSource{FT}\n\nThe TOPMODEL subsurface runoff parameterization, which is implemented as a sink term in the soil equations.\n\nThe runoff flux is given by Equation 12 of Niu et al. (2005), \"A simple TOPMODEL-based runoff parameterization (SIMTOP) for use in global climate models\".\n\nR_sb: The subsurface runoff flux (m/s) when the depth to the water table = 1/f_over; calibrated\nf_over: A calibrated parameter defining how subsurface runoff decays with depth to water table (1/m ; calibrated)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.Runoff.subsurface_runoff_source","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.Runoff.subsurface_runoff_source","text":"subsurface_runoff_source(runoff::AbstractRunoffModel)\n\nA helper function which returns the subsurface source of the runoff model runoff.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#ClimaLand.Soil.Runoff.update_runoff!","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.Runoff.update_runoff!","text":"update_runoff!(p, runoff::NoRunoff, input, _...)\n\nUpdates the runoff variables in the cache p.soil in place in the case of NoRunoff: sets infiltration = precipitation.\n\n\n\n\n\nupdate_runoff!(\n    p,\n    runoff::SurfaceRunoff,\n    input,\n    Y,\n    t,\n    model::AbstractSoilModel,\n\n)\n\nThe update_runoff! function for the SurfaceRunoff model.\n\nUpdates the runoff model variables in place in p.soil for the SurfaceRunoff  parameterization: p.soil.Rs p.soil.issaturated p.soil.infiltration\n\n\n\n\n\nupdate_runoff!(p, runoff::TOPMODELRunoff, input, Y,t, model::AbstractSoilModel)\n\nUpdates the runoff model variables in place in p.soil for the TOPMODELRunoff parameterization: p.soil.Rs p.soil.Rss p.soil.h∇ p.soil.infiltration\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#Soil-BC-Methods-and-Types","page":"Soil Energy and Hydrology","title":"Soil BC Methods and Types","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Energy and Hydrology","title":"Soil Energy and Hydrology","text":"ClimaLand.Soil.MoistureStateBC\nClimaLand.Soil.HeatFluxBC\nClimaLand.Soil.WaterFluxBC\nClimaLand.Soil.TemperatureStateBC\nClimaLand.Soil.FreeDrainage\nClimaLand.Soil.RichardsAtmosDrivenFluxBC\nClimaLand.Soil.AtmosDrivenFluxBC\nClimaLand.Soil.WaterHeatBC\nClimaLand.Soil.soil_boundary_fluxes!","category":"page"},{"location":"APIs/Soil/#ClimaLand.Soil.MoistureStateBC","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.MoistureStateBC","text":"MoistureStateBC <: AbstractWaterBC\n\nA simple concrete type of boundary condition, which enforces a state boundary condition ϑ_l = f(p,t) at either the top or bottom of the domain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.HeatFluxBC","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.HeatFluxBC","text":"HeatFluxBC <: AbstractHeatBC\n\nA simple concrete type of boundary condition, which enforces a normal flux boundary condition f(p,t) at either the top or bottom of the domain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.WaterFluxBC","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.WaterFluxBC","text":"WaterFluxBC <: AbstractWaterBC\n\nA simple concrete type of boundary condition, which enforces a normal flux boundary condition f(p,t) at either the top or bottom of the domain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.TemperatureStateBC","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.TemperatureStateBC","text":"TemperatureStateBC <: AbstractHeatBC\n\nA simple concrete type of boundary condition, which enforces a state boundary condition T = f(p,t) at either the top or bottom of the domain.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.FreeDrainage","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.FreeDrainage","text":"FreeDrainage <: AbstractWaterBC\n\nA concrete type of soil boundary condition, for use at the BottomBoundary only, where the flux is set to be F = -K∇h = -K.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.RichardsAtmosDrivenFluxBC","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.RichardsAtmosDrivenFluxBC","text":"RichardsAtmosDrivenFluxBC{F <: PrescribedPrecipitation, R <: AbstractRunoffModel} <: AbstractWaterBC\n\nA concrete type of boundary condition intended only for use with the RichardsModel, which uses a prescribed precipitation rate (m/s) to compute the infiltration into the soil.\n\nA runoff model is used to simulate surface and subsurface runoff and this is accounted for when setting boundary conditions. In order to run the simulation without runoff, choose runoff = NoRunoff() - this is also the default.\n\nIf you wish to simulate precipitation and runoff in the full EnergyHydrology model, you must use the AtmosDrivenFluxBC type.\n\nprecip: The prescribed liquid water precipitation rate f(t) (m/s); Negative by convention.\nrunoff: The runoff model. The default is no runoff.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.AtmosDrivenFluxBC","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.AtmosDrivenFluxBC","text":"AtmosDrivenFluxBC{\n    A <: AbstractAtmosphericDrivers,\n    B <: AbstractRadiativeDrivers,\n    R <: AbstractRunoffModel,\n    C::Tuple\n} <: AbstractEnergyHydrologyBC\n\nA concrete type of soil boundary condition for use at the top of the domain. This holds the conditions for the atmosphere AbstractAtmosphericDrivers, for the radiation state AbstractRadiativeDrivers. This is only supported for the EnergyHydrology model.\n\nThis choice indicates the Monin-Obukhov Surface Theory will be used to compute the sensible and latent heat fluxes, as well as evaporation,  and that the net radiation and precipitation will also be computed. The net energy and water fluxes are used as boundary conditions.\n\nA runoff model is used to simulate surface and subsurface runoff and this is accounted for when setting boundary conditions. The default is to have no runoff accounted for.\n\nFinally, because this same boundary condition type is used for the soil in integrated land surface models, we also provide a tuple of symbols indicating the prognostic land components present, as these affect how the boundary conditions are computed. The default is a tuple containing only (:soil,), indicating a standalone soil run.\n\nFor more information on the allowed values, please see the documentation\n\natmos: The atmospheric conditions driving the model\nradiation: The radiative fluxes driving the model\nrunoff: The runoff model. The default is no runoff.\nprognostic_land_components: Prognostic land components present\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.WaterHeatBC","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.WaterHeatBC","text":"WaterHeatBC{W <: AbstractWaterBC, H <: AbstractHeatBC} <:\n   AbstractEnergyHydrologyBC\n\nA general struct used to store the boundary conditions for Richards and the soil heat equations separately; useful when the boundary conditions for each component are independent of each other.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.soil_boundary_fluxes!","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.soil_boundary_fluxes!","text":"soil_boundary_fluxes!(bc::WaterHeatBC, boundary::AbstractBoundary, model, Δz, Y, p, t)\n\nupdates the boundary fluxes for ϑl and ρeint.\n\n\n\n\n\nsoil_boundary_fluxes!(\n    bc::AtmosDrivenFluxBC{\n        <:PrescribedAtmosphere,\n        <:PrescribedRadiativeFluxes,\n    },\n    boundary::ClimaLand.TopBoundary,\n    model::EnergyHydrology,\n    Δz,\n    Y,\n    p,\n    t,\n)\n\nReturns the net volumetric water flux (m/s) and net energy flux (W/m^2) for the soil EnergyHydrology model at the top of the soil domain.\n\nThis function calls the turbulent_fluxes and net_radiation functions, which use the soil surface conditions as well as the atmos and radiation conditions in order to compute the surface fluxes using Monin Obukhov Surface Theory. It also accounts for the presence of other components, if run as part of an integrated land model, and their effect on boundary conditions.\n\n\n\n\n\nsoil_boundary_fluxes!(\n    bc::AtmosDrivenFluxBC{\n        <:PrescribedAtmosphere,\n        <:PrescribedRadiativeFluxes,\n    },\n    prognostic_land_components::Val{(:soil,)},\n    model::EnergyHydrology,\n    Y,\n    p,\n    t,\n)\n\nReturns the net volumetric water flux (m/s) and net energy flux (W/m^2) for the soil EnergyHydrology model at the top of the soil domain.\n\nHere, the soil boundary fluxes are computed as if the soil is run in standalone mode.\n\n\n\n\n\nsoil_boundary_fluxes!(\n    bc::AtmosDrivenFluxBC{<:PrescribedAtmosphere, <:PrescribedRadiativeFluxes},\n    prognostic_land_components::Val{(:canopy, :soil,:soilco2,)},\n    soil::EnergyHydrology{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nA method of ClimaLand.Soil.soil_boundary_fluxes! which is used for integrated land surface models; this computes and returns the net energy and water flux at the surface of the soil for use as boundary conditions when a canopy and Soil CO2  model is also included, though only the presence of the canopy modifies the soil BC.\n\n\n\n\n\nsoil_boundary_fluxes!(\n    bc::AtmosDrivenFluxBC{<:PrescribedAtmosphere, <:PrescribedRadiativeFluxes},\n     prognostic_land_components::Val{(:snow, :soil)},\n    soil::EnergyHydrology{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nA method of ClimaLand.Soil.soil_boundary_fluxes! which is used for integrated land surface models; this computes and returns the net energy and water flux at the surface of the soil for use as boundary conditions, taking into account the presence of snow on the surface.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Soil/#Soil-Source-Types","page":"Soil Energy and Hydrology","title":"Soil Source Types","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Energy and Hydrology","title":"Soil Energy and Hydrology","text":"ClimaLand.Soil.AbstractSoilSource\nClimaLand.Soil.PhaseChange\nClimaLand.Soil.RootExtraction","category":"page"},{"location":"APIs/Soil/#ClimaLand.Soil.AbstractSoilSource","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.AbstractSoilSource","text":"AbstractSoilSource{FT} <:  ClimaLand.AbstractSource{FT}\n\nAn abstract type for types of source terms for the soil equations.\n\nIn standalone mode, the only supported source type is freezing and thawing. ClimaLand.jl creates additional sources to include as necessary e.g. root extraction (not available in stand alone mode).\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#ClimaLand.Soil.PhaseChange","page":"Soil Energy and Hydrology","title":"ClimaLand.Soil.PhaseChange","text":"PhaseChange{FT} <: AbstractSoilSource{FT}\n\nPhaseChange source type.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Soil/#Soil-Jacobian-Structures","page":"Soil Energy and Hydrology","title":"Soil Jacobian Structures","text":"","category":"section"},{"location":"APIs/Soil/","page":"Soil Energy and Hydrology","title":"Soil Energy and Hydrology","text":"ClimaLand.Soil.ImplicitEquationJacobian","category":"page"},{"location":"APIs/Soil/#ClimaLand.ImplicitEquationJacobian","page":"Soil Energy and Hydrology","title":"ClimaLand.ImplicitEquationJacobian","text":"ImplicitEquationJacobian{M, S}\n\nA struct containing the necessary information for constructing a block Jacobian matrix used for implicit timestepping.\n\nmatrix is a block matrix containing one block on the diagonal for each     variable in the model. solver is a diagonal solver because our matrix is block diagonal.\n\nNote that the diagonal, upper diagonal, and lower diagonal entry values are stored in this struct and updated in place.\n\n\n\n\n\n","category":"type"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/#Radiative-transfer-scheme","page":"Beer model","title":"Radiative transfer scheme","text":"","category":"section"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"This section describes multiple models of radiative transfer  through the vegetation canopy, implemented in ClimaLand. ","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/#Beer's-law","page":"Beer model","title":"Beer's law","text":"","category":"section"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"Plants utilize Photosynthetically Active Radiation (PAR) for the process of photosynthesis, during which they convert light energy into chemical energy, fueling the synthesis of sugars and other organic compounds. PAR refers to the portion of the electromagnetic spectrum that is essential for photosynthesis in plants. PAR includes wavelengths ranging from approximately 400 to 700 nanometers and corresponds to the visible light spectrum. The unit used to measure PAR is called micromoles per square meter per second (μmol/m²/s), representing the number of photons within the PAR range that strike a square meter of a surface per second.","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"The portion of PAR that is actually absorbed by the vegetation canopy for photosynthesis is called Absorbed Photosynthetically Active Radiation (APAR). The APAR driving photosynthesis is calculated following the Beer- Lambert law:","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"APAR(PAR theta_s) = (PAR)(1 - rho_leaf)(1 - e^(-K(theta_s) LAI  Omega))","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"where PAR ≈ SW/2 is the incident moles of photons per meter squared per second in the PAR window, approximated as half of the incident shortwave flux. If PAR is not directly available, ρ_leaf is the PAR canopy reflectance, K is the vegetation extinction coefficient following Campbell (1998), LAI is the leaf area index, θ_s is the zenith angle, and Ω is the clumping index following Braghiere (2021). K, Ω and ρ_leaf are all unitless. LAI is in m² m⁻². In order to compute K, we need θ_s in radians and the leaf angle distribution l_d (unitless). K is then defined as","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"K = l_dmax(cos(theta_s) epsilon)","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"so that at night, when 3π/2 > θ_s > π/2, K is large (lots of extinction) and non-negative. The small value ε prevents dividing by zero.","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"The model has the following parameters:","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"Output Symbol Unit Range\nAbsorbed Photosynthetically Active Radiation APAR μmol m⁻² s⁻¹ 0-1500","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"Drivers Symbol Unit Range\nPhotosynthetically Active Radiation PAR μmol m⁻² s⁻¹ 0–1500\nLeaf Area Index LAI m² m⁻² 0–10","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"Parameters Symbol Unit Range\nCanopy reflectance ρ_leaf - 0.0–1.0\nExtinction coefficient K - 0.0–1.0\nClumping index Ω - 0.0–1.0\nZenith angle θ_s rad 0–π","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"Constants Symbol Unit Value\nLeaf angle distribution l_d - 0.5","category":"page"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/#Interactive-APAR(PAR,-LAI,-ρ_{leaf},-K,-Ω)","page":"Beer model","title":"Interactive APAR(PAR, LAI, ρ_leaf, K, Ω)","text":"","category":"section"},{"location":"standalone/pages/vegetation/radiative_transfer/beer_model/","page":"Beer model","title":"Beer model","text":"<iframe src=\"https://clima.westus3.cloudapp.azure.com/jsserve/beer_APAR\"\n   style=\"height:1400px;width:100%;\">\n</iframe>","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Soil/freezing_front/#Modeling-a-freezing-front-in-unsaturated-soil","page":"Phase Changes","title":"Modeling a freezing front in unsaturated soil","text":"","category":"section"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Before reading this tutorial, we recommend that you look over the coupled energy and water tutorial. That tutorial showed how to solve the heat equation for soil volumetric internal energy ρe_int, simultaneously with Richards equation for volumetric liquid water fraction ϑ_l, assuming zero volumetric ice fraction θ_i for all time, everywhere in the domain. In this example, we add in a source term to the right hand side for both θ_i and ϑ_l which models freezing and thawing and conserves water mass during the process. The equations are","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"frac ρe_int t =    κ(θ_l θ_i ν ) T +   ρe_int_liq K (Tθ_l θ_i ν ) nabla h( ϑ_l z ν )","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"frac  ϑ_l t =   K (Tθ_l θ_i ν ) h( ϑ_l z ν ) -fracF_Tρ_l","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"frac  θ_i t = fracF_Tρ_i","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Here","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"t is the time (s),","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"z is the location in the vertical (m),","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"ρe_int is the volumetric internal energy of the soil (J/m^3),","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"T is the temperature of the soil (K),","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"κ is the thermal conductivity (W/m/K),","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"ρe_int_liq is the volumetric internal energy of liquid water (J/m^3),","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"K is the hydraulic conductivity (m/s),","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"h is the hydraulic head (m),","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"ϑ_l is the augmented volumetric liquid water fraction,","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"θ_i is the volumetric ice fraction,","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"ν  denotes parameters relating to soil type, such as porosity, and","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"F_T is the freeze-thaw term.","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"To begin, we will show how to implement adding in this source term. After the results are obtained, we will explain how our model parameterizes this effect and compare the results with some analytic expections.","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"We solve these equations in an effectively 1-d domain with z  -020, and with the following boundary and initial conditions:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"- κ T(t z = 0) = 28 Wm^2K (T - 26715K) ẑ","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"- κ T(t z= -02) =  -3 Wm^2K (T - 27985K) ẑ","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"T(t = 0 z) = 27985 K","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"- K h(t z = 0) = 0 ẑ","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"-K h(t z = -02) = 0 ẑ","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"ϑ_l(t = 0 z) = 033.","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"The problem setup and soil properties are chosen to match the lab experiment of Mizoguchi (1990), as detailed in Hansson (2004) and Dall'Amico (2011). Like Hansson et al., we allow for a small amount of energy leakage at the bottom of the domain to account for imperfect insulation.","category":"page"},{"location":"generated/standalone/Soil/freezing_front/#Import-necessary-modules","page":"Phase Changes","title":"Import necessary modules","text":"","category":"section"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"import SciMLBase\nimport ClimaTimeSteppers as CTS\nusing DelimitedFiles\nusing CairoMakie\n\nusing ClimaCore\nimport ClimaParams as CP\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\n\nimport ClimaLand\nimport ClimaLand.Parameters as LP","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Preliminary set-up","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Choose a floating point precision, and get the parameter set, which holds constants used across CliMA models:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"FT = Float32","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Float32","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Set the values of other parameters required by the model:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"ν = FT(0.535)\nK_sat = FT(3.2e-6) # m/s\nS_s = FT(1e-3) #inverse meters\nvg_n = FT(1.48)\nvg_α = FT(1.11) # inverse meters\nhydrology_cm = vanGenuchten{FT}(; α = vg_α, n = vg_n);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"You could also try the Brooks and Corey model:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"#ψb = FT(-0.6)\n#c = FT(0.43)\n#hcm = BrooksCorey(;ψb = ψb, c = c);\nθ_r = FT(0.05)\nν_ss_om = FT(0.3)\nν_ss_quartz = FT(0.7)\nν_ss_gravel = FT(0.0)\nparams = Soil.EnergyHydrologyParameters(\n    FT;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm,\n    K_sat,\n    S_s,\n    θ_r,\n);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Choose the domain and discretization:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"zmax = FT(0)\nzmin = FT(-0.2)\nnelems = 20\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Set the boundary conditions:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"zero_water_flux_bc = WaterFluxBC((p, t) -> 0.0)\nfunction top_heat_flux(p, t)\n    FT = eltype(p.soil.T)\n    p_len = ClimaCore.Spaces.nlevels(axes(p.soil.T))\n    T_c = ClimaCore.Fields.level(p.soil.T, p_len)\n    return @. FT(28 * (T_c - 267.15))\nend\nfunction bottom_heat_flux(p, t)\n    FT = eltype(p.soil.T)\n    T_c = ClimaCore.Fields.level(p.soil.T, 1)\n    return @. FT(-3 * (T_c - 279.85))\nend\ntop_heat_flux_bc = HeatFluxBC(top_heat_flux)\nbottom_heat_flux_bc = HeatFluxBC(bottom_heat_flux)\nboundary_fluxes = (;\n    top = WaterHeatBC(; water = zero_water_flux_bc, heat = top_heat_flux_bc),\n    bottom = WaterHeatBC(;\n        water = zero_water_flux_bc,\n        heat = bottom_heat_flux_bc,\n    ),\n);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Create the source term instance. Our phase change model requires knowledge of the vertical spacing, so we pass that information in via an attribute of the PhaseChange structure. Sources are added as elements of a list of sources. Here we just add freezing and thawing.","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"sources = (PhaseChange{FT}(),);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Now we can package this up in the EnergyHydrology model struct:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"soil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/#Running-a-simulation","page":"Phase Changes","title":"Running a simulation","text":"","category":"section"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Once we have the model, we can initialize the state vectors and obtain the coordinates","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Y, p, coords = initialize(soil);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"After which, we can specify the initial condition function, and initialze the variables:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"function init_soil!(Ysoil, z, params)\n    ν = params.ν\n    FT = eltype(Ysoil.soil.ϑ_l)\n    Ysoil.soil.ϑ_l .= FT(0.33)\n    Ysoil.soil.θ_i .= FT(0.0)\n    T = FT(279.85)\n    ρc_s = Soil.volumetric_heat_capacity(\n        FT(0.33),\n        FT(0.0),\n        params.ρc_ds,\n        params.earth_param_set,\n    )\n    Ysoil.soil.ρe_int .=\n        Soil.volumetric_internal_energy.(\n            FT(0.0),\n            ρc_s,\n            T,\n            params.earth_param_set,\n        )\nend\n\ninit_soil!(Y, coords.subsurface.z, soil.parameters);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"We choose the initial and final simulation times:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"t0 = Float64(0)\ntf = Float64(60 * 60 * 50);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"We set the cache values corresponding to the initial conditions of the state Y:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"set_initial_cache! = make_set_initial_cache(soil);\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Create the tendency function, and choose a timestep, and timestepper:","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"exp_tendency! = make_exp_tendency(soil)\nimp_tendency! = make_imp_tendency(soil);\njacobian! = ClimaLand.make_jacobian(soil);\njac_kwargs = (; jac_prototype = ImplicitEquationJacobian(Y), Wfact = jacobian!);\n\ndt = Float64(100)\n\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 3,\n        update_j = CTS.UpdateEvery(CTS.NewTimeStep),\n    ),\n);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Problem definition and callbacks","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"prob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Now we can solve the problem.","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"sol = SciMLBase.solve(prob, ode_algo; dt = dt, saveat = 0:3600:tf);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/#Comparison-to-data","page":"Phase Changes","title":"Comparison to data","text":"","category":"section"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"This data was obtained by us from the figures of Hansson et al. (2004), but was originally obtained by Mizoguchi (1990). No error bars were reported, and we haven't quantified the error in our estimation of the data from images.","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"dataset_path = ClimaLand.Artifacts.mizoguchi1990_soil_freezing_data();\nds = readdlm(dataset_path, ',')\nhours = ds[:, 1][2:end]\nvwc = ds[:, 2][2:end] ./ 100.0\ndepth = ds[:, 3][2:end]\nmask_12h = hours .== 12\nmask_24h = hours .== 24\nmask_50h = hours .== 50;\n\nfig = Figure(size = (900, 300))\nax1 = Axis(\n    fig[1, 1],\n    title = \"12 hours\",\n    xlabel = L\"θ_l + θ_i\",\n    ylabel = \"Soil depth (m)\",\n)\nlimits!(ax1, 0.2, 0.5, -0.2, 0.0)\nax2 = Axis(\n    fig[1, 2],\n    title = \"24 hours\",\n    xlabel = L\"θ_l + θ_i\",\n    yticksvisible = false,\n    yticklabelsvisible = false,\n)\nlimits!(ax2, 0.2, 0.5, -0.2, 0.0)\nax3 = Axis(\n    fig[1, 3],\n    title = \"50 hours\",\n    xlabel = L\"θ_l + θ_i\",\n    yticksvisible = false,\n    yticklabelsvisible = false,\n)\nlimits!(ax3, 0.2, 0.5, -0.2, 0.0)\n\n\nz = parent(coords.subsurface.z)[:];\n\nscatter!(ax1, vwc[mask_12h], -depth[mask_12h], label = \"\", color = \"purple\")\nlines!(\n    ax1,\n    parent(sol.u[13].soil.ϑ_l .+ sol.u[13].soil.θ_i)[:],\n    z,\n    label = \"\",\n    color = :green,\n)\n\n\nscatter!(ax2, vwc[mask_24h], -depth[mask_24h], label = \"\", color = \"purple\")\nlines!(\n    ax2,\n    parent(sol.u[25].soil.ϑ_l .+ sol.u[25].soil.θ_i)[:],\n    z,\n    label = \"\",\n    color = :green,\n)\n\nscatter!(ax3, vwc[mask_50h], -depth[mask_50h], label = \"Data\", color = \"purple\")\nlines!(\n    ax3,\n    parent(sol.u[51].soil.ϑ_l .+ sol.u[51].soil.θ_i)[:],\n    z,\n    label = \"Simulation\",\n    color = :green,\n)\naxislegend(ax3, position = :rb)\n\nsave(\"mizoguchi_data_comparison.png\", fig);","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/freezing_front/#Discussion-and-Model-Explanation","page":"Phase Changes","title":"Discussion and Model Explanation","text":"","category":"section"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"To begin, let's observe that the freeze thaw source term alone conserves water mass, as it satisfies","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"ρ_l partial_tϑ_l + ρ_i partial_tθ_i = -F_T + F_T = 0","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Next, we describe how we define F_T. The Clausius-Clapeyron (CC) equation defines a pressure-temperature curve along which two phases can co-exist. It assumes that the phases are at equal temperature and pressures. For water in soil, however, the liquid water experiences pressure ρ_l g ψ, where ψ is the matric potential. A more general form of the CC equation allows for different pressures in the two phases. Usually the ice pressure is taken to be zero, which is reasonable for unsaturated freezing soils. In saturated soils, freezing can lead to heaving of the soil which we do not model. After that assumption is made, we obtain that, below freezing (T  T_f)","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"fracdp_lρ_l = L_f fracdTT","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"or","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"p_l = p_l0 + L_f ρ_l fracT-T_fT_f mathcalH(T_f-T)","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"where we have assumed that assumed T is near the freezing point, and then performed a Taylor explansion of the logarithm, and we are ignoring the freezing point depression, which is small (less than one degree) for non-clay soils. What we have sketched is further explained in Dall'Amico et al. (2011) and Kurylyk and Watanabe (2013).","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"What this implies is that above the freezing point, the pressure is equal to p_l0, which is independent of temperature. Once the temperature drops below the freezing point, the pressure drops. Since prior to freezing, the pressure p_l0 is equal to ρ_l g ψ(θ_l), water undergoing freezing alone (without flowing) should satisfy (Dall'Amico et al. (2011)):","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"p_l0 = ρ_l g ψ(θ_l+ρ_iθ_iρ_l)","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"where ψ is the matric potential function of van Genuchten. At each step, we know both the water and ice contents, as well as the temperature, and can then solve for","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"θ_l^* = (ν-θ_r) ψ^-1(p_l(ρ_l g)) + θ_r","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"For freezing, the freeze thaw function F_T is equal to","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"F_T = frac1τ ρ_l (θ_l-θ_l^*) mathcalH(T_f-T) mathcalH(θ_l-θ_l^*)","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"which brings the θ_l to a value which satisfies p_l = ρ_l g ψ(θ_l). This is why, in our simulation, we see the liquid water fraction approaches a constant around 0.075 in the frozen region, rather than the residual fraction of 0.019, or 0. This behavior is observed, for example, in the experiments of Watanabe et al. (2011).","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Although this approach may indicate that we should replace the pressure head appearing in the diffusive water flux term in Richards equation (Dall'Amico et al. (2011)), we do not do so at present. As such, we may not be modeling the flow of water around the freezing front properly. However, we still observe cryosuction, which is the flow of water towards the freezing front, from the unfrozen side. As the water freezes, the liquid water content drops, setting up a larger gradient in matric potential across the freezing front, which generates upward flow against gravity. This is evident because the total water content at the top is larger at the end of the simulation than it was at t=0 (when it was 0.33).","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"This model differs from others (e.g. Painter and Karra (2014), Hansson et al. (2004), Dall'Amico et al. (2011))  in that it requires us to set a timescale for the phase change, τ. We currently use the thermal time","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"τ_LTE= c Δz²κ","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"which seems to work adequately for modeling freezing front propagation and cryosuction, via comparisons with Mizoguchi (1990).","category":"page"},{"location":"generated/standalone/Soil/freezing_front/#References","page":"Phase Changes","title":"References","text":"","category":"section"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"Mizoguchi, M., 1990. Water, heat and salt transport in freezing soil. Ph.D. thesis. (In Japanese.) University of Tokyo.\nHansson et al., Vadose Zone Journal 3:693–704 (2004).\nM. Dall’Amico et al., The Cryosphere, 5, 469–484 (2011).\nKurylyk and Watanabe, Advances in Water Resources, Volume 60, (2013)\nWatanabe et al. 2011, Annals of Glaciology , Volume 52 , Issue 58\nPainter and Karra, Vadose Zone Journal (2014) 13 (4)","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"","category":"page"},{"location":"generated/standalone/Soil/freezing_front/","page":"Phase Changes","title":"Phase Changes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/#Scraping-SNOTEL-Data","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"","category":"section"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"This tutorial shows you how to make use of the code developed for scraping SNOTEL site data in order to generate datasets for use in training artificial intelligence models for seasonal snow forecasting. The code below contains a basic version of the code used to produce training_data.csv, which is used in the base tutorial for snow forecasting, as well as the paper. However, exploration of the optional arguments or requesting of alternative SNOTEL data codes offers additional utility in creating alternative data sets for further investigation.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"We begin by importing all required packages:","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"using ClimaLand\nusing DataFrames, CSV, HTTP, Dates, Flux, StatsBase, cuDNN","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"The code lives in an extenson that we have to manually load. The extension can be loaded only if \"CSV\", \"HTTP\", \"Flux\", \"StatsBase\", \"cuDNN\" and \"ClimaLand\" are loaded.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"DataTools = Base.get_extension(ClimaLand, :NeuralSnowExt).DataTools;","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"We first extract a DataFrame matching station ID to various station metadata, in order to automate some of the scraping process and pass some station metadata that is used for analysis in the paper. This resulting DataFrame can also be used to see other available SNOTEL station IDs for scraping, in order to create custom datasets.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"metadata = DataTools.snotel_metadata();\nmetacols = [\"id\", \"name\", \"state\", \"elev\", \"lat\", \"lon\"]\nDataFrames.rename!(metadata, Symbol.(metacols));","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"At the most user-friendly level, the function scrape_site_paper() provides a wrapper to scrape SNOTEL data in the exact same manner as the paper (it may take a minute or two per site). This function handles all special cases and data processing, allowing the user to only pass a SNOTEL ID number and associated state code to retrieve the same data as that used in the paper. However, this will likely not work or yield unexpected results for sites not used in the paper. Here is an example for how to use the metadata to streamline the process:","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"example_ID = 1030\nexample_state = metadata[findfirst(==(example_ID), metadata[!, :id]), :state]\nexample_data = DataTools.scrape_site_paper(example_ID, example_state);","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"And that's it! This can be iterated within a loop to gather the data for all sites. However, while straightforward, this wrapper obfuscates many of the underlying steps, or some of the opportunities for using different arguments to generate custom datasets. As such, we can reimplement much of the same code in more detail below to enable more advanced usage.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"We first define constants that will be used in the cleaning of the SNOTEL data, such as conversion constants from imperial to metric units, and the sensor limits defined in the SNOTEL Engineering Handbook. Some SNOTEL sensors measure in imperial units, and some measure in metric units, and the data portal will round converted values if a sensor stream is requested in units other than its original measurement. Therefore, we will scrape data in the originally measured units to limit systemic errors.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"const inch2meter = 0.0254\nconst kmphr2mps = 5.0 / 18.0\n\nfilter_val = Dict{Symbol, Tuple{Real, Real}}(\n    :SWE => (0.0, 250.0),\n    :z => (0.0, 420.0),\n    :precip => (0.0, 250.0),\n    :rel_hum_avg => (10.0, 100.0),\n    :sol_rad_avg => (0.0, 1500.0),\n    :wind_speed_avg => (0.0, 216.0),\n    :air_temp_avg => (-40.0, 60.0),\n)\n\nscales = Dict{Symbol, Real}(\n    :SWE => inch2meter,\n    :z => inch2meter,\n    :precip => inch2meter,\n    :rel_hum_avg => 0.01,\n    :wind_speed_avg => kmphr2mps,\n);","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"We next proceed to outline which stations will be scraped by defining a dictionary of station IDs, paired with the date range to be scraped if a custom range is desired. \"start\" refers to 1850-01-01 or the first available date, while \"end\" refers to the earlier option bewteen 2024-02-01 or the last available date. Most of these stations are commented out for the sake of speed and readability in generating the tutorial, or due to special handling required, but can be uncommented to yield the full dataset (if special cases are handled) found in training_data.csv used in the base tutorial. Stations were selected based upon their availability of the features utilized in creating the model used in the paper:","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"* Indicates alternative handling of the rectify_daily_hourly() function.\n^ Indicates usage of RHUM flag instead of RHUMV flag for relative humidity.\nA Indicates an Alaskan site, which is in the testing data, not the training data, and uses a lower temperature bound of -50 instead of -40 in filter_val.\nT Requires a site that already has had the temperature bias correction at the portal level as of May 2024.\nX Indicates a SNOTEL portal error when trying to scrape into 2024, as of May 2024.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"good_stations = Dict{Int, Tuple{String, String}}(\n    #306 => (\"start\", \"end\"), #*\n    316 => (\"start\", \"end\"),\n    344 => (\"start\", \"end\"),\n    #=367 => (\"start\", \"end\"),\n    395 => (\"start\", \"end\"),\n    457 => (\"start\", \"end\"),\n    482 => (\"start\", \"end\"),\n    491 => (\"start\", \"end\"),\n    515 => (\"start\", \"2023-06-02\"), #X\n    532 => (\"start\", \"end\"),\n    551 => (\"start\", \"end\"),\n    571 => (\"start\", \"end\"),\n    599 => (\"start\", \"end\"),\n    608 => (\"start\", \"end\"),\n    613 => (\"start\", \"end\"),\n    641 => (\"start\", \"end\"), #A^\n    665 => (\"start\", \"end\"),\n    708 => (\"start\", \"end\"),\n    715 => (\"start\", \"end\"),\n    734 => (\"start\", \"end\"),\n    737 => (\"start\", \"end\"),\n    744 => (\"start\", \"end\"),\n    832 => (\"start\", \"end\"),\n    845 => (\"start\", \"end\"),\n    854 => (\"start\", \"end\"),\n    857 => (\"start\", \"end\"),\n    921 => (\"start\", \"end\"),\n    922 => (\"start\", \"end\"),\n    927 => (\"start\", \"end\"),\n    942 => (\"start\", \"end\"),\n    963 => (\"start\", \"end\"), #A^\n    969 => (\"start\", \"end\"),\n    974 => (\"start\", \"end\"),\n    978 => (\"start\", \"end\"), #*\n    1030 => (\"start\", \"end\"),\n    1035 => (\"start\", \"end\"), #A^\n    1053 => (\"start\", \"end\"),\n    1070 => (\"start\", \"end\"), #A^T\n    1083 => (\"start\", \"end\"),\n    1091 => (\"start\", \"end\"), #A^T\n    1092 => (\"start\", \"end\"), #A^T\n    1105 => (\"start\", \"end\"),\n    1122 => (\"start\", \"end\"), #*\n    1123 => (\"start\", \"end\"),\n    1159 => (\"start\", \"end\"),\n    1168 => (\"start\", \"end\"),\n    1170 => (\"start\", \"end\"),\n    1254 => (\"start\", \"end\"),\n    1286 => (\"start\", \"end\"),\n    2080 => (\"start\", \"end\"), #A^\n    2170 => (\"start\", \"end\"), #^\n    =#\n);","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"We then loop through each site to scrape and follow an automated data pipeline, consisting of:","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"Extracting the daily and hourly timeseries from the site\nApplying the sensor bounds over each data timeseries (i.e. remove sensor error)\nConverting the hourly dataset into a daily dataset\nCoalescing the converted-hourly and daily data into one dataset\nScaling all data to the appropriate metric units\nRestricting data to complete cases\nMaking the differential variables ( fracdzdt, etc.)\nResetting negative precipitation cases (i.e. where the water year resets), and using daily precipitation rates dprecipdt instead of accumulated precipitation precip\nAttaching appropriate metadata","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"A few steps are commented out, which indicate steps implemented in scrape_site_paper() like quality-control measures, which could be substituted with other user-defined steps.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"allsites = Any[];\nfor site in sort(collect(keys(good_stations)))\n    state = metadata[metadata[!, :id] .== site, :state][1]\n    start_date = good_stations[site][1]\n    end_date = good_stations[site][2]\n\n    hourly = DataTools.apply_bounds(\n        DataTools.sitedata_hourly(\n             site,\n            state,\n            start = start_date,\n            finish = end_date,\n        ),\n       filter_val,\n    )\n    hourly[!, :id] .= site\n    #hourly = DataTools.bcqc_hourly(hourly)\n    hourly_d = DataTools.hourly2daily(hourly)\n    #DataFrames.allowmissing!(hourly_d)\n    #sflags = DataTools.qc_filter(hourly_d, :sol_rad_avg, t1 = 2)\n   #hourly_d[sflags, :sol_rad_avg] .= missing\n\n    daily = DataTools.apply_bounds(\n        DataTools.sitedata_daily(\n            site,\n            state,\n            start = start_date,\n            finish = end_date,\n        ),\n        filter_val,\n    )\n    daily[!, :id] .= site\n    gap_daily = DataTools.rectify_daily_hourly(daily, hourly_d)\n    #gap_daily = DataTools.bcqc_daily(gap_daily, site, state)\n    #gap_daily = DataTools.d_impute(gap_daily)\n    daily_scaled = DataTools.scale_cols(gap_daily, scales)\n    daily_clean = daily_scaled[completecases(daily_scaled), :]\n    daily_clean = DataTools.makediffs(daily_clean, Day(1))\n    good_vals = daily_clean[!, :dprecipdt] .>= 0.0\n    daily_clean[(!).(good_vals), :dprecipdt] .= 0.0\n    daily_clean = daily_clean[!, Not(:precip)]\n    #show(describe(daily_clean), allrows = true, allcols = true)\n    #print(\"\\nSIZE: \", nrow(daily_clean), \"\\n\")\n\n    daily_clean[!, :id] .= site\n    daily_clean[!, :elev] .= metadata[metadata[!, :id] .== site, :elev][1]\n    daily_clean[!, :lat] .= metadata[metadata[!, :id] .== site, :lat][1]\n    daily_clean[!, :lon] .= metadata[metadata[!, :id] .== site, :lon][1]\n\n    push!(allsites, daily_clean)\nend;","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"With the sites complete, we condense all sites into a single DataFrame,","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"totaldata = deepcopy(allsites[1])\nfor site in allsites[2:end]\n    append!(totaldata, site)\nend","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"and a final CSV.write(\"data.csv\", totaldata) call will save the file.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"Many of the functions above contain default or optional arguments which can be explored to obtain a richer set of functionality, or implement some of the special cases mentioned above. Such options can be explored in the code documentation.","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"","category":"page"},{"location":"generated/standalone/Snow/data_tutorial/","page":"Scraping SNOTEL Data","title":"Scraping SNOTEL Data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/#Setting-up-a-Coupled-Simulation","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"","category":"section"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"For more information about the bucket model, please see the bucket model tutorial.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"This tutorial shows how to set up a simulation for a coupled simulation. More detail for coupled runs can be found in the ClimaCoupler.jl documentation. In preparation for understanding this tutorial, we recommend also reading the intro to multi-component models tutorial as well as being familiar with multiple dispatch programming in Julia.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/#Background","page":"Setting up a Coupled Simulation","title":"Background","text":"","category":"section"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"Recall that in order to drive the system in standalone mode, the user must provide prescribed functions of time for the water volume flux in precipitation,  for the net downward shortwave and longwave radiative energy fluxes, for the atmospheric temperature T_a, wind speed u_a (m/s), specific humidity q_a, and air density ρ_a (kg/m^3) at a reference height h_a (m).","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"Turbulent surface fluxes are computed by the bucket model at each step of the simulation, using the land surface properties as well as the prescribed atmospheric properties, according to Monin-Obukhov theory. These fluxes, as well as the net radiation, are stored in the auxiliary state of the bucket model: p.bucket.turbulent_fluxes.lhf, p.bucket.turbulent_fluxes.shf, p.bucket.turbulent_fluxes.vapor_flux, p.bucket.R_n, where they are accessible when boundary conditions are required in the ODE functions (right hand side) of the prognostic equations. Similarily, the precipitation rates are provided from prescribed conditions and stored in p.drivers.P_liq, p.drivers.P_snow.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"In a coupled simulation, this changes. The coupler computes turbulent surface fluxes based on information (prognostic state, parameters) passed to it by both the atmosphere and land models. Net radiation is computed within the atmosphere model, using the prognostic land surface temperature and the land surface albedo, and passed back to the land model via the coupler. These details are important, but from the point of view of the land model, we only need to know that the coupler accesses land model variables to compute fluxes, and that the coupler passes these fluxes back to the land model.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"In our current setup, \"passed back to the land model via the coupler\" means that the coupler accesses the auxiliary state of the land model and modifies it, at each step in the simulation, so that it holds the current net radiation, precipitation, and turbulent surface fluxes (p.bucket.turbulent_fluxes, p.bucket.R_n, p.drivers.P_liq, p.drivers.P_snow). These quantities are then still available in the ODE functions of the prognostic equations for the bucket model, as in the standalone case.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"In order for the land model to be able to run both in standalone mode, and a coupled mode, within a single interface, we make use of multiple dispatch.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/#Turbulent-Surface-Fluxes-and-Radiation","page":"Setting up a Coupled Simulation","title":"Turbulent Surface Fluxes and Radiation","text":"","category":"section"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"Let's review how turbulent surface fluxes and radiation are computed by the land model. The user first creates the prescribed atmosphere and prescribed radiation drivers. In pseudo code, this might look something like:","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"prescribed_atmos = PrescribedAtmosphere{FT}(*driver data passed in here*)\nprescribed_radiation = PrescribedRadiativeFluxes{FT}(*driver data passed in here*)","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"These are stored in the BucketModel object, along with BucketParameters. In order to compute turbulent surface fluxes, we call turbulent_fluxes, with arguments including prescribed_atmos. Since this argument is of the type PrescribedAtmosphere, the method of turbulent_fluxes which is executed is one which computes the turbulent surface fluxes using MOST. We have a similar function for net_radiation and which computes the net radiation based on the prescribed downwelling radiative fluxes, stored in an argument prescribed_radiation, which is of type PrescribedRadiation.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"In the coupled case, we want different behavior. We have defined new coupled types to use instead of the \"prescribed\" types:","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"struct CoupledAtmosphere{FT} <: AbstractAtmosphericDrivers{FT} end\nstruct CoupledRadiativeFluxes{FT} <: AbstractRadiativeDrivers{FT} end","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"Then, we have defined a new method for turbulent_fluxes and net_radiation which dispatch for these types, and simply return the fluxes that the coupler has updated p.bucket.turbulent_fluxes and p.bucket.R_n with. In pseudo code:","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"function ClimaLand.turbulent_fluxes(\n   atmos::CoupledAtmosphere,\n   model::BucketModel,\n   p)\n   return (\n        lhf = p.bucket.turbulent_fluxes.lhf,\n        shf = p.bucket.turbulent_fluxes.shf,\n        vapor_flux = p.bucket.turbulent_fluxes.vapor_flux,\n    )\nend","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"similarily:","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"function ClimaLand.net_radiation(\n    radiation::CoupledRadiativeFluxes{FT},\n    model::BucketModel{FT},\n    p)\n    return p.bucket.R_n\nend","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"These methods simply returns the values stored in the auxiliary state p. Importantly, these functions are called by the bucket model each time step after the coupler has already computed these values (or extracted them from another model) and modifed p!","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/#Surface-air-density","page":"Setting up a Coupled Simulation","title":"Surface air density","text":"","category":"section"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"Within the right hand side/ODE function calls for the bucket model, we need both the surface air density (for computing specific humidity at the surface). In standalone runs, we call the function surface_air_density, When the atmos type is PrescribedAtmosphere, this function uses the atmospheric state and surface temperature to estimate the surface air density assuming an ideal gas and hydrostatic balance and by extrapolating from the air density at the lowest level of the atmosphere.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"In the coupled case, we need to extend these functions with a CoupledAtmosphere method:","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"function ClimaLand.surface_air_density(\n    atmos::CoupledAtmosphere,\n    model::BucketModel,\n    p)\n    return p.bucket.ρ_sfc\nend","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"Again, this functions is called in the ODE function of the bucket model after the coupler has updated the values of p with the correct values at that timestep.","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"","category":"page"},{"location":"generated/standalone/Bucket/coupled_bucket/","page":"Setting up a Coupled Simulation","title":"Setting up a Coupled Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Regridder/#Bucket","page":"Parameter Dataset Tools","title":"Bucket","text":"","category":"section"},{"location":"APIs/Regridder/","page":"Parameter Dataset Tools","title":"Parameter Dataset Tools","text":"CurrentModule = ClimaLand.Regridder","category":"page"},{"location":"APIs/Regridder/#Functions","page":"Parameter Dataset Tools","title":"Functions","text":"","category":"section"},{"location":"APIs/Regridder/","page":"Parameter Dataset Tools","title":"Parameter Dataset Tools","text":"ClimaLand.Regridder.hdwrite_regridfile_rll_to_cgll\nClimaLand.Regridder.swap_space","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Soil/richards_equation/#Hydrostatic-Equilibrium-test-for-Richards-Equation","page":"Richards Equation","title":"Hydrostatic Equilibrium test for Richards Equation","text":"","category":"section"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"This tutorial shows how to use ClimaLand code to solve Richards equation in a column of soil. We choose boundary conditions of zero flux at the top and bottom of the column, and then run the simulation long enough to see that the system is approaching hydrostatic equilibrium, where the gradient of the pressure head is equal and opposite the gradient of the gravitational head.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"The equations are:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"frac  ϑ_l t =   K (ϑ_l ν ) h( ϑ_l z ν )","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Here","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"t is the time (s),","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"z is the location in the vertical (m),","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"K is the hydraulic conductivity (m/s),","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"h is the hydraulic head (m),","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"ϑ_l is the augmented volumetric liquid water fraction,","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"ν  denotes parameters relating to soil type, such as porosity.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"We will solve this equation in a 1-d domain with z  -50, and with the following boundary and initial conditions:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"- K h(t z = 0) = 0 ẑ","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"-K h(t z = -5) = 0 ẑ","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"ϑ(t = 0 z) = ν-0001","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"θ_i(t = 0 z) = 00","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"where nu is the porosity.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"When solving Richards equation (not a fully integrated energy and hydrology model), the hydraulic conductivity is only a function of liquid moisture content.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Lastly, our formulation of this equation allows for a continuous solution in both saturated and unsaturated areas, following Woodward and Dawson (2000).","category":"page"},{"location":"generated/standalone/Soil/richards_equation/#Preliminary-setup","page":"Richards Equation","title":"Preliminary setup","text":"","category":"section"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Load external packages","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"import SciMLBase\nusing Plots","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Load CliMA packages and ClimaLand modules","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"using ClimaCore\nimport ClimaParams as CP\nimport ClimaTimeSteppers as CTS\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\n\nimport ClimaLand\nimport ClimaLand.Parameters as LP","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Define the float type desired (Float64 or Float32), and get the parameter set, which holds constants used across CliMA models:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"const FT = Float32;\nearth_param_set = LP.LandParameters(FT);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/#Set-up-the-soil-model","page":"Richards Equation","title":"Set up the soil model","text":"","category":"section"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"We want to solve Richards equation alone, without simultaneously solving the heat equation. Because of that, we choose a RichardsModel. Taking a look at the documentation (linked), we see that we need to supply parameters, a domain, boundary conditions, and sources.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"First, we define the parameters: porosity \\nu, Ksat, the van Genuchten parameters `vgα,vgm,vgn,θ_r`, and the specific storage value for the soil. Note that all values must be given in mks units.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"K_sat = FT(0.0443 / (3600 * 100))\nS_s = FT(1e-3)\nν = FT(0.495)\nvg_α = FT(2.6)\nvg_n = FT(2)\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n);\nθ_r = FT(0)\nparams = Soil.RichardsParameters(;\n    ν = ν,\n    hydrology_cm = hcm,\n    K_sat = K_sat,\n    S_s = S_s,\n    θ_r = θ_r,\n);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Next, we define the domain. Here, we are considering a 1D domain, discretized using finite difference, with coordinates z:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"zmax = FT(0)\nzmin = FT(-5)\nnelems = 10\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"We also need to specify the boundary conditions. The user must specify two conditions,  at the top and at the bottom of the domain. We currently support two broad types of boundary conditions: boundary conditions on the state ϑl = ϑl_BC (MoistureStateBC) or on the flux (WaterFluxBC, FreeDrainage, or RichardsAtmosDrivenFluxBC). Flux boundary conditions are passed as the (scalar) z-component of the flux f, i.e. F⃗ = f ẑ. The flux BC RichardsAtmosDrivenFluxBC is for driving Richards equation with a spatially and temporally varying map of precipitation. FreeDrainage is an option only at the bottom of the domain. Here, we set zero flux boundary conditons. WaterFluxBCs require a function of the cache p and the simulation time t:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"surface_flux = Soil.WaterFluxBC((p, t) -> 0.0)\nbottom_flux = Soil.WaterFluxBC((p, t) -> 0.0)\nboundary_conditions = (; top = surface_flux, bottom = bottom_flux);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Lastly, in this case we don't have any sources, so we pass an empty tuple:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"sources = ();","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Now we can make the model itself. This contains every piece of information needed to turn the continuous form of Richards equation into a set of ODEs, ready to be passed off to a timestepper.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"soil = Soil.RichardsModel{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = boundary_conditions,\n    sources = sources,\n);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Here we create the explicit and implicit tendencies, which update prognostic variable components that are stepped explicitly and implicitly, respectively. We also create the function which is used to update our Jacobian.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"exp_tendency! = make_exp_tendency(soil);\nimp_tendency! = ClimaLand.make_imp_tendency(soil);\njacobian! = ClimaLand.make_jacobian(soil);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/#Set-up-the-simulation","page":"Richards Equation","title":"Set up the simulation","text":"","category":"section"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"We can now initialize the prognostic and auxiliary variable vectors, and take a peek at what those variables are:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Y, p, coords = initialize(soil);\nY.soil |> propertynames\n\np.soil |> propertynames\n\ncoords |> propertynames","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"(:surface, :subsurface)","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Note that the variables are nested into Y and p in a hierarchical way. Since we have the vectors (composed of ClimaCore Fields handy, we can now set them to the desired initial conditions.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Y.soil.ϑ_l .= FT(0.494);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"We choose the initial and final simulation times:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"t0 = Float64(0)\ntf = Float64(60 * 60 * 24 * 36);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"We set the cache values corresponding to the initial conditions of the state Y:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"set_initial_cache! = make_set_initial_cache(soil);\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Next, we turn to timestepping. As usual, your timestep depends on the problem you are solving, the accuracy of the solution required, and the timestepping algorithm you are using.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"dt = Float64(1e3);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Now, we choose the timestepping algorithm we want to use. We'll use the ARS111 algorithm with 1 Newton iteration per timestep; you can also specify a convergence criterion and a maximum number of Newton iterations.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"stepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    stepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Here we set up the information used for our Jacobian.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"jac_kwargs = (; jac_prototype = ImplicitEquationJacobian(Y), Wfact = jacobian!);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"And then we can solve the system of equations, using SciMLBase.jl and ClimaTimeSteppers.jl.","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"prob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n);\nsol = SciMLBase.solve(prob, ode_algo; dt = dt, adaptive = false);","category":"page"},{"location":"generated/standalone/Soil/richards_equation/#Create-some-plots","page":"Richards Equation","title":"Create some plots","text":"","category":"section"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"We'll plot the moisture content vs depth in the soil, as well as the expected profile of ϑ_l in hydrostatic equilibrium. For ϑ_l values above porosity, the soil is saturated, and the pressure head changes from being equal to the matric potential to the pressure generated by compression of water and the soil matrix. The profile can be solved for analytically by (1) solving for the form that ϑ_l(z) must take in both the saturated and unsaturated zones to satisfy the steady-state requirement with zero flux boundary conditions, (2) requiring that at the interface between saturated and unsaturated zones, the water content equals porosity, and (3) solving for the location of the interface by requiring that the integrated water content at the end matches that at the beginning (yielding an interface location of z≈-0.56m).","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"t = sol.t ./ (60 * 60 * 24);\nϑ_l = [parent(sol.u[k].soil.ϑ_l) for k in 1:length(t)]\nz = parent(coords.subsurface.z)\nplot(\n    ϑ_l[1],\n    z,\n    label = string(\"t = \", string(t[1]), \"days\"),\n    xlim = [0.47, 0.501],\n    ylabel = \"z\",\n    xlabel = \"ϑ_l\",\n    legend = :bottomleft,\n    title = \"Equilibrium test\",\n);\nplot!(ϑ_l[end], z, label = string(\"t = \", string(t[end]), \"days\"));\nfunction hydrostatic_equilibrium(z, z_interface)\n    ν = 0.495\n    S_s = 1e-3\n    α = 2.6\n    n = 2.0\n    m = 0.5\n    if z < z_interface\n        return -S_s * (z - z_interface) + ν\n    else\n        return ν * (1 + (α * (z - z_interface))^n)^(-m)\n    end\nend\nplot!(hydrostatic_equilibrium.(z, -0.56), z, label = \"equilibrium solution\");\n\nplot!(1e-3 .+ ϑ_l[1], z, label = \"porosity\");","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Save the output:","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"savefig(\"equilibrium_test_ϑ_l.png\");","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/richards_equation/#References","page":"Richards Equation","title":"References","text":"","category":"section"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"Woodward and Dawson, (2000) SIAM J. Numer. Anal., 37, 701–724","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"","category":"page"},{"location":"generated/standalone/Soil/richards_equation/","page":"Richards Equation","title":"Richards Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/canopy/PlantHydraulics/#PlantHydraulics","page":"Plant Hydraulics","title":"PlantHydraulics","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/","page":"Plant Hydraulics","title":"Plant Hydraulics","text":"CurrentModule = ClimaLand.PlantHydraulics","category":"page"},{"location":"APIs/canopy/PlantHydraulics/#Models","page":"Plant Hydraulics","title":"Models","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/","page":"Plant Hydraulics","title":"Plant Hydraulics","text":"ClimaLand.PlantHydraulics.PlantHydraulicsModel","category":"page"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsModel","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsModel","text":"PlantHydraulicsModel{FT, PS, T, AA} <: AbstractPlantHydraulicsModel{FT}\n\nDefines, and constructs instances of, the PlantHydraulicsModel type, which is used for simulation flux of water to/from soil, along roots of different depths, along a stem, to a leaf, and ultimately being lost from the system by transpiration. Note that the canopy height is specified as part of the PlantHydraulicsModel, along with the area indices of the leaves, roots, and stems.\n\nThis model can also be combined with the soil model using ClimaLand, in which case the prognostic soil water content is used to determine root extraction, and the transpiration is also computed diagnostically. In  global run with patches of bare soil, you can \"turn off\" the canopy model (to get zero root extraction, zero absorption and emission, zero transpiration and sensible heat flux from the canopy), by setting:\n\nn_leaf = 1\nn_stem = 0\nLAI = SAI = RAI = 0.\n\nA plant model can have leaves but no stem, but not vice versa. If n_stem = 0, SAI must be zero.\n\nFinally, the model can be used in Canopy standalone mode by prescribing the soil matric potential at the root tips or flux in the roots. There is also the option (intendend only for debugging) to use a prescribed transpiration rate.\n\nn_stem: The number of stem compartments for the plant; can be zero\nn_leaf: The number of leaf compartments for the plant; must be >=1\ncompartment_midpoints: The height of the center of each leaf compartment/stem compartment, in meters\ncompartment_surfaces: The height of the compartments' top faces, in meters. The canopy height is the last element of the vector.\ncompartment_labels: The label (:stem or :leaf) of each compartment\nparameters: Parameters required by the Plant Hydraulics model\ntranspiration: The transpiration model, of type AbstractTranspiration\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#Plant-Hydraulics-Diagnostic-Variables","page":"Plant Hydraulics","title":"Plant Hydraulics Diagnostic Variables","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/","page":"Plant Hydraulics","title":"Plant Hydraulics","text":"ClimaLand.PlantHydraulics.effective_saturation\nClimaLand.PlantHydraulics.augmented_liquid_fraction\nClimaLand.PlantHydraulics.water_retention_curve\nClimaLand.PlantHydraulics.inverse_water_retention_curve\nClimaLand.PlantHydraulics.root_water_flux_per_ground_area!\nClimaLand.PlantHydraulics.water_flux\nClimaLand.PlantHydraulics.hydraulic_conductivity","category":"page"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.effective_saturation","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.effective_saturation","text":"effective_saturation(\n    ν::FT,\n    ϑ_l::FT) where {FT}\n\nComputes the effective saturation given the augmented liquid fraction.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.augmented_liquid_fraction","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.augmented_liquid_fraction","text":"augmented_liquid_fraction(\n    ν::FT,\n    S_l::FT) where {FT}\n\nComputes the augmented liquid fraction from porosity and effective saturation.\n\nAugmented liquid fraction allows for oversaturation: an expansion of the volume of space available for storage in a plant compartment.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.water_retention_curve","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.water_retention_curve","text":"water_retention_curve(\n    S_l::FT,\n    b::FT,\n    ν::FT,\n    S_s::FT) where {FT}\n\nReturns the potential ψ given the effective saturation S at a point, according to a linear model for the retention curve with parameters specified by retention_params.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.inverse_water_retention_curve","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.inverse_water_retention_curve","text":"inverse_water_retention_curve(\n    ψ::FT,\n    b::FT,\n    ν::FT,\n    S_s::FT) where {FT}\n\nReturns the effective saturation given the potential at a point, according to the linear retention curve model.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.root_water_flux_per_ground_area!","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.root_water_flux_per_ground_area!","text":"PlantHydraulics.root_water_flux_per_ground_area!(\n    fa::ClimaCore.Fields.Field,\n    s::PrognosticSoilConditions,\n    model::Canopy.PlantHydraulics.PlantHydraulicsModel,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nAn extension of the PlantHydraulics.root_water_flux_per_ground_area! function,  which returns the net flux of water between the roots and the soil, per unit ground area, when both soil and plant hydraulics are modeled prognostically. This is for use in an LSM.\n\nIt is computed by summing the flux of water per ground area between roots and soil at each soil layer.\n\n\n\n\n\nroot_water_flux_per_ground_area!(\n    fa::ClimaCore.Fields.Field,\n    ground::PrescribedGroundConditions,\n    model::PlantHydraulicsModel{FT},\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n) where {FT}\n\nA method which computes the water flux between the soil and the stem, via the roots, and multiplied by the RAI, in the case of a model running without a prognostic soil model:\n\nFlux = -Keff x [(ψstem - ψsoil)/(zstem - zsoil) + 1], where Keff = Ksoil Kstem /(Kstem + Ksoil)\n\nNote that in PrescribedSoil mode, we compute the flux using Ksoil = Kplant(ψsoil) and Kstem = Kplant(ψstem). In PrognosticSoil mode, we compute the flux using Ksoil = Ksoil(ψsoil) and Kstem = Kplant(ψstem). The latter is a better model, but our PrescribedSoil struct does not store Ksoil, only ψsoil.\n\nThe returned flux is per unit ground area. This assumes that the stem compartment is the first element of Y.canopy.hydraulics.ϑ_l.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.water_flux","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.water_flux","text":"water_flux(\n    z1,\n    z2,\n    ψ1,\n    ψ2,\n    K1,\n    K2,\n) where {FT}\n\nComputes the water flux given the absolute potential ψ (pressure/(ρg))  and the conductivity K (m/s) at the center of the two layers with midpoints z1 and z2.\n\nWe currently assuming a harmonic mean for effective conducticity between the two layers (see CLM Technical Documentation).\n\nTo account for different path lengths in the two compartments Δz1 and Δz2, we would require the following conductance k (1/s) keff = K1/Δz1*K2/Δz2/(K1/Δz1+K2/Δz2) and a water flux of F = -keff * (ψ1 +z1 - ψ2 - z2) (m/s).\n\nThis currently assumes the path lengths are equal.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.hydraulic_conductivity","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.hydraulic_conductivity","text":"hydraulic_conductivity(conductivity_params::Weibull{FT}, ψ::FT) where {FT}\n\nComputes the hydraulic conductivity at a point, using the Weibull formulation, given the potential ψ.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/PlantHydraulics/#Plant-Hydraulics-Parameters","page":"Plant Hydraulics","title":"Plant Hydraulics Parameters","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/","page":"Plant Hydraulics","title":"Plant Hydraulics","text":"ClimaLand.PlantHydraulics.PlantHydraulicsParameters\nClimaLand.PlantHydraulics.Weibull\nClimaLand.PlantHydraulics.LinearRetentionCurve","category":"page"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsParameters","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.PlantHydraulicsParameters","text":"PlantHydraulicsParameters\n\nA struct for holding parameters of the PlantHydraulics Model.\n\nai_parameterization: The area index model for LAI, SAI, RAI\nν: porosity (m3/m3)\nS_s: storativity (m3/m3)\nconductivity_model: Conductivity model and parameters\nretention_model: Water retention model and parameters\nrooting_depth: Rooting depth parameter (m) - a characteristic depth below which 1/e of the root mass lies\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.Weibull","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.Weibull","text":"Weibull{FT} <: AbstractConductivityModel{FT}\n\nA concrete type specifying that a Weibull conductivity model is to be used; the struct contains the require parameters for this model.\n\nFields\n\nK_sat: Maximum Water conductivity in the above-ground plant compartments (m/s) at saturation\nψ63: The absolute water potential in xylem (or xylem water potential) at which ∼63%     of maximum xylem conductance is lost (Liu, 2020).\nc: Weibull parameter c, which controls shape the shape of the conductance curve (Sperry, 2016).\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.LinearRetentionCurve","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.LinearRetentionCurve","text":"LinearRetentionCurve{FT} <: AbstractRetentionModel{FT}\n\nA concrete type specifying that a linear water retention  model is to be used; the struct contains the require parameters for this model.\n\nWhen ψ = 0, the effective saturation is one, so the intercept is not a free parameter, and only the slope must be specified.\n\nFields\n\na: Bulk modulus of elasticity and slope of potential to volume curve. See also Corcuera, 2002, and Christoffersen, 2016.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/PlantHydraulics/#Plant-Hydraulics-Methods-and-Types","page":"Plant Hydraulics","title":"Plant Hydraulics Methods and Types","text":"","category":"section"},{"location":"APIs/canopy/PlantHydraulics/","page":"Plant Hydraulics","title":"Plant Hydraulics","text":"ClimaLand.PlantHydraulics.PrescribedSoilPressure\nClimaLand.PlantHydraulics.PrescribedTranspiration\nClimaLand.PlantHydraulics.AbstractRootExtraction","category":"page"},{"location":"APIs/canopy/PlantHydraulics/#ClimaLand.Canopy.PlantHydraulics.PrescribedTranspiration","page":"Plant Hydraulics","title":"ClimaLand.Canopy.PlantHydraulics.PrescribedTranspiration","text":"PrescribedTranspiration{FT, F <: Function} <: AbstractTranspiration{FT}\n\nA concrete type used for dispatch when computing the transpiration from the leaves, in the case where transpiration is prescribed.\n\n\n\n\n\n","category":"type"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The AbstractModel tutorial describes how a user can run simulations of a physical system governed by differential equations. In this framework, the user must define a model type for their problem, which contains all of the information required to set up the system of equations. By extending the methods for make_compute_exp_tendency(model), prognostic_variables(model), etc, the information stored in the model is used to make the system of equations. Given initial conditions, these equations can then be stepped forward in time using the time-stepper of your choice. Note that a model requiring implicit timestepping would instead use an AbstractImExModel framework.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The benefit of this framework is that it can be used for both individual components of an LSM (soil, snow, rivers, canopy biophysics, carbon...) as well as the LSM itself. Here we explain how a simple two component model can be set up using this software interface.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We'll first demonstrate how to set up two components in standalone mode, before spending time explaining the LSM setup. In our example, we have a component which accounts for soil hydrology via the Richardson-Richards (RR) equation.  Our second component is a surface water model without lateral flow (standing water, as in a pond). For more details on these models, and how they were set up, please feel free to look at the source code here and here. This tutorial focuses on using the AbstractModels framework to set up the equations, rather than on running simulations.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"First, let's load the required modules:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"using ClimaLand\nusing ClimaLand.Domains: Column, obtain_surface_domain\nusing ClimaLand.Soil\nusing ClimaLand.Pond\n\nFT = Float32;","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/#The-individual-component-models-I-Soil-Hydrology","page":"Intro to multi-component models","title":"The individual component models I - Soil Hydrology","text":"","category":"section"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The RR equation for the volumetric water content of soil is given by","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"fracpartial ϑpartial t = -  (-K(ψ+z)) + S(xyz t)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"In order to solve this, one must specify:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"boundary conditions,\nrelevant parameters (closure models for K and ψ),\na domain and a spatial discretization scheme,\nadditional source terms S, if applicable,\na time-stepping algorithm,\ninitial conditions.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We make the distinction between the spatially discretized equations (for which you need parameters, boundary conditions, source terms, and domain/ discretization scheme information in order to write down and evaluate), and the simulation you want to run (for which you need the equations, initial conditions, a time span, and a time-stepping scheme in order to specify completely).","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Here, we'll focus on what you need to write the equations. This information is stored in the model structure itself, so that we can call make_exp_tendency(model) and get back a function which computes the time derivative of the prognostic variables, which the ODE timestepper needs to advance the state forward in time.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"For the RR equation, we can create this as follows. First, we specify parameters:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"ν = FT(0.495);\nK_sat = FT(0.0443 / 3600 / 100); # m/s\nS_s = FT(1e-3); #inverse meters\nvg_n = FT(2.0);\nvg_α = FT(2.6); # inverse meters\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n);\nθ_r = FT(0);\nsoil_ps = Soil.RichardsParameters(;\n    ν = ν,\n    hydrology_cm = hcm,\n    K_sat = K_sat,\n    S_s = S_s,\n    θ_r = θ_r,\n);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Next, let's define the spatial domain and discretization:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"zmax = FT(0);\nzmin = FT(-1);\nnelems = 20;\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"And boundary conditions and source terms (none currently):","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"top_flux_bc = WaterFluxBC((p, t) -> 0.0);\nbot_flux_bc = WaterFluxBC((p, t) -> 0.0);\nsources = ()\nboundary_fluxes = (; top = top_flux_bc, bottom = bot_flux_bc)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(top = ClimaLand.Soil.WaterFluxBC{Main.var\"##562\".var\"#1#2\"}(Main.var\"##562\".var\"#1#2\"()), bottom = ClimaLand.Soil.WaterFluxBC{Main.var\"##562\".var\"#3#4\"}(Main.var\"##562\".var\"#3#4\"()))","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"With this information, we can make our model:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"soil = Soil.RichardsModel{FT}(;\n    parameters = soil_ps,\n    domain = soil_domain,\n    boundary_conditions = boundary_fluxes,\n    sources = sources,\n);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We also can create the soil prognostic and auxiliary ClimaCore.Field.FieldVectors using the default method for initialize,","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Y_soil, p_soil, coords_soil = initialize(soil);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and we can set up the tendency function using the default as well,","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"soil_ode! = make_exp_tendency(soil);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"which computes, for the column domain,","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"-frac z (-Kfrac(ψ+z) z)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"for each value of ϑ on the mesh of our soil_domain.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Note that the soil model does includes hydraulic K, pressure head ψ, and the boundary fluxes at the top and bottom of the domain in the auxiliary vector. These are updated first in each call to soil_ode!, as follows:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function soil_ode!(dY, Y, p, t)\n         update_aux!(p,Y,t) # updates p.soil.K, p.soil.ψ in place\n         update_boundary_fluxes!(p,Y,t) # updates p.soil.top_bc, p.soil.bottom_bc in place\n         compute_exp_tendency!(dY, Y, p, t) # computes the divergence of the Darcy flux, updates dY in place.\nend","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"It is crucial the the cache p is correctly updated before the tendency is computed. The default method for make_exp_tendency creates the update_aux! and update_boundary_fluxes! functions, given the model, and evaluates them before computing the tendency, so we do not need to define that for the soil model.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Note also that we have defined methods make_compute_exp_tendency, make_update_aux, and make_update_boundary_fluxes, which only take the model as argument, and which return the functions compute_exp_tendency!, update_aux!, and update_boundary_fluxes!. Please see the API documentation or source code for more information.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Lastly, the coordinates returned by initialize contain the z-coordinates of the centers of the finite difference layers used for spatial discretization of the PDE.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/#The-individual-component-models-II-Surface-Water","page":"Intro to multi-component models","title":"The individual component models II - Surface Water","text":"","category":"section"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The pond model has a single variable, the pond height η, which satisfies the ODE:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"frac η t = -(P - I) = R","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"where P is the precipitation, I the infiltration into the soil, and R is the runoff. Note that P, I < 0 indicates flow in the -ẑ direction.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"To write down the pond equations, we need to specify","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"P\nI","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"which are akin to boundary fluxes. In standalone mode,  one would need to pass in prescribed functions of time and store them inside our pond model, since again, the pond model structure must contain everything needed to make the tendency function:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"precipitation(t) = t < 20 ? -1e-5 : 0.0 # m/s\n\ninfiltration(t) = -(1e-6) #m/s\npond_model =\n    Pond.PondModel{FT}(; runoff = PrescribedRunoff(precipitation, infiltration));","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Here, PrescribedRunoff is the structure holding the prescribed driving functions for P and I.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Again we can initialize the state vector and auxiliary vectors:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Y_pond, p_pond, coords_pond = initialize(pond_model);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We can make the tendency function in the same way, for stepping the state forward in time:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"pond_ode! = make_exp_tendency(pond_model);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The pond_ode! function works in the same way as for the soil model:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function pond_ode!(dY, Y, p, t)\n         update_aux!(p,Y,t) # falls back to default; does nothing\n         update_boundary_fluxes!(p,Y,t)  # p.surface_water.runoff in place\n         compute_exp_tendency!(dY, Y, p, t)\nend","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/#An-LSM-with-pond-and-soil:","page":"Intro to multi-component models","title":"An LSM with pond and soil:","text":"","category":"section"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The LSM model must contain everything needed to write down the joint system of equations","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"fracpartial etapartial t = -(P(t) - I(ϑ η P)) = R","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"fracpartial ϑpartial t = -  (-K(ψ+z)) + S","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"-K (ψ+z)_z = zmax   z = I(ϑ η P)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"-K (ψ+z)_z = zmin   z = 00","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"These two components interact via the infiltration term I. Infiltration is a boundary condition for the soil, and affects the source term for the surface water equation. Infiltration depends on precipitation, the soil moisture state, and the pond height.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"As in the standalone cases, defining our model requires specifying","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"parameters,\ndomains, discretizations\nprecipitation,\nboundary conditions,\nsources in the soil equation, if any.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"First, let's make our single column domain.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"lsm_domain = Column(; zlim = (zmin, zmax), nelements = nelems);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Let's now collect the needed arguments for the soil model. The pond model only has one argument, the runoff model, but that will be set internally. Similarily, the boundary conditions of the soil model will be set internally to be consisent with the equations of the pond-soil model - see below for detail.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"soil_args = (parameters = soil_ps, domain = lsm_domain, sources = ());\nsurface_water_args = NamedTuple();","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Atmospheric drivers don't \"belong\" to either component alone:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"land_args = (precip = precipitation,);\nland = LandHydrology{FT}(;\n    land_args = land_args,\n    soil_model_type = Soil.RichardsModel{FT},\n    soil_args = soil_args,\n    surface_water_model_type = Pond.PondModel{FT},\n    surface_water_args = surface_water_args,\n);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Here, LandHydrology is a type of AbstractModel which has a surface water model (Pond or otherwise) and a soil model (RR, or perhaps otherwise).","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Now, note that we did not specify the infiltration function, like we did in standalone pond mode, nor did we specify boundary conditions for the soil model, nor did we specify the pond model domain. Yet, before we stressed that the model needs to have everything required to write down and evaluate the time derivative of the ODEs. So, how does this work?","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Here, the LSM model constructor is given the information needed to make both the soil model and the pond model. Then, it is like running the pond and soil model in standalone mode, in series, except we have defined methods internally for computing the boundary condition and pond source term correctly, based on I, instead of using prescribed values passed in. The LSM constructor creates the correct boundary_fluxes object for the soil model, and the correct infiltration object for the pond model under the hood.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"To advance the state of the joint system (ϑ, η) from time t to time t+Δt, we must compute the infiltration at t. This value is stored in p.soil_infiltration.  In pseudo code, we have:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function make_update_aux(land)\n         soil_update_aux! = make_update_aux(land.soil)\n         surface_update_aux! = make_update_aux(land.surface_water)\n         function update_aux!(p,Y,t)\n                  surface_update_aux!(p,Y,t) # does nothing to `p`\n                  soil_update_aux!(p,Y,t) # updates p.soil.K and p.soil.ψ\n         end\n         return update_aux!\nend","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function make_update_boundary_fluxes(land)\n         update_soil_bf! = make_update_boundary_fluxes(land.soil)\n         update_pond_bf! = make_update_boundary_fluxes(land.surface_water)\n         function update_boundary_fluxes!(p,Y,t)\n                  p.soil_infiltration = compute_infiltration(Y,p, t)\n                  update_soil_bf!(p,Y,t) # updates p.soil.top_bc using p.soil_infiltration\n                  update_pond_bf!(p,Y,t) # updates p.surface_water.runoff using p.soil_infiltration\n         end\n         return update_boundary_fluxes!\nend","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and similarily for the compute_exp_tendency! functions:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function make_compute_exp_tendency(land)\n         soil_compute_exp_tendency! = make_update_aux(land.soil)\n         surface_compute_exp_tendency! = make_update_aux(land.surface_water)\n         function compute_exp_tendency!(dY,Y,p,t)\n                  surface_compute_exp_tendency!(dY,Y,p, t), # computes dY.surface.η\n                  soil_compute_exp_tendency!(dY,Y,p,t) # computes dY.soil.ϑ\n         end\n         return compute_exp_tendency!\nend","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"The exp_tendency! for the land model is then again just","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"function exp_tendency!(dY, Y, p, t)\n         update_aux!(p,Y,t)\n         update_boundary_fluxes!(p,Y,t)\n         compute_exp_tendency!(dY, Y, p, t)\nend","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"In the above, we showed explicitly what occurs by hardcoding the compute_exp_tendency!, update_aux! with names for soil and surface_water. In reality, this is done by looping over the components of the land model, meaning that we can use the same code internally for land models with different components.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"A similar composition occurs for initializing the state itself: Calling initialize(land) does four things:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"initialize(land.soil)\ninitialize(land.surface_water)\ninitializes additional auxiliary variables, like p.soil_infiltration\nappend these into Y, p, and coords:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Y, p, coords = initialize(land);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"We have volumetric liquid water fraction:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(Y.soil)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(:ϑ_l,)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and surface height of the pond:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(Y.surface_water)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(:η,)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"as well as auxiliary variables for the soil:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(p.soil)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(:K, :ψ, :top_bc, :top_bc_wvec, :bottom_bc, :bottom_bc_wvec)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and the runoff for surface water:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(p.surface_water)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(:runoff,)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and the additional variable required in the LSM is stored here as well:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"propertynames(p)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"(:soil_infiltration, :soil, :surface_water)","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and finally, coordinates - useful for visualization of solutions:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"coords.subsurface","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"ClimaCore.Geometry.ZPoint{Float32}-valued Field:\n  z: Float32[-0.975, -0.925, -0.875, -0.825, -0.775, -0.725, -0.675, -0.625, -0.575, -0.525, -0.475, -0.425, -0.375, -0.325, -0.275, -0.225, -0.175, -0.125, -0.075, -0.025]","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"and the coordinates of the surface variables:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"coords.surface","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"ClimaCore.Geometry.ZPoint{Float32}-valued Field:\n  z: Float32[0.0]","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"And we can make the tendency function as before:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"land_ode! = make_exp_tendency(land);","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Next up would be to set initial conditions, choose a timestepping scheme, and run your simulation.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/#Advantages-and-disadvantages","page":"Intro to multi-component models","title":"Advantages and disadvantages","text":"","category":"section"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Some advantages to our interface design are as follows:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"a developer only needs to learn a few concepts (compute_exp_tendency!, prognostic vs. aux variables, update_aux!/update_boundary_fluxes!, initialize, domains) to make a model which can be run in standalone or work with other components.\nlikewise, a user only needs to learn one interface to run all models, regardless of if they are standalone components or LSMs with multiple components.\nthe exp_tendency!is completely seperate from the timestepping scheme used, so any scheme can be used (with the exception of mixed implicit/explicit schemes, which we can't handle yet).\nalthough we wrote it here in a hardwired fashion for surface water and soil, the update_aux!, compute_exp_tendency! methods for LSM models generalize to any number and mix of components. One just needs to write a new model type (e.g. BiophysicsModel <: AbstractModel for a vegetation and carbon component model) and the appropriate make_update_boundary_var methods for that model.\nthe order in which the components are treated in the tendency or in update aux does not matter. What matters is that (1) auxiliary/cache variables are updated prior to calling update_boundary_fluxes!, and that (2) update_boundary_fluxes! is called prior to evaluating the tendency.\nthe code is also modular in terms of swapping out a simple component model for a more complex version.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Possible disadvantages to our interface design:","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"Even in standalone model, variables are accessed in a nested way: Y.soil, p.soil, etc, which is excessive.\nTo accomodate the fact that some components involve PDEs, a developer for purely ODE based component does need to at least handle ClimaCore.Field.FieldVectors.\nstandalone models need to play by the rules of AbstractModels, and LSMs need to play by the rules of ClimaLand.jl.\nwe need to define multiple update cache functions in order to handle dependencies between cache variables of one component model and boundary fluxes of another.","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"","category":"page"},{"location":"generated/standalone/Usage/LSM_single_column_tutorial/","page":"Intro to multi-component models","title":"Intro to multi-component models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"This sets up the simulation that mimicks the lab experiment presented in Gardener 1970b and modeled also by Lehmann and Or, 2024.","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"For further details on how to setup a simulation, please see our other Soil tutorials. This one is very terse and does not provide complete explanations","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"The same experiment is carried out 3 times","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"No evaporation (zero flux boundary conditions)\nWith evaporation but no drainage (Ksat = 0)\nWith evaporation and drainage","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"using CairoMakie\nimport SciMLBase\nimport ClimaTimeSteppers as CTS\nusing Thermodynamics\n\nusing ClimaCore\nimport ClimaParams as CP\nusing SurfaceFluxes\nusing StaticArrays\nusing Dates\nusing DelimitedFiles: readdlm\n\nusing ClimaLand\nusing ClimaLand.Domains: Column\nusing ClimaLand.Soil\nimport ClimaLand\nimport ClimaLand.Parameters as LP\nimport SurfaceFluxes.Parameters as SFP\n\nFT = Float64;\nearth_param_set = LP.LandParameters(FT)\nthermo_params = LP.thermodynamic_parameters(earth_param_set);","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"Parameters","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"K_sat = FT(0.01 / 3600 / 24)\nvg_n = FT(1.55)\nvg_α = FT(1.5)\nhcm = vanGenuchten{FT}(; α = vg_α, n = vg_n)\nν = FT(0.4)\nθ_r = FT(0.04)\nS_s = FT(1e-3)\nν_ss_om = FT(0.0)\nν_ss_quartz = FT(0.3)\nν_ss_gravel = FT(0.0)\nemissivity = FT(1.0)\nPAR_albedo = FT(0.2)\nNIR_albedo = FT(0.4)\nz_0m = FT(1e-3)\nz_0b = FT(1e-4)\nd_ds = FT(0.01)# 10mm\nparams = ClimaLand.Soil.EnergyHydrologyParameters(\n    FT;\n    ν,\n    ν_ss_om,\n    ν_ss_quartz,\n    ν_ss_gravel,\n    hydrology_cm = hcm,\n    K_sat,\n    S_s,\n    θ_r,\n    PAR_albedo,\n    NIR_albedo,\n    emissivity,\n    z_0m,\n    z_0b,\n    earth_param_set,\n    d_ds,\n);\n\nstart_date = DateTime(2005)\nSW_d = (t) -> 0\nLW_d = (t) -> 294.15^4 * 5.67e-8\nradiation = PrescribedRadiativeFluxes(\n    FT,\n    TimeVaryingInput(SW_d),\n    TimeVaryingInput(LW_d),\n    start_date,\n)","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"PrescribedRadiativeFluxes{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#1#2\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#3#4\"}, Dates.DateTime, Nothing}(ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#1#2\"}(Main.var\"##347\".var\"#1#2\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#3#4\"}(Main.var\"##347\".var\"#3#4\"()), Dates.DateTime(\"2005-01-01T00:00:00\"), nothing)","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"Atmos","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"T_air = FT(301.15)\nrh = FT(0.38)\nesat = Thermodynamics.saturation_vapor_pressure(\n    thermo_params,\n    T_air,\n    Thermodynamics.Liquid(),\n)\ne = rh * esat\nq = FT(0.622 * e / (101325 - 0.378 * e))\nprecip = (t) -> 0.0\nT_atmos = (t) -> T_air\nu_atmos = (t) -> 1.0\nq_atmos = (t) -> q\nh_atmos = FT(0.1)\nP_atmos = (t) -> 101325\ngustiness = FT(1e-2)\natmos = PrescribedAtmosphere(\n    TimeVaryingInput(precip),\n    TimeVaryingInput(precip),\n    TimeVaryingInput(T_atmos),\n    TimeVaryingInput(u_atmos),\n    TimeVaryingInput(q_atmos),\n    TimeVaryingInput(P_atmos),\n    start_date,\n    h_atmos,\n    earth_param_set;\n    gustiness = gustiness,\n)","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"PrescribedAtmosphere{Float64, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#5#6\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#7#8\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#9#10\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#11#12\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#13#14\"}, ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{ClimaLand.var\"#21#24\"}, Dates.DateTime, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}}(ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#5#6\"}(Main.var\"##347\".var\"#5#6\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#5#6\"}(Main.var\"##347\".var\"#5#6\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#7#8\"}(Main.var\"##347\".var\"#7#8\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#9#10\"}(Main.var\"##347\".var\"#9#10\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#11#12\"}(Main.var\"##347\".var\"#11#12\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{Main.var\"##347\".var\"#13#14\"}(Main.var\"##347\".var\"#13#14\"()), ClimaUtilitiesClimaCoreNCDatasetsExt.TimeVaryingInputsExt.AnalyticTimeVaryingInput{ClimaLand.var\"#21#24\"}(ClimaLand.var\"#21#24\"()), Dates.DateTime(\"2005-01-01T00:00:00\"), 0.1, 0.01, Thermodynamics.Parameters.ThermodynamicsParameters{Float64}(273.16, 101325.0, 100000.0, 1859.0, 4181.0, 2100.0, 2.5008e6, 2.8344e6, 611.657, 273.16, 273.15, 1.0, 1000.0, 150.0, 298.15, 6864.8, 10513.6, 0.28571428571, 8.3144598, 0.02897, 0.01801528, 290.0, 220.0, 9.81, 233.0, 1.0))","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"Simulation setup - no evaporation Boundary conditions","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"zero_water_flux = WaterFluxBC((p, t) -> 0)\nzero_heat_flux = HeatFluxBC((p, t) -> 0)\nno_flux_boundary_fluxes = (;\n    top = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n    bottom = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n);\n\nt0 = Float64(0)\ntf = Float64(24 * 3600 * 15)\ndt = Float64(900.0)\nΔz = 0.01\nzmax = FT(0)\nzmin = FT(-1.6)\nnelems = Int((zmax - zmin) / Δz)\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems)\nz = ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z\n\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = no_flux_boundary_fluxes,\n    sources = (),\n);","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"Initial conditions","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"Y, p, cds = initialize(soil)\nfunction estimated_ic(z)\n    0.34 / (1 + exp(-(z + 0.165) / 0.005)) + 0.05\nend\nfunction init_soil!(Y, z, params)\n    FT = eltype(Y.soil.ϑ_l)\n    Y.soil.ϑ_l .= estimated_ic.(z)\n    Y.soil.θ_i .= 0\n    T = FT(294.15)\n    ρc_s = @. Soil.volumetric_heat_capacity(\n        Y.soil.ϑ_l,\n        Y.soil.θ_i,\n        params.ρc_ds,\n        params.earth_param_set,\n    )\n    Y.soil.ρe_int =\n        Soil.volumetric_internal_energy.(\n            Y.soil.θ_i,\n            ρc_s,\n            T,\n            params.earth_param_set,\n        )\nend\n\ninit_soil!(Y, z, soil.parameters)\nset_initial_cache! = make_set_initial_cache(soil)\nset_initial_cache!(p, Y, t0);","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"Timestepping:","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"exp_tendency! = make_exp_tendency(soil)\nimp_tendency! = make_imp_tendency(soil);\njacobian! = ClimaLand.make_jacobian(soil);\njac_kwargs = (; jac_prototype = ImplicitEquationJacobian(Y), Wfact = jacobian!);\n\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"Problem definition and callbacks","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"prob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n);\nsaveat = Array(t0:3600.0:tf)\nsv = (;\n    t = Array{Float64}(undef, length(saveat)),\n    saveval = Array{NamedTuple}(undef, length(saveat)),\n)\nsaving_cb = ClimaLand.NonInterpSavingCallback(sv, saveat)\ncb = SciMLBase.CallbackSet(saving_cb);\n\nsol_no_evap =\n    SciMLBase.solve(prob, ode_algo; dt = dt, callback = cb, saveat = saveat);","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"Repeat with evaporation and drainage This requires different initial conditions","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"top_bc = ClimaLand.Soil.AtmosDrivenFluxBC(atmos, radiation)\nevap_boundary_fluxes = (;\n    top = top_bc,\n    bottom = WaterHeatBC(; water = zero_water_flux, heat = zero_heat_flux),\n)\n\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = evap_boundary_fluxes,\n    sources = (),\n)\nY, p, cds = initialize(soil)\ninit_soil!(Y, z, soil.parameters)\nset_initial_cache! = make_set_initial_cache(soil)\nset_initial_cache!(p, Y, t0)\nsoil_exp_tendency! = make_exp_tendency(soil)\nexp_tendency! = make_exp_tendency(soil)\nimp_tendency! = make_imp_tendency(soil);\njacobian! = ClimaLand.make_jacobian(soil);\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\njac_kwargs = (; jac_prototype = ImplicitEquationJacobian(Y), Wfact = jacobian!);\nprob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n);\nsaveat = Array(t0:3600.0:tf)\nsv = (;\n    t = Array{Float64}(undef, length(saveat)),\n    saveval = Array{NamedTuple}(undef, length(saveat)),\n)\nsaving_cb = ClimaLand.NonInterpSavingCallback(sv, saveat)\nupdateat = deepcopy(saveat)\nmodel_drivers = ClimaLand.get_drivers(soil)\nupdatefunc = ClimaLand.make_update_drivers(model_drivers)\ndriver_cb = ClimaLand.DriverUpdateCallback(updateat, updatefunc)\ncb = SciMLBase.CallbackSet(driver_cb, saving_cb)\nsol = SciMLBase.solve(prob, ode_algo; dt = dt, callback = cb, saveat = saveat)\nevap = [\n    parent(sv.saveval[k].soil.turbulent_fluxes.vapor_flux_liq)[1] for\n    k in 1:length(sol.t)\n];\n\n# Repeat with no drainage (Ksat = 0, different BC), and with evaporation, in shorter domain","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"[ Info: Warning: No runoff model was provided; zero runoff generated.\n","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"This requires different boundary conditions yet again: Wet boundary at bottom, zero heat flux at bottom, the previously defined atmos driven evaporation at the top.","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"bottom_water_bc = MoistureStateBC((p, t) -> 0.35)\nno_drainage_boundary_fluxes = (;\n    top = top_bc,\n    bottom = WaterHeatBC(; water = bottom_water_bc, heat = zero_heat_flux),\n)\nzmax = FT(0)\nzmin = FT(-0.16)\nnelems = Int((zmax - zmin) / Δz)\ndt = Float64(10.0)\nsoil_domain = Column(; zlim = (zmin, zmax), nelements = nelems)\nz_no_evap = ClimaCore.Fields.coordinate_field(soil_domain.space.subsurface).z\nsoil = Soil.EnergyHydrology{FT}(;\n    parameters = params,\n    domain = soil_domain,\n    boundary_conditions = no_drainage_boundary_fluxes,\n    sources = (),\n)\nY, p, cds = initialize(soil)\ninit_soil!(Y, z_no_evap, soil.parameters)\nset_initial_cache! = make_set_initial_cache(soil)\nset_initial_cache!(p, Y, t0)\nexp_tendency! = make_exp_tendency(soil)\nimp_tendency! = make_imp_tendency(soil);\njacobian! = ClimaLand.make_jacobian(soil);\ntimestepper = CTS.ARS111();\node_algo = CTS.IMEXAlgorithm(\n    timestepper,\n    CTS.NewtonsMethod(\n        max_iters = 1,\n        update_j = CTS.UpdateEvery(CTS.NewNewtonIteration),\n    ),\n);\njac_kwargs = (; jac_prototype = ImplicitEquationJacobian(Y), Wfact = jacobian!);\nprob = SciMLBase.ODEProblem(\n    CTS.ClimaODEFunction(\n        T_exp! = exp_tendency!,\n        T_imp! = SciMLBase.ODEFunction(imp_tendency!; jac_kwargs...),\n        dss! = ClimaLand.dss!,\n    ),\n    Y,\n    (t0, tf),\n    p,\n);\nsaveat = Array(t0:3600.0:tf)\nsv = (;\n    t = Array{Float64}(undef, length(saveat)),\n    saveval = Array{NamedTuple}(undef, length(saveat)),\n)\nsaving_cb = ClimaLand.NonInterpSavingCallback(sv, saveat)\nupdateat = deepcopy(saveat)\nmodel_drivers = ClimaLand.get_drivers(soil)\nupdatefunc = ClimaLand.make_update_drivers(model_drivers)\ndriver_cb = ClimaLand.DriverUpdateCallback(updateat, updatefunc)\ncb = SciMLBase.CallbackSet(driver_cb, saving_cb)\nsol_no_drainage =\n    SciMLBase.solve(prob, ode_algo; dt = dt, callback = cb, saveat = saveat)\nevap_no_drainage = [\n    parent(sv.saveval[k].soil.turbulent_fluxes.vapor_flux_liq)[1] for\n    k in 1:length(sol.t)\n];","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"Figures","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"savepath = joinpath(pkgdir(ClimaLand), \"docs/tutorials/standalone/Soil/\")\n\nfig = Figure(size = (800, 400))\nax = Axis(fig[1, 1], xlabel = \"Day\", ylabel = \"Evaporation rate (mm/d)\")\nCairoMakie.lines!(\n    ax,\n    sol.t ./ 3600 ./ 24,\n    evap .* (1000 * 3600 * 24),\n    label = \"With drainage\",\n    color = :red,\n)\nCairoMakie.lines!(\n    ax,\n    sol_no_drainage.t ./ 3600 ./ 24,\n    evap_no_drainage .* (1000 * 3600 * 24),\n    label = \"No drainage\",\n    color = :blue,\n)\n\nCairoMakie.axislegend(ax)\nax2 = Axis(fig[1, 2], xlabel = \"Day\", ylabel = \"Cumulative evaporation (mm)\")\nCairoMakie.lines!(\n    ax2,\n    sol.t ./ 3600 ./ 24,\n    cumsum(evap) .* (1000 * 3600),\n    color = :red,\n)\nCairoMakie.lines!(\n    ax2,\n    sol_no_drainage.t ./ 3600 ./ 24,\n    cumsum(evap_no_drainage) .* (1000 * 3600),\n    color = :blue,\n)\nsave(\"evaporation_lehmann2024_figS6.png\", fig);","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"fig2 = Figure(size = (800, 1200))\nax1 = Axis(fig2[1, 1], title = \"Drainage only\")\nCairoMakie.ylims!(-0.35, 0)\nCairoMakie.xlims!(0.0, 0.4)\nlinestyles = [:solid, :dash, :dashdot, :dashdotdot, :dot]\ndays = [0, 1, 2, 10]\nfor i in 1:1:4\n    CairoMakie.lines!(\n        ax1,\n        parent(sol_no_evap.u[days[i] * 24 + 1].soil.ϑ_l)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\nax2 = Axis(fig2[2, 1], title = \"Evap+Drainage\", ylabel = \"Depth(cm)\")\n\nCairoMakie.ylims!(-0.3, 0)\nCairoMakie.xlims!(0.0, 0.4)\ndays = [0, 1, 2, 5, 13]\nfor i in 1:1:5\n    CairoMakie.lines!(\n        ax2,\n        parent(sol.u[days[i] * 24 + 1].soil.ϑ_l)[:],\n        parent(z)[:],\n        label = \"$(days[i]) days\",\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\nax3 = Axis(fig2[3, 1], title = \"Evap only\", xlabel = \"Volumetric Water Content\")\nCairoMakie.ylims!(-0.15, 0)\nCairoMakie.xlims!(0.0, 0.4)\ndays = [0, 2, 9, 14]\nfor i in 1:1:4\n    CairoMakie.lines!(\n        ax3,\n        parent(sol_no_drainage.u[days[i] * 24 + 1].soil.ϑ_l)[:],\n        label = \"$(days[i]) days\",\n        parent(z_no_evap)[:],\n        color = :black,\n        linestyle = linestyles[i],\n    )\nend\n\nCairoMakie.axislegend(ax3, position = :lt)\nCairoMakie.axislegend(ax2, position = :lt)\nCairoMakie.axislegend(ax1, position = :lt)\nsave(\"evaporation_gardner_fig1.png\", fig2);","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"(Image: )","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"","category":"page"},{"location":"generated/standalone/Soil/evaporation_gilat_loess/","page":"Gilat Loess Evaporation","title":"Gilat Loess Evaporation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Snow/","page":"Snow Model","title":"Snow Model","text":"Snow Model","category":"page"},{"location":"APIs/Snow/","page":"Snow Model","title":"Snow Model","text":"CurrentModule = ClimaLand.Snow","category":"page"},{"location":"APIs/Snow/#Snow-Parameters","page":"Snow Model","title":"Snow Parameters","text":"","category":"section"},{"location":"APIs/Snow/","page":"Snow Model","title":"Snow Model","text":"ClimaLand.Snow.SnowParameters","category":"page"},{"location":"APIs/Snow/#ClimaLand.Snow.SnowParameters","page":"Snow Model","title":"ClimaLand.Snow.SnowParameters","text":"SnowParameters{FT <: AbstractFloat, PSE}\n\nA struct for storing parameters of the SnowModel.\n\nNote that in our current implementation of runoff, a physical timescale is required and computed using Ksat and the depth of the snow. For shallow snowpacks, this will fall below the timestep of the model. For that reason, we pass the timestep of the model as  a parameter, and take the larger of the timestep and the physical timescale as the value used in the model. Future implementations will revisit this.\n\nρ_snow: Density of snow (kg/m^3)\nz_0m: Roughness length over snow for momentum (m)\nz_0b: Roughness length over snow for scalars (m)\nα_snow: Albedo of snow (unitless)\nϵ_snow: Emissivity of snow (unitless)\nθ_r: Volumetric holding capacity of water in snow (unitless)\nKsat: Hydraulic conductivity of wet snow (m/s)\nκ_ice: Thermal conductivity of ice (W/m/K)\nΔt: Timestep of the model (s)\nρcD_g: Areal specific heat of ground interacting with snow (J/m^2/K)\nearth_param_set: Clima-wide parameters\n\n\n\n\n\n","category":"type"},{"location":"APIs/Snow/#Snow-Functions-of-State","page":"Snow Model","title":"Snow Functions of State","text":"","category":"section"},{"location":"APIs/Snow/","page":"Snow Model","title":"Snow Model","text":"ClimaLand.Snow.specific_heat_capacity\nClimaLand.Snow.snow_surface_temperature\nClimaLand.Snow.snow_depth\nClimaLand.Snow.snow_thermal_conductivity\nClimaLand.Snow.snow_bulk_temperature\nClimaLand.Snow.snow_liquid_mass_fraction\nClimaLand.Snow.maximum_liquid_mass_fraction\nClimaLand.Snow.runoff_timescale\nClimaLand.Snow.compute_water_runoff\t\nClimaLand.Snow.energy_from_q_l_and_swe\nClimaLand.Snow.energy_from_T_and_swe\nClimaLand.Snow.snow_cover_fraction","category":"page"},{"location":"APIs/Snow/#ClimaLand.Snow.specific_heat_capacity","page":"Snow Model","title":"ClimaLand.Snow.specific_heat_capacity","text":"specific_heat_capacity(q_l::FT,\n                       parameters::SnowParameters{FT}\n                       ) where {FT}\n\nComputes the specific heat capacity of the snow, neglecting any contribution from air in the pore spaces, given the liquid water mass fraction q_l and other parameters.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_surface_temperature","page":"Snow Model","title":"ClimaLand.Snow.snow_surface_temperature","text":"snow_surface_temperature(T::FT) where {FT}\n\nReturns the snow surface temperature assuming it is the same as the bulk temperature T.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_depth","page":"Snow Model","title":"ClimaLand.Snow.snow_depth","text":"snow_depth(SWE::FT, ρ_snow::FT, ρ_l::FT) where {FT}\n\nReturns the snow depth given SWE, snow density ρsnow, and the density of liquid water ρl.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_thermal_conductivity","page":"Snow Model","title":"ClimaLand.Snow.snow_thermal_conductivity","text":"snow_thermal_conductivity(ρ_snow::FT,\n                     parameters::SnowParameters{FT},\n                     ) where {FT}\n\nComputes the thermal conductivity, given the density of the snow, according to Equation 5.33 from Bonan's textbook, which in turn is taken from Jordan (1991).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_bulk_temperature","page":"Snow Model","title":"ClimaLand.Snow.snow_bulk_temperature","text":"snow_bulk_temperature(U::FT,\n                      SWE::FT,\n                      q_l::FT,\n                      parameters::SnowParameters{FT}) where {FT}\n\nComputes the bulk snow temperature from the snow water equivalent SWE, energy per unit area U, liquid water mass fraction ql, and specific heat capacity cs, along with other needed parameters.\n\nIf there is no snow (U = SWE = 0), the bulk temperature is the reference temperature, which is 273.16K.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_liquid_mass_fraction","page":"Snow Model","title":"ClimaLand.Snow.snow_liquid_mass_fraction","text":"snow_liquid_mass_fraction(U::FT, SWE::FT, parameters::SnowParameters{FT}) where {FT}\n\nComputes the snow liquid water mass fraction, given the snow water equivalent SWE, snow energy per unit area U, and other needed parameters.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.maximum_liquid_mass_fraction","page":"Snow Model","title":"ClimaLand.Snow.maximum_liquid_mass_fraction","text":"maximum_liquid_mass_fraction(T::FT, ρ_snow::FT, parameters::SnowParameters{FT}) where {FT}\n\nComputes the maximum liquid water mass fraction, given the bulk temperature of the snow T, the density of the snow ρ_snow, and parameters.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.runoff_timescale","page":"Snow Model","title":"ClimaLand.Snow.runoff_timescale","text":"runoff_timescale(z::FT, Ksat::FT, Δt::FT) where {FT}\n\nComputes the timescale for liquid water to percolate and leave the snowpack, given the depth of the snowpack z and the hydraulic conductivity Ksat.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.compute_water_runoff","page":"Snow Model","title":"ClimaLand.Snow.compute_water_runoff","text":"compute_energy_runoff(S::FT, q_l::FT, T::FT, parameters) where {FT}\n\nComputes the rate of change in the snow water equivalent S due to loss of liquid water (runoff) from the snowpack.\n\nRunoff occurs as the snow melts and exceeds the water holding capacity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.energy_from_q_l_and_swe","page":"Snow Model","title":"ClimaLand.Snow.energy_from_q_l_and_swe","text":"energy_from_q_l_and_swe(S::FT, q_l::FT, parameters) where {FT}\n\nA helper function for compute the snow energy per unit area, given snow  water equivalent S, liquid fraction q_l,  and snow model parameters.\n\nNote that liquid water can only exist at the freezing point in this model, so temperature is not required as an input.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.energy_from_T_and_swe","page":"Snow Model","title":"ClimaLand.Snow.energy_from_T_and_swe","text":"energy_from_T_and_swe(S::FT, T::FT, parameters) where {FT}\n\nA helper function for compute the snow energy per unit area, given snow  water equivalent S, bulk temperature T, and snow model parameters.\n\nIf T = Tfreeze, we return the energy as if ql = 0.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_cover_fraction","page":"Snow Model","title":"ClimaLand.Snow.snow_cover_fraction","text":"snow_cover_fraction(x::FT; α = FT(1e-3))::FT where {FT}\n\nReturns the snow cover fraction, assuming it is a heaviside function at 1e-3 meters.\n\nIn the future we can play around with other forms.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#Computing-fluxes-for-snow","page":"Snow Model","title":"Computing fluxes for snow","text":"","category":"section"},{"location":"APIs/Snow/","page":"Snow Model","title":"Snow Model","text":"ClimaLand.Snow.snow_boundary_fluxes!\nClimaLand.Snow.AtmosDrivenSnowBC","category":"page"},{"location":"APIs/Snow/#ClimaLand.Snow.snow_boundary_fluxes!","page":"Snow Model","title":"ClimaLand.Snow.snow_boundary_fluxes!","text":"snow_boundary_fluxes!(bc::AtmosDrivenSnowBC, model::SnowModel, Y, p, t)\n\nUpdates in place various volumetric water flux (m/s) and energy flux (W/m^2) terms for the snow model:\n\np.snow.turbulent fluxes (latent, sensible, and evaporative fluxes)\np.snow.R_n (radiative fluxes)\np.snow.totalwaterflux\np.snow.totalenergyflux\n\nThe two latter fluxes also include contributions from fluxes  due to melt and precipitation, but note that precipitation and melt flux are not computed or updated in snow_boundary_fluxes currently. Instead, they  are updated in update_aux!, which happens prior to the snow_boundary_fluxes! call, and used in the snow_boundary_fluxes! call.\n\nThis function calls the turbulent_fluxes and net_radiation functions, which use the snow surface conditions as well as the atmos and radiation conditions in order to compute the surface fluxes using Monin Obukhov Surface Theory. It also accounts for the presence of other components, if run as part of an integrated land model, and their effect on boundary conditions.\n\n\n\n\n\nsnow_boundary_fluxes!(\n    bc::AtmosDrivenSnowBC,\n    prognostic_land_components::Val{(:snow,)},\n    model::SnowModel{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nComputes the boundary fluxes for the snow model in standalone mode.\n\nThe ground heat flux is assumed to be zero, and the snow surface is  assumed to be bare (no vegetation).\n\n\n\n\n\nsnow_boundary_fluxes!(\n    bc::AtmosDrivenSnowBC,\n    prognostic_land_components::Val{(:snow, :soil)},\n    model::SnowModel{FT},\n    Y,\n    p,\n    t,\n) where {FT}\n\nA method of snow_boundary_fluxes! which computes  the boundary fluxes for the snow model accounting for a heat flux between the soil and snow.\n\nThe snow surface is  assumed to be bare (no vegetation).\n\nCurrently this is almost identical to the method for snow alone, except for the inclusion of the ground heat flux (precomputed by  the integrated land model). However, this will change more if e.g. we allow for transmission of radiation through the snowpack.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Snow/#ClimaLand.Snow.AtmosDrivenSnowBC","page":"Snow Model","title":"ClimaLand.Snow.AtmosDrivenSnowBC","text":"AtmosDrivenSnowBC{\n    A <: AbstractAtmosphericDrivers,\n    B <: AbstractRadiativeDrivers,\n    C::Tuple\n} <: AbstractSnowBC\n\nA struct used to specify the snow fluxes, referred to as ``boundary conditions\", at the surface and bottom of the snowpack, for water and energy.\n\nThese fluxes include turbulent surface fluxes computed with Monin-Obukhov theory, and radiative fluxes.\n\natmos: The atmospheric conditions driving the model\nradiation: The radiative fluxes driving the model\nprognostic_land_components: Prognostic land components present\n\n\n\n\n\n","category":"type"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/#Stomatal-conductance","page":"Medlyn model","title":"Stomatal conductance","text":"","category":"section"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"Stomata play an important role in uptaking CO2 for photosynthesis while limiting water loss during transpiration. Consequently, an accurate depiction of stomatal conductance is required to study leaf energy fluxes, transpiration, and photosynthesis.","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"This section describes multiple models of stomatal conductance implemented in ClimaLand. ","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/#Medlyn-Model","page":"Medlyn model","title":"Medlyn Model","text":"","category":"section"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"The Medlyn model is a semiempirical model that relates stomatal conductance and photosynthesis and is derived from water-use efficiency optimization theory.","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"Transpiration is computed using the stomatal conductance and Monin-Obukhov theory.","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"beginequation\nT = -rho_a g_mathrmeff leftq_a- q_v(T_mathrmleaf rho_mathrmsfc) right\nendequation","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"where T is the transpiration (mass flux of water vapor), q_a is the specific humidity at the lowest level of the atmosphere, q_v(T_mathrmT_leaf rho_mathrmsfc) is the saturated specific humidity over liquid water, given the temperature of the leave T_leaf and air density at the surface rho_sfc. We will approximate T_leaf = T_a and rho_mathrmsfc = rho_a.","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"We also need the effective conductivity, given by","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"beginequation\n    g_mathrmeff = frac1g_mathrmae^-1+g_mathrms^-1\nendequation","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"where g_ae is the aerodynamic conductance, computed by the MOST solve, and g_s is the stomatal conductance to water vapor per unit ground area. The units of all conductances are ms.","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"The stomatal conductance is calculated using the Medlyn stomatal conductance model (Medlyn, 2011), while omitting cuticular and epidermal losses by assuming zero minimum stomatal conductance:","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"beginalign\ng_sm(PAR T VPD c_a) = g_0m + D_rel times m fracA_n(PAR T VPD c_a)c_anonumber \ng_s = fracg_smrho_m\nendalign","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"where D_rel =16 (unitless) is the relative diffusivity of water vapor with respect to CO_2, rho_m is the molar density of water, and m is the Medlyn factor,","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"beginequation\n    m = left( 1 + fracg_1sqrtVPD right) \nendequation","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"where g1 is the slope parameter, inversely proportional to the square root of marginal water use efficiency (Medlyn, 2011). We also have A_n as the biochemical demand for CO_2 calculated using the photosynthesis model (Farquhar, 1980; Equation \\eqref{eq:an}; units of molar flux). The resulting units are ms. g{0,m}$ is a minimum molar conductivity. (subscript m indicates molar).","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"The model has the following parameters:","category":"page"},{"location":"standalone/pages/vegetation/stomatal_conductance/medlyn_model/","page":"Medlyn model","title":"Medlyn model","text":"Constants Symbol Unit Value\nRelative diffusivity of water vapor D_rel - 1.6\nMinimum stomatal conductance g_0 mol/m^2/s 1e-4\nSlope parameter g_1 sqrtPa 790","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../..\"","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/#Background","page":"Adjusting boundary conditions for the soil","title":"Background","text":"","category":"section"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"When solving the partial differential equations describing the storage of water, ice, and energy in soil, boundary conditions must be set for the soil liquid water and energy. The tutorial on boundary conditions for the soil model describes the various boundary condition options we currently support. Many of these are suitable for use when replicating laboratory experiments or other standalone soil settings - for example, a particular experiment may fix the temperature or water content at the top of a soil column. However, when we wish to model the soil interacting with the atmosphere, in standalone or integrated models, the particular boundary condition we use is one that computes the sensible, latent, and radiative fluxes in addition to evaporation and sublimation; this option is called the AtmosDrivenFluxBC. This boundary condition type includes the atmospheric and radiative forcings, the runoff parameterization, and finally, a Tuple which indicates which components of the land are present. The last argument is what we will describe here. For more information on how to supply the prescribed forcing data, please see the tutorial linked here.","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/#Adjusting-the-boundary-conditions-for-the-soil-model-when-run-as-part-of-an-integrated-land-model","page":"Adjusting boundary conditions for the soil","title":"Adjusting the boundary conditions for the soil model when run as part of an integrated land model","text":"","category":"section"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"The presence of other land components (a canopy, snow) affects the boundary conditions of the soil and changes them relative to what they would be if only bare soil was interacting with the atmosphere. For example, the canopy and snow absorb radiation that might otherwise be absorbed by the soil, the canopy intercepts precipitation, and the snow can melt and contribute to soil infiltration. Because of this, we need a way to indicate to the soil model that the boundary conditions must be computed in a different way. In all cases, the same AtmosDrivenFluxBC is used with the exception of the field prognostic_land_components, which is a Tuple of the symbols associated with each component in the land model. For example, if you are simulating the soil model in standalone mode, you would set","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"prognostic_land_components = (:soil,)","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"top_soil_boundary_condition = ClimaLand.Soil.AtmosDrivenFluxBC(atmos_forcing, radiative_forcing, runoff_parameterization, prognostic_land_components)","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"while, if you are simulating both a prognostic canopy and soil model, you would set","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"prognostic_land_components = (:canopy, :soil)","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"top_soil_boundary_condition = ClimaLand.Soil.AtmosDrivenFluxBC(atmos_forcing, radiative_forcing, runoff_parameterization, prognostic_land_components)","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"Note that the land components are always in alphabetical order, and the symbols associated with each land model component are always the same as the name of that component, i.e.,","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"ClimaLand.name(snow_model) = :snow","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"ClimaLand.name(canopy_model) = :canopy","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"ClimaLand.name(soilco2_model) = :soilco2","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"ClimaLand.name(soil_model) = :soil","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"Currently, the only supported options are: (:soil,), (:canopy, :soil, :soilco2), (:snow, :soil).","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/#How-it-works","page":"Adjusting boundary conditions for the soil","title":"How it works","text":"","category":"section"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"When the soil model updates the boundary conditions, it calls the function soil_boundary_fluxes!(bc, ClimaLand.TopBoundary(), soil_model, Δz_top, Y, p, t), where bc is the boundary condition being used at the top of the domain. This function has multiple methods depending on the boundary condition type typeof(bc). When that type is AtmosDrivenFluxBC, the function then calls soil_boundary_fluxes!(bc, Val(bc.prognostic_land_components), soil, Y, p, t). Again multiple dispatch is used, this time to compute the fluxes correctly according to the value of the prognostic_land_components, i.e., based on which components are present.","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"","category":"page"},{"location":"generated/integrated/handling_soil_fluxes/","page":"Adjusting boundary conditions for the soil","title":"Adjusting boundary conditions for the soil","text":"This page was generated using Literate.jl.","category":"page"},{"location":"standalone/README/#DynamicDocs","page":"DynamicDocs","title":"DynamicDocs","text":"","category":"section"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../..\"","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/#Background","page":"Adjusting boundary conditions for the snow","title":"Background","text":"","category":"section"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"When solving the system of equations describing the storage of water and energy in snow, \"boundary conditions\" must be set. These are only true boundary conditions if one considers the equations for water and energy in snow to be discretized PDEs, but they do represent the fluxes at upper boundary (the snow/atmosphere interface) and at the lower boundary (the snow/soil interface), so we refer to them as boundary conditions in order to use a consistent notation with the soil model.","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"At present, the only type of boundary condition the snow model supports is AtmosDrivenSnowBC, which is an attempt at a compact way of indicating that with this choice, the snow model exchanges water and energy with the atmosphere via sensible, latent, and radiative heat fluxes, and by precipitation and sublimation/evaporation. With this choice, the snow model also has exchange fluxes with the soil (melt water, and a conductive ground heat flux). This boundary condition type includes the atmospheric and radiative forcings, and, importantly, a Tuple which indicates which components of the land are present. The last argument is what we will describe here. For more information on how to supply the prescribed forcing data, please see the tutorial linked here. For an explanation of the same design implementation for the Soil model, please see here.","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/#Adjusting-the-boundary-conditions-for-the-snow-model-when-run-as-part-of-an-integrated-land-model","page":"Adjusting boundary conditions for the snow","title":"Adjusting the boundary conditions for the snow model when run as part of an integrated land model","text":"","category":"section"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"The presence of other land components (a canopy, the soil) affects the boundary conditions of the snow and changes them relative to what they would be if only bare snow was interacting with the atmosphere. For example, the canopy absorbs radiation that might otherwise be absorbed by the snow, the canopy intercepts precipitation, and the soil and snow interact thermally at the interface between them. Because of this, we need a way to indicate to the snow model that the boundary conditions must be computed in a different way depending on the components. We do this via the field in the boundary condition of type AtmosDrivenSnowBC via a field prognostic_land_components, which is a Tuple of the symbols associated with each component in the land model. For example, if you are simulating the snow model in standalone mode, you would set","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"prognostic_land_components = (:snow,)","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"boundary_condition = ClimaLand.Snow.AtmosDrivenSnowBC(atmos_forcing, radiative_forcing, prognostic_land_components)","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"while, if you are simulating both a prognostic snow and soil model, you would set","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"prognostic_land_components = (:snow, :soil)","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"boundary_condition = ClimaLand.Snow.AtmosDrivenSnowBC(atmos_forcing, radiative_forcing, prognostic_land_components)","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"Note that the land components are always in alphabetical order, and the symbols associated with each land model component are always the same as the name of that component, i.e.,","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"ClimaLand.name(snow_model) = :snow","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"ClimaLand.name(canopy_model) = :canopy","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"ClimaLand.name(soilco2_model) = :soilco2","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"ClimaLand.name(soil_model) = :soil","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"Currently, the only supported options are: (:snow,), and (:snow, :soil).","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/#How-it-works","page":"Adjusting boundary conditions for the snow","title":"How it works","text":"","category":"section"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"When the snow model computes its boundary fluxes, it calls the function snow_boundary_fluxes!(bc, snow_model, Y, p, t), where bc is the boundary condition of type AtmosDrivenSnowBC. This function then calls snow_boundary_fluxes!(bc, Val(bc.prognostic_land_components), snow, Y, p, t). Here multiple dispatch is used to compute the fluxes correctly according to the value of the prognostic_land_components, i.e., based on which components are present.","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/#Some-important-notes","page":"Adjusting boundary conditions for the snow","title":"Some important notes","text":"","category":"section"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"When the snow model is run in standalone mode (prognostic_land_components = (:snow,)), the ground heat flux is approximate as zero. When the soil and snow model are run together, this flux is computed and affects both the snow and soil.","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"","category":"page"},{"location":"generated/integrated/handling_snow_fluxes/","page":"Adjusting boundary conditions for the snow","title":"Adjusting boundary conditions for the snow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Microbial-respiration","page":"DAMM model","title":"Microbial respiration","text":"","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"This section describes multiple models of soil organic decomposition by microbes, implemented in ClimaLand. ","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/#Dual-Arrhenius-Michaelis-Menten","page":"DAMM model","title":"Dual Arrhenius Michaelis-Menten","text":"","category":"section"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"<iframe src=\"https://clima.westus3.cloudapp.azure.com/jsserve/Rh\"\n   style=\"height:1500px;width:100%;\">\n</iframe>","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"The Dual Arrhenius and Michaelis-Menten (DAMM) kinetics model in ClimaLand.jl follows Davidson et al. 2012. DAMM models heterotrophic respiration (Rh) as a function of soil temperature (T_s) and soil moisture (theta).","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"The rate of respiration, Rh, is expressed as:","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"beginequation\n    Rh = V_textmaxs_xMM_s_xMM_O_2\nendequation","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"where V_textmaxs_x is the maximum potential rate of respiration, MM_s_x represents the availability of substrate, and MM_O_2 is used as the oxygen limitation factor. MM_s_x and MM_O_2 are between 0 (limiting) and 1 (non limiting). V_textmaxs_x, MM_s_x, and MM_O_2 are expressed as:","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"beginequation\n    V_textmaxs_x = alpha_s_x exp(frac-Ea_s_xRT_s)\nendequation","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"beginequation\n    MM_textsx = fracs_xkM_s_x+s_x\nendequation","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"beginequation\n    MM_textO_2 = fracO_2kM_O_2+O_2\nendequation","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"where alpha_s_x is the pre-exponential factor, Ea_s_x is the activation energy of the reaction, R is the gas constant, and T_s is soil temperature. s_x is the concentration of all soluble substrate, and O_2 is the oxygen concentration. kM_s_x and kM_O_2 are the Michaelis constant for soil and oxygen, respectively.","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"The concentration of soluble carbon substrates is affected by soil water content, and specifically by diffusion of substrates through soil water films. Using these underlying principles, s_x is calculated as:","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"beginequation\n    s_x = p_s_xtimesC_somtimes D_liqtimestheta^3\nendequation","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"where C_som is the total amount of soil organic carbon, and p_s_x is the fraction of C_som that is soluble. D_liq is the diffusion coefficient of the soluble carbon. theta is soil moisture.","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"The concentration of O_2 depends on the diffusion of gases within the soil, which is calculated as below:","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"beginequation\n    O_2 = D_Oatimes O_2a times porosity_air^43\nendequation","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"where D_Oa is the diffusion coefficient for O_2 in air, O_2a is the volume fraction of O_2 in air, and porosity_air is the air-filled porosity.","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"The air-filled porosity is calculated by subtracting the soil moisture from the total porosity (nu):","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"beginequation\n    porosity_air = nu - theta\nendequation","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"To sum up, the model has the following parameters:","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"Output Symbol Unit Range\nHeterotrophic respiration Rh mumol m^-2 s^-2 0–25","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"Drivers Symbol Unit Range\nSoil temperature T_s C -20–50\nSoil moisture theta m^3 m^-3 0.0–1.0","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"Parameters Symbol Unit Range\nSoil porosity nu m^3 m^-3 0.0–1.0\nPre-exponential factor alpha_s_x kg C m^-3 s^-1 100e3–300e3\nActivation energy Ea_s_x Jmol^-1 50e3–70e3\nMichaelis constant for soil kM_s_x kg C m^-3 1e-10–0.1\nMichaelis constant for O_2 kM_O_2 m^3 m^-3 1e-10–0.1\nVolumetric fraction of O_2 in the soil air content O_2_a - 0.005–0.5\nFraction of soil carbon that is considered soluble p_s_x - 0.005–0.5\nSoil organic C C_som kg C m^-3 1.0–10.0","category":"page"},{"location":"standalone/pages/soil/biogeochemistry/DAMM_model/","page":"DAMM model","title":"DAMM model","text":"Constants Symbol Unit Value\nAir-filled porosity at soil water potential of -100 cm H₂O (~ 10 Pa) O_a100 - 0.1816\nDiffusivity of soil C substrate in liquid D_liq - 3.17\nDiffusion coefficient of oxygen in air D_Oa - 1.67","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/#Plant-Hydraulics","page":"Van Genuchten model","title":"Plant Hydraulics","text":"","category":"section"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"Additional understanding of stomatal behavior comes from the transport of water through the soil-plant–atmosphere continuum. Plants reduce stomatal conductance as needed to regulate transpiration and prevent desiccation or other hydraulic failure.","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"Specifically, water loss during day-time transpiration drives plants to draw water from the soil by roots and transport it through the stem to leaves. Transpiration provides the force that pulls water from soil. As transpiration is dominant during the day, water in soil near the roots, water in the stem, and water in foliage create a water potential gradient that allows leaves to draw water from the soil.","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"The plant hydraulics code solves for the volumetric water content in the stem and leaf (theta_stem and theta_leaf). It allows for an arbitrary number of stem/leaf compartments, but for now we will start with a single stem and leaf compartment. ","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/#Van-Genuchten-Model","page":"Van Genuchten model","title":"Van Genuchten Model","text":"","category":"section"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"As explained above, soil moisture is an indispensable variable in studying plant water uptake. Van Genuchten (1980) developed a widely used soil moisture retention curve, which is used below to describe plant hydraulics.","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"The volume flux of water q (m/s) between compartments with centers at two heights, z_1 and z_2, is given by Darcy's law as","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"beginalign\n    q = -int_z_1^z_2 k(psi) dh\nendalign","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"where h = psi+z is the head (in meters), and k is the conductance (units of 1/s). As this is the conductance unit that CLM uses, there should be data bases with this information. We approximate this using finite difference as\\footnote{Double check this - the units of k in our code are ms.}","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"beginequation\nq = -int_h_1^h_2 k(psi) dh approx -frack_1(psi_1) + k_2(psi_2)2 * (psi_2 - psi_1) + (z_2 - z_1)\nendequation","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"In order to close the set of equations, the user will have to specify k(psi) and a function psi(theta). In our current implementation, we use a van Genuchten relationship with the same parameters for all compartments, but differing values of K_sat","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"The change of water volume (m^3)  V, in the compartments is then","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"beginalign\n    fracd V_w stemdt = q_rootssigma_roots - q_stemsigma_stem nonumber \n    fracd V_w leafdt = q_stemsigma_stem - tau sigma_leaf\nendalign","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"where tau is a transpiration volume flux per unit emitting area, and sigma is the total emitting/conducting area\\footnote{Note that these are actually the areas at the faces between compartments. In the code, we take the average of the cross section of the compartments to estimate this.}. ","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"This currently holds for a single plant. To convert to fluxes from an entire surface, we can multiply by the number of individuals N. We can make use of the fact that NsigmaA, where A is the area of the ground those N individuals are occupying, is the area index for that plant type. Following CLM, we incorporate a root, stem, and leaf area index (RAI, SAI, LAI) in order to model fluxes across an entire grid cell. ","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"Then we have:","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"beginalign\n    fracd v_stemdt = q_rootsRAI - q_stemSAI nonumber \n    fracd v_leafdt = q_stemSAI - tau LAI\nendalign","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"where v now represents the volume of water in that compartment (of a bulk plant) per unit ground area.","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"We also need to convert from the variable v to psi, in order to compute root extraction with the soil.  To do so, we can convert v to the volumetric water content, and from theta to psi using a van Genuchten relationship. To convert, let the volume of water per area of compartment be V_wstem, and H the typical ``length\" of the compartment. Then","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"beginequation\n    theta_stem=fracV_wstemA_ground times fracA_groundA_stem times frac1H_stem = fracv_stemH_stem times SAI \nendequation","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"Substituting in the volumetric water content, we have","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"beginalign\n    fracd theta_stemdt = fracq_rootsRAI - q_stemSAIH_stem SAI nonumber \n    fracd theta_leafdt = fracq_stemSAI - tau LAIH_leaf LAI\nendalign","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"We can also account for the distribution of roots as a function of depth. A quantity that is modeled in plant hydraulic models is the root fraction P(z), satisfying int P(z) dz = 1. Instead of having a single root at one discrete location, we can distribute the root system over different depths using P(z). The total flux from roots between z and z+dz is given by","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"beginequation\n    dq_roots(z) = -P(z) dz int_h_soil(z)^h_stem k(psi) dh\nendequation","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"so that the net flux for the plant system would sum over this","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"beginequation\n    q_roots  = -int_z_min^z_sfc fracdq_roots(z)dzdz \nendequation","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"where z_min is the minimum soil layer of the simulation. ","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"The sink term of the soil is in terms of a volumetric fraction change, i.e. we need a volume of water per volume of soil per second. We can obtain this with","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"beginequation\n    S(z) = -(RAI) dq_roots(z)dz = (RAI) P(z) int_h_soil(z)^h_stem k(psi) dh\nendequation","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"The sign change occurs in the expression for S(z) because a positive value of q_roots indicates flow from the soil to the plant. This is a sink term for the soil.","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"The model needs the following parameters:","category":"page"},{"location":"standalone/pages/vegetation/plant_hydraulics/van_genuchten_model/","page":"Van Genuchten model","title":"Van Genuchten model","text":"Drivers Symbol Unit Range\nA function of simulation time t given the leaf area index LAI m²/m² 0–10\nThe constant stem area index SAI m²/m² 0–10\nThe constant root area index RAI m²/m² 0–10","category":"page"},{"location":"Contributing/#Contributing","page":"Contribution guide","title":"Contributing","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Thank you for contributing to ClimaLand! We encourage Pull Requests (PRs). Please do not hesitate to ask questions.","category":"page"},{"location":"Contributing/#Some-useful-tips","page":"Contribution guide","title":"Some useful tips","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"When you start working on a new feature branch, make sure you start from main by running: git checkout main.\nMake sure you add tests for your code in test/ and appropriate documentation in the code and/or in docs/. All exported functions and structs must be documented.\nWhen your PR is ready for review, clean up your commit history by squashing and make sure your code is current with ClimateMachine main by rebasing.","category":"page"},{"location":"Contributing/#Continuous-integration","page":"Contribution guide","title":"Continuous integration","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"After rebasing your branch, you can ask for review. Fill out the template and provide a clear summary of what your PR does. When a PR is created or updated, a set of automated tests are run on the PR in our continuous integration (CI) system.","category":"page"},{"location":"Contributing/#Automated-testing","page":"Contribution guide","title":"Automated testing","text":"","category":"section"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"Currently a number of checks are run per commit for a given PR.","category":"page"},{"location":"Contributing/","page":"Contribution guide","title":"Contribution guide","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation rebuilds the documentation for the PR and checks if the docs are consistent and generate valid output.\nTests runs the file test/runtests.jl,  using Pkg.test(). These are a mix of unit tests and fast integration tests.","category":"page"},{"location":"APIs/canopy/CanopyEnergy/#Canopy-Energy-Model","page":"Canopy Energy","title":"Canopy Energy Model","text":"","category":"section"},{"location":"APIs/canopy/CanopyEnergy/","page":"Canopy Energy","title":"Canopy Energy","text":"CurrentModule = ClimaLand.Canopy","category":"page"},{"location":"APIs/canopy/CanopyEnergy/#Methods","page":"Canopy Energy","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/CanopyEnergy/","page":"Canopy Energy","title":"Canopy Energy","text":"ClimaLand.Canopy.canopy_temperature\nClimaLand.Canopy.root_energy_flux_per_ground_area!","category":"page"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.canopy_temperature","page":"Canopy Energy","title":"ClimaLand.Canopy.canopy_temperature","text":"canopy_temperature(model::PrescribedCanopyTempModel, canopy, Y, p, t)\n\nReturns the canopy temperature under the PrescribedCanopyTemp model, where the canopy temperature is assumed to be the same as the atmosphere temperature.\n\n\n\n\n\ncanopy_temperature(model::BigLeafEnergyModel, canopy, Y, p, t)\n\nReturns the canopy temperature under the BigLeafEnergyModel model, where the canopy temperature is modeled prognostically.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.root_energy_flux_per_ground_area!","page":"Canopy Energy","title":"ClimaLand.Canopy.root_energy_flux_per_ground_area!","text":"root_energy_flux_per_ground_area!(\n    fa_energy::ClimaCore.Fields.Field,\n    s::PrognosticSoilConditions,\n    model::Canopy.AbstractCanopyEnergyModel,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nA method computing the energy flux associated with the root-soil water flux, which returns 0 in cases where we do not need to track this quantity: in this case, when the canopy energy is tracked, but we are using a PrescribedSoil model (non-prognostic soil model).\n\nNote that this energy flux is not typically included in land surface models. We account for it when the soil model is prognostic because the soil model includes the energy in the soil water in its energy balance; therefore, in order to conserve energy, the canopy model must account for it as well.\n\n\n\n\n\nroot_energy_flux_per_ground_area!(\n    fa_energy::ClimaCore.Fields.Field,\n    ground::PrescribedGroundConditions{FT},\n    model::AbstractCanopyEnergyModel{FT},\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n) where {FT}\n\nA method which updates the ClimaCore.Fields.Field fa_energy in place with  the energy flux associated with the root-soil water flux for the CanopyModel run in standalone mode, with a PrescribedGroundConditions.This value is ignored and set to zero in this case.\n\nBackground information: This energy flux is not typically included in land surface models. We account for it when the soil model is prognostic because the soil model includes the energy in the soil water in its energy balance; therefore, in order to conserve energy, the canopy model must account for it as well.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/CanopyEnergy/#Types","page":"Canopy Energy","title":"Types","text":"","category":"section"},{"location":"APIs/canopy/CanopyEnergy/","page":"Canopy Energy","title":"Canopy Energy","text":"ClimaLand.Canopy.AbstractCanopyEnergyModel\nClimaLand.Canopy.PrescribedCanopyTempModel\nClimaLand.Canopy.BigLeafEnergyModel","category":"page"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.PrescribedCanopyTempModel","page":"Canopy Energy","title":"ClimaLand.Canopy.PrescribedCanopyTempModel","text":"PrescribedCanopyTempModel{FT} <: AbstractCanopyEnergyModel{FT}\n\nA model for the energy of the canopy which assumes the canopy temperature is the same as the atmosphere temperature prescribed in the PrescribedAtmos struct.\n\nNo equation for the energy of the canopy is solved.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/CanopyEnergy/#ClimaLand.Canopy.BigLeafEnergyModel","page":"Canopy Energy","title":"ClimaLand.Canopy.BigLeafEnergyModel","text":"BigLeafEnergyModel{FT} <: AbstractCanopyEnergyModel{FT}\n\n\n\n\n\n","category":"type"},{"location":"APIs/SurfaceWater/#SurfaceWater","page":"Surface Water Models","title":"SurfaceWater","text":"","category":"section"},{"location":"APIs/SurfaceWater/","page":"Surface Water Models","title":"Surface Water Models","text":"CurrentModule = ClimaLand.Pond","category":"page"},{"location":"APIs/SurfaceWater/#Models","page":"Surface Water Models","title":"Models","text":"","category":"section"},{"location":"APIs/SurfaceWater/","page":"Surface Water Models","title":"Surface Water Models","text":"ClimaLand.Pond.PondModel","category":"page"},{"location":"APIs/SurfaceWater/#ClimaLand.Pond.PondModel","page":"Surface Water Models","title":"ClimaLand.Pond.PondModel","text":"PondModel{FT, D, R} <: AbstractSurfaceWaterModel{FT}\n\nA stand-in model for models like the snow or river model. In standalone mode, a prescribed soil infiltration rate  and precipitation rate control the rate of change of the pond height variable η via an ODE. In integrated LSM mode, the infiltration into the soil will be computed via a different method, and also be applied as a flux boundary condition for the soil model.\n\ndomain: The domain for the pond model\nrunoff: The runoff model for the pond model\n\n\n\n\n\n","category":"type"},{"location":"APIs/SurfaceWater/#Methods-and-Types","page":"Surface Water Models","title":"Methods and Types","text":"","category":"section"},{"location":"APIs/SurfaceWater/","page":"Surface Water Models","title":"Surface Water Models","text":"ClimaLand.Pond.PrescribedRunoff\nClimaLand.Pond.surface_runoff","category":"page"},{"location":"APIs/SurfaceWater/#ClimaLand.Pond.PrescribedRunoff","page":"Surface Water Models","title":"ClimaLand.Pond.PrescribedRunoff","text":"PrescribedRunoff{F1 <: Function, F2 <: Function} <:  AbstractSurfaceRunoff\n\nThe required input for driving the simple pond model: precipitation, as a function of time, soil effective saturation at a depth Δz below the surface, as a function of time, and soil parameters, which affect infiltration.\n\n\n\n\n\n","category":"type"},{"location":"APIs/SurfaceWater/#ClimaLand.Pond.surface_runoff","page":"Surface Water Models","title":"ClimaLand.Pond.surface_runoff","text":"function Pond.surface_runoff(\n    runoff::PrognosticRunoff,\n    Y::ClimaCore.Fields.FieldVector,\n    p::NamedTuple,\n    t,\n)\n\nExtension of the Pond.surface_runoff function, which computes  the surface runoff, for use in an LSM when the runoff is determined prognostically.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/AutotrophicRespiration/#Autotrophic-Respiration","page":"Canopy Autotrophic Respiration","title":"Autotrophic Respiration","text":"","category":"section"},{"location":"APIs/canopy/AutotrophicRespiration/","page":"Canopy Autotrophic Respiration","title":"Canopy Autotrophic Respiration","text":"CurrentModule = ClimaLand.Canopy","category":"page"},{"location":"APIs/canopy/AutotrophicRespiration/#Parameters","page":"Canopy Autotrophic Respiration","title":"Parameters","text":"","category":"section"},{"location":"APIs/canopy/AutotrophicRespiration/","page":"Canopy Autotrophic Respiration","title":"Canopy Autotrophic Respiration","text":"ClimaLand.Canopy.AutotrophicRespirationParameters","category":"page"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.AutotrophicRespirationParameters","page":"Canopy Autotrophic Respiration","title":"ClimaLand.Canopy.AutotrophicRespirationParameters","text":"AutotrophicRespirationParameters{FT<:AbstractFloat}\n\nThe required parameters for the autrophic respiration model, which is based  off of the JULES model. Clark, D. B., et al. \"The Joint UK Land Environment Simulator (JULES), model description–Part 2: carbon fluxes and vegetation dynamics.\" Geoscientific Model Development 4.3 (2011): 701-722.\n\nne: Vcmax25 to N factor (mol CO2 m-2 s-1 kg C (kg C)-1)\nηsl: Live stem wood coefficient (kg C m-3)\nσl: Specific leaf density (kg C m-2 [leaf])\nμr: Ratio root nitrogen to top leaf nitrogen (-), typical value 1.0\nμs: Ratio stem nitrogen to top leaf nitrogen (-), typical value 0.1\nRel: Relative contribution or Rgrowth (-)\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/AutotrophicRespiration/#Methods","page":"Canopy Autotrophic Respiration","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/AutotrophicRespiration/","page":"Canopy Autotrophic Respiration","title":"Canopy Autotrophic Respiration","text":"ClimaLand.Canopy.nitrogen_content\nClimaLand.Canopy.plant_respiration_maintenance\nClimaLand.Canopy.plant_respiration_growth","category":"page"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.nitrogen_content","page":"Canopy Autotrophic Respiration","title":"ClimaLand.Canopy.nitrogen_content","text":"nitrogen_content(\n                 ne::FT, # Mean leaf nitrogen concentration (kg N (kg C)-1)\n                 Vcmax25::FT, #\n                 LAI::FT, # Leaf area index\n                 SAI::FT,\n                 RAI::FT,\n                 ηsl::FT, # live stem  wood coefficient (kg C m-3)\n                 h::FT, # canopy height (m)\n                 σl::FT # Specific leaf density (kg C m-2 [leaf])\n                 μr::FT, # Ratio root nitrogen to top leaf nitrogen (-), typical value 1.0\n                 μs::FT, # Ratio stem nitrogen to top leaf nitrogen (-), typical value 0.1\n                ) where {FT}\n\nComputes the nitrogen content of leafs (Nl), roots (Nr) and stems (Ns).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.plant_respiration_maintenance","page":"Canopy Autotrophic Respiration","title":"ClimaLand.Canopy.plant_respiration_maintenance","text":"plant_respiration_maintenance(\n    Rd::FT, # Dark respiration\n    β::FT, # Soil moisture factor\n    Nl::FT, # Nitrogen content of leafs\n    Nr::FT, # Nitrogen content of roots\n    Ns::FT, # Nitrogen content of stems\n    ) where {FT}\n\nComputes plant maintenance respiration as a function of dark respiration (Rd), the nitrogen content of leafs (Nl), roots (Nr) and stems (Ns), and the soil moisture factor (β).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/AutotrophicRespiration/#ClimaLand.Canopy.plant_respiration_growth","page":"Canopy Autotrophic Respiration","title":"ClimaLand.Canopy.plant_respiration_growth","text":"plant_respiration_growth(\n    Rel::FT, # Factor of relative contribution\n    An::FT, # Net photosynthesis\n    Rpm::FT # Plant maintenance respiration\n    ) where {FT}\n\nComputes plant growth respiration as a function of net photosynthesis (An), plant maintenance respiration (Rpm), and a relative contribution factor, Rel.\n\n\n\n\n\n","category":"function"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../..\"","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/#Using-atmospheric-and-radiative-drivers","page":"Intro to forced site-level runs","title":"Using atmospheric and radiative drivers","text":"","category":"section"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"The goal of this is to outline how to set up simulations driven by prescribed forcing data (``drivers\"). These are grouped into radiative forcing and atmospheric forcing. We will first cover the types of forcing we support, followed by how to specify the driver structs given the forcing data and how to update the values used during a simulation.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/#Types-of-forcing-data","page":"Intro to forced site-level runs","title":"Types of forcing data","text":"","category":"section"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"We currently support site-level simulations and have two site-level driver types, PrescribedAtmosphere and PrescribedRadiativeFluxes.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"The atmosphere driver stores the atmospheric state data as a function of time, including the liquid precipitation rate (m/s), the snow precipitation rate converted into an equivalent rate of liquid water (m/s), the atmopheric pressure (Pa), specific humidity, horizontal wind speed (m/s), temperature (K), CO2 concentration (mol/mol), and the height at which these measurements were taken (currently assumed to be the same value for all variables).","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"The radiative fluxes driver stores the data required to specify the radiative forcing. We currently support only a single downwelling shortwave and longwave flux (W/m^2). The radiative driver is also where a function which computes the zenith angle for the site is stored.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Both drivers store the start date for the data/simulation. This is the DateTime object which corresponds to the time at which t=0 in the simulation. Additionally, for site-level runs, both drivers store the forcing data as a spline function fit to the data which takes the time t as an argument, where t is the simulation time measured in seconds since the start date. The start date should be in UTC.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Note: for coupled runs, corresponding types CoupledAtmosphere and CoupledRadiativeFluxes exist. However, these are not defined in ClimaLand, but rather inside of the Clima Coupler repository.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/#Creating-site-level-drivers-for-radiation","page":"Intro to forced site-level runs","title":"Creating site-level drivers for radiation","text":"","category":"section"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"First, assume that we have data stored for the longwave and shortwave radiation at a particular site, and that we have read it in to an array, along with the times at which the observations were made and the latitude and longitude of the site.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"using Dates\nusing Insolation # for computing zenith angle given lat, lon, time.\nusing ClimaLand\nimport ClimaLand.Parameters as LP\nimport ClimaParams","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Assume the local_datetime array is read in from the data file.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"local_datetime = DateTime(2013):Dates.Hour(1):DateTime(2013, 1, 7); # one week, hourly data","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Timezone (offset of local time from UTC in hrs)","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"time_offset = 7;","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Site latitude and longitude","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"lat = 38.7441; # degree\nlong = -92.2000; # degree","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Compute the start date in UTC, and convert local datetime vector into a vector of seconds since the start date","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"start_date = local_datetime[1] + Dates.Hour(time_offset);\ndata_dt = 3600.0;\nseconds = 0:data_dt:((length(local_datetime) - 1) * data_dt);","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Assume the downwelling long and shortwave radiation are read in from the file and are measured at the times in local_datetime. Here, we'll just make them up periodic on daily timescales:","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"T = @. 298.15 + 5.0 * sin(2π * (seconds - 3600 * 6) / (3600 * 24));\nLW_d = 5.67 * 10^(-8) .* T .^ 4;\nSW_d = @. max(1400 * sin(2π * (seconds - 3600 * 6) / (3600 * 24)), 0.0);","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Next, fit interpolators to the data. These interpolators are what are stored in the driver function. Then we can evaluate the radiative forcing at any simulation time (and not just at times coinciding with measurements). By default, linear interpolation is used.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"LW_d = TimeVaryingInput(seconds, LW_d)\nSW_d = TimeVaryingInput(seconds, SW_d);","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Finally, for many models we also need to specify the function for computing the zenith angle as a function of simulation time. To do so, we use the Insolation package as follows:","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"earth_param_set = LP.LandParameters(Float64);\ninsol_params = earth_param_set.insol_params # parameters of Earth's orbit required to compute the insolation\nfunction zenith_angle(\n    t,\n    start_date;\n    latitude = lat,\n    longitude = long,\n    insol_params = insol_params,\n)\n    current_datetime = start_date + Dates.Second(round(t)) # Time in UTC\n\n    d, δ, η_UTC = (Insolation.helper_instantaneous_zenith_angle(\n        current_datetime,\n        start_date,\n        insol_params,\n    ))\n\n\n    return Insolation.instantaneous_zenith_angle(\n        d,\n        δ,\n        η_UTC,\n        longitude,\n        latitude,\n    )[1]\nend;","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"Lastly, we store the interpolators for downwelling fluxes and the zenith angle function in the PrescribedRadiativeFluxes struct.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"radiation = ClimaLand.PrescribedRadiativeFluxes(\n    Float64,\n    SW_d,\n    LW_d,\n    start_date;\n    θs = zenith_angle,\n);","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/#Updating-the-driver-variables-during-the-simulation","page":"Intro to forced site-level runs","title":"Updating the driver variables during the simulation","text":"","category":"section"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"The values for LWd, SWd, and zenith angle θ_s are stored in the simulation/model cache p under the name drivers. When you initialize the variables and cache of a model, the cache p will be returned with memory allocated but all values set to zero:","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"p = (; drivers = (LW_d = [0.0], SW_d = [0.0], θs = [0.0]));","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"In order to update them, we can make use of default update functions:","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"update_radiation! = ClimaLand.make_update_drivers(radiation)\nt0 = seconds[1] # midnight local time\nupdate_radiation!(p, t0);\n@show(p.drivers);","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"p.drivers = (LW_d = [418.7382685853159], SW_d = [0.0], θs = [2.814306258618376])\n","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"During a simulation, the drivers are updated in place in p.drivers via a \"callback\", which is a function which is called a specified times or when certain criteria are met during a simulation. In general, then, we don't update drivers every timestep, but less frequently. For example, the simulation timestep may be 10 minutes, but we may only update the drivers every three hours:","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"updateat = collect(seconds[1]:(3600 * 3):seconds[end]);\nupdatefunc = update_radiation!;\ncb = ClimaLand.DriverUpdateCallback(updateat, updatefunc);","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"This callback must then be provided to the simulation solve function.","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/#Using-ERA5-data","page":"Intro to forced site-level runs","title":"Using ERA5 data","text":"","category":"section"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"If you wish to force your ClimaLand simulation with ERA5 reanalysis data, there is a helper function which can make this easier than specifying each atmospheric variable as individual TimeVaryingInput objects, and then making the PrescribedAtmosphere struct. You first need a local path to the netcdf file with the ERA5 data. This file must have the following variables:","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"\"tp\" Total precipitation as a mass/m^2/hour (accumulated over an hour)\n\"sf\" Snow precipitation as a mass/m^2/hour (accumulated over an hour)\n\"u10n\", \"v10n\", Neutral wind speed components in the horizontal, at 10m, in m/s\n\"d2m\", Dewpoint temperature at 2m in K\n\"t2m\", Air temperature at 2m in K\n\"sp\", Surface pressure in Pa\n\"ssrd\", Downwelling shortwave radiation in J/m^2/hour (accumulated over an hour)\n\"strd\", Downwelling longwave radiation J/m^2/hour (accumulated over an hour)","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"You also need the surface_space of your simulation (corresponding to the grid being used), the floating point type of the simulation FT, the ClimaLand earth_param_set, and the start_date, which should be a date after the first date in your ERA5 netcdf file and before the last date. Then you can access the atmospheric and radiative drivers like:","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"atmos, radiation = ClimaLand.prescribed_forcing_era5(era5_ncdata_path,\n                                                     surface_space,\n                                                     start_date,\n                                                     earth_param_set,\n                                                     FT)","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"","category":"page"},{"location":"generated/shared_utilities/driver_tutorial/","page":"Intro to forced site-level runs","title":"Intro to forced site-level runs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/canopy/Photosynthesis/#Photosynthesis","page":"Canopy Photosynthesis","title":"Photosynthesis","text":"","category":"section"},{"location":"APIs/canopy/Photosynthesis/","page":"Canopy Photosynthesis","title":"Canopy Photosynthesis","text":"CurrentModule = ClimaLand.Canopy","category":"page"},{"location":"APIs/canopy/Photosynthesis/#Parameters","page":"Canopy Photosynthesis","title":"Parameters","text":"","category":"section"},{"location":"APIs/canopy/Photosynthesis/","page":"Canopy Photosynthesis","title":"Canopy Photosynthesis","text":"ClimaLand.Canopy.SIFParameters\nClimaLand.Canopy.FarquharParameters\nClimaLand.Canopy.OptimalityFarquharParameters","category":"page"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.SIFParameters","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.SIFParameters","text":"SIFParameters{FT<:AbstractFloat}\n\nThe required parameters for the SIF parameterisation  Lee et al, 2015. Global Change Biology 21, 3469-3477, doi:10.1111/gcb.12948.\n\nkf: The rate coefficient for florescence, unitless\nkd_p1: Parameter used to compute the rate coefficient for heat loss in dark-adapted conditions, Tol et al. 2014, unitless\nkd_p2: Parameter used to compute the rate coefficient for heat loss in dark-adapted conditions, Tol et al. 2014, unitless\nmin_kd: Parameter used to compute the rate coefficient for heat loss in dark-adapted conditions, Tol et al. 2014, unitless\nkn_p1: Parameter used to compute the rate coefficient for heat loss in light-adapted conditions, Lee et al 2013 (unitless)\nkn_p2: Parameter used to compute the rate coefficient for heat loss in light-adapted conditions, Lee et al 2013 (unitless)\nkp: Rate coefficient for photochemical quenching\nkappa_p1: Slope of line relating leaf-level fluorescence to spectrometer-observed fluorescence as a function of Vcmax 25. Lee et al 2015.\nkappa_p2: Intercept of line relating leaf-level fluorescence to spectrometer-observed fluorescence as a function of Vcmax 25.  Lee et al 2015.\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.FarquharParameters","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.FarquharParameters","text":"FarquharParameters{\n    FT<:AbstractFloat,\n    MECH <: Union{FT, ClimaCore.Fields.Field},\n    VC <: Union{FT, ClimaCore.Fields.Field},\n}\n\nThe required parameters for the Farquhar photosynthesis model.\n\nVcmax25: Vcmax at 25 °C (mol CO2/m^2/s)\nΓstar25: Γstar at 25 °C (mol/mol)\nKc25: Michaelis-Menten parameter for CO2 at 25 °C (mol/mol)\nKo25: Michaelis-Menten parameter for O2 at 25 °C (mol/mol)\nΔHkc: Energy of activation for CO2 (J/mol)\nΔHko: Energy of activation for oxygen (J/mol)\nΔHVcmax: Energy of activation for Vcmax (J/mol)\nΔHΓstar: Energy of activation for Γstar (J/mol)\nΔHJmax: Energy of activation for Jmax (J/mol)\nΔHRd: Energy of activation for Rd (J/mol)\nTo: Reference temperature equal to 25 degrees Celsius (K)\noi: Intercelluar O2 concentration (mol/mol); taken to be constant\nϕ: Quantum yield of photosystem II (Bernacchi, 2003; unitless)\nθj: Curvature parameter, a fitting constant to compute J, unitless\nf: Constant factor appearing the dark respiration term, equal to 0.015.\nsc: Sensitivity to low water pressure, in the moisture stress factor, (Pa^{-1}) [Tuzet et al. (2003)]\npc: Reference water pressure for the moisture stress factor (Pa) [Tuzet et al. (2003)]\nis_c3: Photosynthesis mechanism: 1.0 indicates C3, 0.0 indicates C4\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.OptimalityFarquharParameters","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.OptimalityFarquharParameters","text":"OptimalityFarquharParameters{FT<:AbstractFloat}\n\nThe required parameters for the optimality Farquhar photosynthesis model. Currently, only C3 photosynthesis is supported.\n\nis_c3: Photosynthesis mechanism: C3 only\nΓstar25: Γstar at 25 °C (mol/mol)\nKc25: Michaelis-Menten parameter for CO2 at 25 °C (mol/mol)\nKo25: Michaelis-Menten parameter for O2 at 25 °C (mol/mol)\nΔHkc: Energy of activation for CO2 (J/mol)\nΔHko: Energy of activation for oxygen (J/mol)\nΔHVcmax: Energy of activation for Vcmax (J/mol)\nΔHΓstar: Energy of activation for Γstar (J/mol)\nΔHJmax: Energy of activation for Jmax (J/mol)\nΔHRd: Energy of activation for Rd (J/mol)\nTo: Reference temperature equal to 25 degrees Celsius (K)\noi: Intercellular O2 concentration (mol/mol); taken to be constant\nϕ: Quantum yield of photosystem II (Bernacchi, 2003; unitless)\nθj: Curvature parameter, a fitting constant to compute J, unitless\nf: Constant factor appearing the dark respiration term, equal to 0.015.\nsc: Fitting constant to compute the moisture stress factor (Pa^{-1})\npc: Fitting constant to compute the moisture stress factor (Pa)\nc: Constant describing cost of maintaining electron transport (unitless)\n\n\n\n\n\n","category":"type"},{"location":"APIs/canopy/Photosynthesis/#Methods","page":"Canopy Photosynthesis","title":"Methods","text":"","category":"section"},{"location":"APIs/canopy/Photosynthesis/","page":"Canopy Photosynthesis","title":"Canopy Photosynthesis","text":"ClimaLand.Canopy.arrhenius_function\nClimaLand.Canopy.intercellular_co2\nClimaLand.Canopy.co2_compensation\nClimaLand.Canopy.rubisco_assimilation\nClimaLand.Canopy.light_assimilation\nClimaLand.Canopy.max_electron_transport\nClimaLand.Canopy.electron_transport\nClimaLand.Canopy.net_photosynthesis\nClimaLand.Canopy.optimality_max_photosynthetic_rates\nClimaLand.Canopy.moisture_stress\nClimaLand.Canopy.dark_respiration\nClimaLand.Canopy.compute_GPP\nClimaLand.Canopy.MM_Kc\nClimaLand.Canopy.MM_Ko\nClimaLand.Canopy.compute_Vcmax","category":"page"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.arrhenius_function","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.arrhenius_function","text":"arrhenius_function(T::FT, To::FT, R::FT, ΔH::FT)\n\nComputes the Arrhenius function at temperature T given the reference temperature To=298.15K, the universal gas constant R, and the energy activation ΔH.\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.intercellular_co2","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.intercellular_co2","text":"intercellular_co2(ca::FT, Γstar::FT, medlyn_factor::FT) where{FT}\n\nComputes the intercellular CO2 concentration (mol/mol) given the atmospheric concentration (ca, mol/mol), the CO2 compensation (Γstar,  mol/mol), and the Medlyn factor (unitless).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.co2_compensation","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.co2_compensation","text":"co2_compensation(Γstar25::FT,\n                 ΔHΓstar::FT,\n                 T::FT,\n                 To::FT,\n                 R::FT) where {FT}\n\nComputes the CO2 compensation point (Γstar), in units of mol/mol, as a function of its value at 25 °C (Γstar25), a constant energy of activation (ΔHΓstar), a standard temperature (To), the unversal gas constant (R), and the temperature (T).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.rubisco_assimilation","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.rubisco_assimilation","text":"rubisco_assimilation(is_c3::AbstractFloat, args...)\n\nCalls the correct rubisco assimilation function based on the is_c3.\n\nA is_c3 value of 1.0 corresponds to C3 photosynthesis and calls c3_rubisco_assimilation, while 0.0 corresponds to C4 photsynthesis and calls c4_rubisco_assimilation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.light_assimilation","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.light_assimilation","text":"light_assimilation(is_c3::AbstractFloat, args...)\n\nCalls the correct light assimilation function based on the is_c3.\n\nA is_c3 value of 1.0 corresponds to C3 photosynthesis and calls c3_light_assimilation, while 0.0 corresponds to C4 photsynthesis and calls c4_light_assimilation.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.max_electron_transport","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.max_electron_transport","text":"max_electron_transport(Vcmax::FT) where {FT}\n\nComputes the maximum potential rate of electron transport (Jmax), in units of mol/m^2/s, as a function of Vcmax at 25 °C (Vcmax25), a constant (ΔHJmax), a standard temperature (To), the unversal gas constant (R), and the temperature (T).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.electron_transport","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.electron_transport","text":"electron_transport(APAR::FT,\n                   Jmax::FT,\n                   θj::FT,\n                   ϕ::FT) where {FT}\n\nComputes the rate of electron transport (J), in units of mol/m^2/s, as a function of the maximum potential rate of electron transport (Jmax), absorbed photosynthetically active radiation (APAR), an empirical \"curvature parameter\" (θj; Bonan Eqn 11.21) and the quantum yield of photosystem II (ϕ).\n\nSee Ch 11, G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.net_photosynthesis","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.net_photosynthesis","text":"net_photosynthesis(Ac::FT,\n                   Aj::FT,\n                   Rd::FT,\n                   β::FT) where {FT}\n\nComputes the total net carbon assimilation (An), in units of mol CO2/m^2/s, as a function of the Rubisco limiting factor (Ac), the electron transport limiting rate (Aj), dark respiration (Rd), and the moisture stress factor (β).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.optimality_max_photosynthetic_rates","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.optimality_max_photosynthetic_rates","text":"optimalitymaxphotosynthetic_rates(APAR::FT,  θj::FT, ϕ::FT, oi::FT, ci::FT, Γstar::FT, Kc::FT, Ko::FT)\n\nComputes the photosynthesis rates Vcmax and Jmax in mol/m^2/s given absorbed photosynthetically active radiation (APAR), an empirical \"curvature parameter\" (θj; Bonan Eqn 11.21)  the quantum yield of photosystem II (ϕ), the intercellular o2 content (oi), the intercellular CO2 concentration (ci), Γstar, and Kc and Ko.\n\nSee Smith et al. 2019.\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.moisture_stress","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.moisture_stress","text":"moisture_stress(pl::FT,\n                sc::FT,\n                pc::FT) where {FT}\n\nComputes the moisture stress factor (β), which is unitless,  as a function of a constant (sc, 1/Pa), a reference pressure (pc, Pa), and the leaf water pressure (pl, Pa) .\n\nSee Eqn 12.57 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.dark_respiration","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.dark_respiration","text":"dark_respiration(Vcmax25::FT,\n                 β::FT,\n                 f::FT,\n                 ΔHkc::FT,\n                 T::FT,\n                 To::FT,\n                 R::FT) where {FT}\n\nComputes dark respiration (Rd), in units of mol CO2/m^2/s, as a function of the maximum rate of carboxylation of Rubisco (Vcmax25), and the moisture stress factor (β), an empirical factor f is equal to 0.015, a constant (ΔHRd), a standard temperature (To), the unversal gas constant (R), and the temperature (T).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_GPP","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.compute_GPP","text":"compute_GPP(An::FT,\n         K::FT,\n         LAI::FT,\n         Ω::FT) where {FT}\n\nComputes the total canopy photosynthesis (GPP) as a function of the total net carbon assimilation (An), the extinction coefficient (K), leaf area index (LAI) and the clumping index (Ω).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.MM_Kc","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.MM_Kc","text":"MM_Kc(Kc25::FT,\n      ΔHkc::FT,\n      T::FT,\n      To::FT,\n      R::FT) where {FT}\n\nComputes the Michaelis-Menten coefficient for CO2 (Kc), in units of mol/mol, as a function of its value at 25 °C (Kc25), a constant (ΔHkc), a standard temperature (To), the unversal gas constant (R), and the temperature (T).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.MM_Ko","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.MM_Ko","text":"MM_Ko(Ko25::FT,\n      ΔHko::FT,\n      T::FT,\n      To::FT,\n      R::FT) where {FT}\n\nComputes the Michaelis-Menten coefficient for O2 (Ko), in units of mol/mol, as a function of its value at 25 °C (Ko25), a constant (ΔHko), a standard temperature (To), the universal gas constant (R), and the temperature (T).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"APIs/canopy/Photosynthesis/#ClimaLand.Canopy.compute_Vcmax","page":"Canopy Photosynthesis","title":"ClimaLand.Canopy.compute_Vcmax","text":"compute_Vcmax(Vcmax25::FT,\n       T::FT,\n       To::FT,\n       R::FT,\n       ep5::FT) where {FT}\n\nComputes the maximum rate of carboxylation of Rubisco (Vcmax), in units of mol/m^2/s, as a function of temperature (T), Vcmax at the reference temperature 25 °C (Vcmax25), the universal gas constant (R), and the reference temperature (To).\n\nSee Table 11.5 of G. Bonan's textbook, Climate Change and Terrestrial Ecosystem Modeling (2019).\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#For-Users","page":"Getting Started","title":"For Users","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, download and install Julia by following the instructions at https://julialang.org/downloads/. Then, you can install the ClimaLand package by doing:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ] # Enter Package REPL mode\nPkg> add ClimaLand # Install ClimaLand\nPkg> # Go back to Julia REPL mode\nJulia> using ClimaLand","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A typical land simulation employs several different parameterizations to model the various land-surface processes. Let's start our journet into ClimaLand by looking at one of those.","category":"page"},{"location":"getting_started/#Parameterization","page":"Getting Started","title":"Parameterization","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's start with a basic example: compute canopy gross photosynthesis (GPP).","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using ClimaLand\n@doc ClimaLand.Canopy.compute_GPP","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As you can see, our parameterization for GPP is located in the Canopy Module, and requires four arguments. For example, with An = 5 µmol m⁻² s⁻¹, K = 0.5, LAI = 3 m² m⁻², Ω = 0.7, you can compute GPP like below:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"import ClimaLand.Canopy as canopy\ncanopy.compute_GPP(5.0, 0.5, 3.0, 0.7)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Et voilà!","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that our package ParamViz allows interactive visualisation of our parameterizations. See examples in the standalone models pages.","category":"page"},{"location":"getting_started/#ClimaLand-structure","page":"Getting Started","title":"ClimaLand structure","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ClimaLand contains multiple modules. They are listed below:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using MethodAnalysis, ClimaLand\nchild_modules(ClimaLand)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To explore what modules, functions and types are exported in a particular module, you can use About.jl:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using ClimaLand\nusing About\nabout(ClimaLand.Soil.Biogeochemistry)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To see the documentation about a particular module, function or type, you can use ? to go in help mode in the REPL, or @doc as in Parameterization above.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"EditURL = \"https://github.com/CliMA/ClimaLand.jl/../../../../..\"","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/#Seasonal-Snow-Timeseries-Generation-with-a-Neural-Network","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"","category":"section"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"This tutorial explains how to make use of the code developed for forecasting seasonal snow depth evolution, using a neural network with structurally-enforced constraints. The following steps through a basic use-case of the system on an already-cleaned dataset, though exploration of optional keyword arguments in the developed code and additional tools for scraping data (explained in the data tutorial) provide for a richer set of functionality.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"The updates of the neural snow model follow the equation","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"fracdzdt = mathcalMleft(z SWE φ R v T_air P_snowright)","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"where","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"t is the time (s),\nz is the snow depth (m),\nmathcalM is the neural network,\nSWE is the Snow Water Equivalent, or the height of water if all the snow melted (m),\nφ is the relative humidity (0-1),\nR is the solar radiation (W/m²).\nv is the wind speed (W/m²).\nT_air is the air temperature (degrees C).\nP_snow is the water equivalent rate of snow precipitation (m/s).","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"The model is a 1D model to permit utilization over any desired grid resolution and shape.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"We will use the forcings and snow depth data as a validation of the model, so the initial conditions will be the initial value provided in the existing data.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"We begin by importing the developed code to create and run the neural network, as well as some preliminary packages:","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"using ClimaLand\nusing DataFrames, CSV, HTTP, Dates, Flux, StatsBase, cuDNN","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"The code lives in an extenson that we have to manually load. The extension can be loaded only if \"CSV\", \"HTTP\", \"Flux\", \"StatsBase\", \"cuDNN\" and \"ClimaLand\" are loaded.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"DataTools = Base.get_extension(ClimaLand, :NeuralSnowExt).DataTools\nModelTools = Base.get_extension(ClimaLand, :NeuralSnowExt).ModelTools;","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"and also, for this tutorial, some purpose-made functions for displaying the output. A similar analysis_tools.jl file exists alongside display_tools.jl for some basic functions for analyzing/scoring the model, if desired.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"using ClimaLand\ncode_dir = joinpath(pkgdir(ClimaLand), \"docs/tutorials/standalone/Snow\")\ninclude(joinpath(code_dir, \"display_tools.jl\"));","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"Next, we set up values of the network hyperparameters, including the number of epochs to train it, as well as the width parameter n as outlined in the associated parameter, and the two loss function hyperparameters n_1, n_2.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"n = 4\nn1 = 2\nn2 = 4;","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"We next outline which variables in the dataset will be used as predictors, calling them by their column name as a Symbol. The number and choice of these can be changed to reflect any dataset. Another column is specified as the target variable, in this case, the fracdzdt column.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"pred_vars = [\n    :z,\n    :SWE,\n    :rel_hum_avg,\n    :sol_rad_avg,\n    :wind_speed_avg,\n    :air_temp_avg,\n    :dprecipdt_snow,\n]\ntarget = :dzdt;","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"Specifying the indices of the depth and precipitation variables (used in the constraints) and the total number of input features will be necessary when creating the model, so we will specify them here as well.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"nfeatures = length(pred_vars)\nz_idx = 1\np_idx = 7;","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"We next read in the already-cleaned training dataset, though for custom datasets there is plenty of functionality provided in the DataTools module to scrape SNOTEL data directly. We also set the unit timestep seen in this data (daily, so 1 day) to be used for setting the network's constraints as well as generating timeseries during usage. To see the code that generated this data file, check out the data tutorial. We also specify the maximum gap size in the data (in units of Δt) that the network can traverse before requiring a reset, via hole_thresh.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"training_data_download_link = \"https://caltech.box.com/shared/static/1gfyh71c44ljzb9xbnza3lbzj6p9723x.csv\"\ntesting_data_download_link = \"https://caltech.box.com/shared/static/qb2ze1wcc1a37fgt5k9wsj27gpoh39ax.csv\"\ndata_train = CSV.read(HTTP.get(training_data_download_link).body, DataFrame)\nvaldata = CSV.read(HTTP.get(testing_data_download_link).body, DataFrame)\nΔt = Second(86400)\nhole_thresh = 5;","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"With this, we can begin the actual usage pipeline. First, we split the precipitation feature into rain and snow constituents, and apply a set of filters before extracting the necessary features with prep_data (the split already exists in the testing data):","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"usedata = DataTools.prep_data(data_train);","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"After this, we determine scalings for the input and target data that are conducive to beneficial weight updates. In this case, the target data during training will be scaled in the -1 to 1 range, and the neural network will scale input features according to their standard deviations (no shifting is carried out in this case, so that the physical meaning of \"0\" is preserved). This data is then converted into matrix form for ease of its conversion into a Flux DataLoader object, later, during training.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"out_scale = maximum(abs.(usedata[!, target]))\nin_scales = std.(eachcol(select(usedata, pred_vars)))\nx_train, y_train = DataTools.make_data(usedata, pred_vars, target, out_scale);","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"We then create the model itself given the hyperparameters specified above, and indicate which features are to be used to determine the boundary constraints on the network, and return the trainable weights for the overall model.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"model = ModelTools.make_model(nfeatures, n, z_idx, p_idx, in_scale = in_scales)\nps = ModelTools.get_model_ps(model);","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"As training updates are better with the scaled data, we have to modify the timescale and output scaling of the model structure prior to training. This step is undone/reset after training is over.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"ModelTools.settimescale!(model, Dates.value(Δt) * out_scale)\nModelTools.setoutscale!(model, 1.0);","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"With that, training is as simple as calling the trainmodel! function:","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"print(\"\\nTraining model!\\n\")\nModelTools.trainmodel!(model, ps, x_train, y_train, n1, n2, verbose = true);","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"\nTraining model!\nEpoch: 10 | training loss: 0.0027334255\nEpoch: 20 | training loss: 0.0027171127\nEpoch: 30 | training loss: 0.0026918126\nEpoch: 40 | training loss: 0.0026712723\nEpoch: 50 | training loss: 0.0026081668\nEpoch: 60 | training loss: 0.0025932537\nEpoch: 70 | training loss: 0.0026110425\nEpoch: 80 | training loss: 0.0025902253\nEpoch: 90 | training loss: 0.0025621695\nEpoch: 100 | training loss: 0.00258808\n","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"To show the model's output on some of our training data in physically meaningful units, we first reset the timesacle and output scaling constants. From there, all we do is pass the dataframe for a given SNOTEL site and the trained model to the make_timeseries function, and we can compare the result to the actual data.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"ModelTools.setoutscale!(model, out_scale)\nModelTools.settimescale!(model, Dates.value(Δt));","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"For instance, let's show the results on SNOTEL site 1286 (Slagamount Lakes site, Montana):","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"Note that gaps in the data are shown as shaded regions on the plotted timeseries.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"site_id = 1286\nsitedata = usedata[usedata[!, :id] .== site_id, :]\ntrue_series = sitedata[!, :z]\npred_series, _, _ =\n    ModelTools.make_timeseries(model, sitedata, Δt, hole_thresh = hole_thresh)\nptitle = \"Slagamount Lakes, Snow Depth (m)\"\nsiteplot(\n    ptitle,\n    sitedata[!, :date],\n    [true_series, pred_series],\n    [\"Data\", \"Neural Model\"],\n    [:black, :red],\n    savename = \"base_tutorial_plot1.png\",\n    display_plot = false,\n);","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"(Image: )","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"Or, alternatively, SNOTEL site 1070 (Anchorage Hillside, Alaska) from the testing data:","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"site_id = \"1070\" #string format for the testing ids is due to non-numerical testing site codes.\nsitedata = valdata[valdata[!, :id] .== site_id, :]\ntrue_series = sitedata[!, :z]\npred_series, _, _ =\n    ModelTools.make_timeseries(model, sitedata, Δt, hole_thresh = hole_thresh)\nptitle = \"Anchorage Hillside, Snow Depth (m)\"\nsiteplot(\n    ptitle,\n    sitedata[!, :date],\n    [true_series, pred_series],\n    [\"Data\", \"Neural Model\"],\n    [:black, :red],\n    savename = \"base_tutorial_plot2.png\",\n    display_plot = false,\n);","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"(Image: )","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"Additional functionality can be explored through the optional arguments to the developed functions, though creating timeseries for any validation dataset can be handled with a similar call to make_timeseries. The timestep Δt (as well as a matching call to the network with settimescale!) can also be changed to different values to evaluate the network's capability on validation data with different temporal resolutions, without the need for retraining.","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"","category":"page"},{"location":"generated/standalone/Snow/base_tutorial/","page":"Seasonal Snow Timeseries Generation with a Neural Network","title":"Seasonal Snow Timeseries Generation with a Neural Network","text":"This page was generated using Literate.jl.","category":"page"}]
}
